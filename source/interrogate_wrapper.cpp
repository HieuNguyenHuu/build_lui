/*
 * This file was generated by:
 * C:\Panda3D-1.10.13-x64\bin\interrogate -fnames -string -refcount -assert -python-native -SC:\Panda3D-1.10.13-x64\include/parser-inc -SC:\Panda3D-1.10.13-x64\include/ -srcdir . -oc interrogate_wrapper.cpp -od interrogate.in -module lui -library lui -nomangle -DINTERROGATE -DCPPPARSER -D__STDC__=1 -D__cplusplus=201103L -D__inline -D_X86_ -DWIN32_VC -DWIN32 -D_WIN32 -DWIN64_VC -DWIN64 -D_WIN64 -D_MSC_VER=1600 -D"__declspec(param)=" -D__cdecl -D_near -D_far -D__near -D__far -D__stdcall .\config_lui.cxx .\config_lui.h .\luiAtlas.cxx .\luiAtlas.h .\luiAtlasDescriptor.cxx .\luiAtlasDescriptor.h .\luiAtlasPacker.cxx .\luiAtlasPacker.h .\luiAtlasPool.cxx .\luiAtlasPool.h .\luiBaseElement.cxx .\luiBaseElement.h .\luiBaseLayout.cxx .\luiBaseLayout.h .\luiBounds.cxx .\luiBounds.h .\luiChunkDescriptor.cxx .\luiChunkDescriptor.h .\luiColorable.cxx .\luiColorable.h .\luiEventData.cxx .\luiEventData.h .\luiExpression.cxx .\luiExpression.h .\luiFontPool.cxx .\luiFontPool.h .\luiHorizontalLayout.cxx .\luiHorizontalLayout.h .\luiInputHandler.cxx .\luiInputHandler.h .\luiIterators.h .\luiObject.cxx .\luiObject.h .\luiRect.cxx .\luiRect.h .\luiRegion.cxx .\luiRegion.h .\luiRoot.cxx .\luiRoot.h .\luiSprite.cxx .\luiSprite.h .\luiText.cxx .\luiText.h .\luiVertexChunk.cxx .\luiVertexChunk.h .\luiVertexData.h .\luiVertexPool.cxx .\luiVertexPool.h .\luiVerticalLayout.cxx .\luiVerticalLayout.h
 *
 */

#include "dtoolbase.h"
#include "interrogate_request.h"
#include "dconfig.h"
#include "pnotify.h"
#include <sstream>
#define PANDA_LIBRARY_NAME_lui
#include "py_panda.h"
#include "extension.h"
#include "dcast.h"

#include "./config_lui.h"
#include "./luiAtlas.h"
#include "./luiAtlasDescriptor.h"
#include "./luiAtlasPacker.h"
#include "./luiAtlasPool.h"
#include "./luiBaseElement.h"
#include "./luiBaseLayout.h"
#include "./luiBounds.h"
#include "./luiChunkDescriptor.h"
#include "./luiColorable.h"
#include "./luiEventData.h"
#include "./luiExpression.h"
#include "./luiFontPool.h"
#include "./luiHorizontalLayout.h"
#include "./luiInputHandler.h"
#include "./luiIterators.h"
#include "./luiObject.h"
#include "./luiRect.h"
#include "./luiRegion.h"
#include "./luiRoot.h"
#include "./luiSprite.h"
#include "./luiText.h"
#include "./luiVertexChunk.h"
#include "./luiVertexData.h"
#include "./luiVertexPool.h"
#include "./luiVerticalLayout.h"
#include "buttonEventList.h"
#include "config_lui.h"
#include "dataGraphTraverser.h"
#include "dconfig.h"
#include "graphicsEngine.h"
#include "graphicsOutput.h"
#include "keyboardButton.h"
#include "linmath_events.h"
#include "luiAtlas.h"
#include "luiAtlasDescriptor.h"
#include "luiAtlasPacker.h"
#include "luiAtlasPool.h"
#include "luiBaseElement.h"
#include "luiBaseLayout.h"
#include "luiBounds.h"
#include "luiChunkDescriptor.h"
#include "luiColorable.h"
#include "luiEventData.h"
#include "luiExpression.h"
#include "luiFontPool.h"
#include "luiHorizontalLayout.h"
#include "luiInputHandler.h"
#include "luiObject.h"
#include "luiRect.h"
#include "luiRegion.h"
#include "luiRoot.h"
#include "luiSprite.h"
#include "luiText.h"
#include "luiVertexChunk.h"
#include "luiVertexPool.h"
#include "luiVerticalLayout.h"
#include "mouseButton.h"
#include "pandaSystem.h"
#include "pandaVersion.h"
#include "pstrtod.h"
#include "py_panda.h"
#include "pythonCallbackObject.h"
#include "samplerState.h"
#include "shader.h"
#include <sstream>
#include "virtualFileSystem.h"

#undef _POSIX_C_SOURCE
#undef _XOPEN_SOURCE
#define PY_SSIZE_T_CLEAN 1

#if PYTHON_FRAMEWORK
  #include <Python/Python.h>
#else
  #include "Python.h"
#endif

/**
 * Forward declarations for top-level class LUIColorable
 */
typedef LUIColorable LUIColorable_localtype;
Define_Module_Class_Private(lui, LUIColorable, LUIColorable_localtype, LUIColorable);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LUIColorable = &Dtool_LUIColorable;
static void Dtool_PyModuleClassInit_LUIColorable(PyObject *module);

/**
 * Forward declarations for top-level class LUIBounds
 */
typedef LUIBounds LUIBounds_localtype;
Define_Module_Class(lui, LUIBounds, LUIBounds_localtype, LUIBounds);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LUIBounds = &Dtool_LUIBounds;
static void Dtool_PyModuleClassInit_LUIBounds(PyObject *module);
LUIBounds *Dtool_Coerce_LUIBounds(PyObject *args, LUIBounds &coerced);

/**
 * Forward declarations for top-level class LUIRect
 */
typedef LUIRect LUIRect_localtype;
Define_Module_Class(lui, LUIRect, LUIRect_localtype, LUIRect);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LUIRect = &Dtool_LUIRect;
static void Dtool_PyModuleClassInit_LUIRect(PyObject *module);
LUIRect *Dtool_Coerce_LUIRect(PyObject *args, LUIRect &coerced);

/**
 * Forward declarations for top-level class LUIBaseElement
 */
typedef LUIBaseElement LUIBaseElement_localtype;
Define_Module_ClassRef(lui, LUIBaseElement, LUIBaseElement_localtype, LUIBaseElement);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LUIBaseElement = &Dtool_LUIBaseElement;
static void Dtool_PyModuleClassInit_LUIBaseElement(PyObject *module);
bool Dtool_ConstCoerce_LUIBaseElement(PyObject *args, CPT(LUIBaseElement) &coerced);
bool Dtool_Coerce_LUIBaseElement(PyObject *args, PT(LUIBaseElement) &coerced);

/**
 * Forward declarations for top-level class LUIObject
 */
typedef LUIObject LUIObject_localtype;
Define_Module_ClassRef(lui, LUIObject, LUIObject_localtype, LUIObject);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LUIObject = &Dtool_LUIObject;
static void Dtool_PyModuleClassInit_LUIObject(PyObject *module);
bool Dtool_ConstCoerce_LUIObject(PyObject *args, CPT(LUIObject) &coerced);
bool Dtool_Coerce_LUIObject(PyObject *args, PT(LUIObject) &coerced);

/**
 * Forward declarations for top-level class LUIAtlas
 */
typedef LUIAtlas LUIAtlas_localtype;
Define_Module_ClassRef(lui, LUIAtlas, LUIAtlas_localtype, LUIAtlas);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LUIAtlas = &Dtool_LUIAtlas;
static void Dtool_PyModuleClassInit_LUIAtlas(PyObject *module);

/**
 * Forward declarations for top-level class LUIAtlasPool
 */
typedef LUIAtlasPool LUIAtlasPool_localtype;
Define_Module_Class(lui, LUIAtlasPool, LUIAtlasPool_localtype, LUIAtlasPool);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LUIAtlasPool = &Dtool_LUIAtlasPool;
static void Dtool_PyModuleClassInit_LUIAtlasPool(PyObject *module);

/**
 * Forward declarations for top-level class LUISprite
 */
typedef LUISprite LUISprite_localtype;
Define_Module_ClassRef(lui, LUISprite, LUISprite_localtype, LUISprite);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LUISprite = &Dtool_LUISprite;
static void Dtool_PyModuleClassInit_LUISprite(PyObject *module);
bool Dtool_ConstCoerce_LUISprite(PyObject *args, CPT(LUISprite) &coerced);
bool Dtool_Coerce_LUISprite(PyObject *args, PT(LUISprite) &coerced);

/**
 * Forward declarations for top-level class LUIElementIterator
 */
typedef LUIElementIterator LUIElementIterator_localtype;
Define_Module_ClassRef(lui, LUIElementIterator, LUIElementIterator_localtype, LUIElementIterator);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LUIElementIterator = &Dtool_LUIElementIterator;
static void Dtool_PyModuleClassInit_LUIElementIterator(PyObject *module);

/**
 * Forward declarations for top-level class LUIRoot
 */
typedef LUIRoot LUIRoot_localtype;
Define_Module_ClassRef(lui, LUIRoot, LUIRoot_localtype, LUIRoot);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LUIRoot = &Dtool_LUIRoot;
static void Dtool_PyModuleClassInit_LUIRoot(PyObject *module);
bool Dtool_ConstCoerce_LUIRoot(PyObject *args, CPT(LUIRoot) &coerced);
bool Dtool_Coerce_LUIRoot(PyObject *args, PT(LUIRoot) &coerced);

/**
 * Forward declarations for top-level class LUIInputHandler
 */
typedef LUIInputHandler LUIInputHandler_localtype;
Define_Module_ClassRef(lui, LUIInputHandler, LUIInputHandler_localtype, LUIInputHandler);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LUIInputHandler = &Dtool_LUIInputHandler;
static void Dtool_PyModuleClassInit_LUIInputHandler(PyObject *module);
bool Dtool_ConstCoerce_LUIInputHandler(PyObject *args, CPT(LUIInputHandler) &coerced);
bool Dtool_Coerce_LUIInputHandler(PyObject *args, PT(LUIInputHandler) &coerced);

/**
 * Forward declarations for top-level class LUIRegion
 */
typedef LUIRegion LUIRegion_localtype;
Define_Module_ClassRef(lui, LUIRegion, LUIRegion_localtype, LUIRegion);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LUIRegion = &Dtool_LUIRegion;
static void Dtool_PyModuleClassInit_LUIRegion(PyObject *module);
bool Dtool_ConstCoerce_LUIRegion(PyObject *args, CPT(LUIRegion) &coerced);
bool Dtool_Coerce_LUIRegion(PyObject *args, PT(LUIRegion) &coerced);

/**
 * Forward declarations for top-level class LUIFontPool
 */
typedef LUIFontPool LUIFontPool_localtype;
Define_Module_Class_Private(lui, LUIFontPool, LUIFontPool_localtype, LUIFontPool);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LUIFontPool = &Dtool_LUIFontPool;
static void Dtool_PyModuleClassInit_LUIFontPool(PyObject *module);

/**
 * Forward declarations for top-level class LUIText
 */
typedef LUIText LUIText_localtype;
Define_Module_ClassRef(lui, LUIText, LUIText_localtype, LUIText);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LUIText = &Dtool_LUIText;
static void Dtool_PyModuleClassInit_LUIText(PyObject *module);
bool Dtool_ConstCoerce_LUIText(PyObject *args, CPT(LUIText) &coerced);
bool Dtool_Coerce_LUIText(PyObject *args, PT(LUIText) &coerced);

/**
 * Forward declarations for top-level class LUIEventData
 */
typedef LUIEventData LUIEventData_localtype;
Define_Module_ClassRef(lui, LUIEventData, LUIEventData_localtype, LUIEventData);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LUIEventData = &Dtool_LUIEventData;
static void Dtool_PyModuleClassInit_LUIEventData(PyObject *module);

/**
 * Forward declarations for top-level class LUIBaseLayout
 */
typedef LUIBaseLayout LUIBaseLayout_localtype;
Define_Module_ClassRef(lui, LUIBaseLayout, LUIBaseLayout_localtype, LUIBaseLayout);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LUIBaseLayout = &Dtool_LUIBaseLayout;
static void Dtool_PyModuleClassInit_LUIBaseLayout(PyObject *module);

/**
 * Forward declarations for top-level class LUIVerticalLayout
 */
typedef LUIVerticalLayout LUIVerticalLayout_localtype;
Define_Module_ClassRef(lui, LUIVerticalLayout, LUIVerticalLayout_localtype, LUIVerticalLayout);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LUIVerticalLayout = &Dtool_LUIVerticalLayout;
static void Dtool_PyModuleClassInit_LUIVerticalLayout(PyObject *module);
bool Dtool_ConstCoerce_LUIVerticalLayout(PyObject *args, CPT(LUIVerticalLayout) &coerced);
bool Dtool_Coerce_LUIVerticalLayout(PyObject *args, PT(LUIVerticalLayout) &coerced);

/**
 * Forward declarations for top-level class LUIHorizontalLayout
 */
typedef LUIHorizontalLayout LUIHorizontalLayout_localtype;
Define_Module_ClassRef(lui, LUIHorizontalLayout, LUIHorizontalLayout_localtype, LUIHorizontalLayout);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LUIHorizontalLayout = &Dtool_LUIHorizontalLayout;
static void Dtool_PyModuleClassInit_LUIHorizontalLayout(PyObject *module);
bool Dtool_ConstCoerce_LUIHorizontalLayout(PyObject *args, CPT(LUIHorizontalLayout) &coerced);
bool Dtool_Coerce_LUIHorizontalLayout(PyObject *args, PT(LUIHorizontalLayout) &coerced);

/**
 * Forward declarations for top-level class LUIAtlasPacker
 */
typedef LUIAtlasPacker LUIAtlasPacker_localtype;
Define_Module_ClassRef(lui, LUIAtlasPacker, LUIAtlasPacker_localtype, LUIAtlasPacker);
static struct Dtool_PyTypedObject *const Dtool_Ptr_LUIAtlasPacker = &Dtool_LUIAtlasPacker;
static void Dtool_PyModuleClassInit_LUIAtlasPacker(PyObject *module);
bool Dtool_ConstCoerce_LUIAtlasPacker(PyObject *args, CPT(LUIAtlasPacker) &coerced);
bool Dtool_Coerce_LUIAtlasPacker(PyObject *args, PT(LUIAtlasPacker) &coerced);

/**
 * Declarations for exported classes
 */
static const Dtool_TypeDef exports[] = {
  {"LUIColorable", &Dtool_LUIColorable},
  {"LUIBounds", &Dtool_LUIBounds},
  {"LUIRect", &Dtool_LUIRect},
  {"LUIBaseElement", &Dtool_LUIBaseElement},
  {"LUIObject", &Dtool_LUIObject},
  {"LUIAtlas", &Dtool_LUIAtlas},
  {"LUIAtlasPool", &Dtool_LUIAtlasPool},
  {"LUISprite", &Dtool_LUISprite},
  {"LUIElementIterator", &Dtool_LUIElementIterator},
  {"LUIRoot", &Dtool_LUIRoot},
  {"LUIInputHandler", &Dtool_LUIInputHandler},
  {"LUIRegion", &Dtool_LUIRegion},
  {"LUIFontPool", &Dtool_LUIFontPool},
  {"LUIText", &Dtool_LUIText},
  {"LUIEventData", &Dtool_LUIEventData},
  {"LUIBaseLayout", &Dtool_LUIBaseLayout},
  {"LUIVerticalLayout", &Dtool_LUIVerticalLayout},
  {"LUIHorizontalLayout", &Dtool_LUIHorizontalLayout},
  {"LUIAtlasPacker", &Dtool_LUIAtlasPacker},
  {nullptr, nullptr},
};

/**
 * Extern declarations for imported classes
 */
#ifndef LINK_ALL_STATIC
static Dtool_TypeDef imports[] = {
  {"TypeHandle", nullptr},
#define Dtool_Ptr_TypeHandle (imports[0].type)
  {"ReferenceCount", nullptr},
#define Dtool_Ptr_ReferenceCount (imports[1].type)
  {"TypedObject", nullptr},
#define Dtool_Ptr_TypedObject (imports[2].type)
  {"Namable", nullptr},
#define Dtool_Ptr_Namable (imports[3].type)
  {"TypedReferenceCount", nullptr},
#define Dtool_Ptr_TypedReferenceCount (imports[4].type)
  {"TypedWritable", nullptr},
#define Dtool_Ptr_TypedWritable (imports[5].type)
  {"TypedWritableReferenceCount", nullptr},
#define Dtool_Ptr_TypedWritableReferenceCount (imports[6].type)
  {"LVecBase4f", nullptr},
#define Dtool_Ptr_LVecBase4f (imports[7].type)
  {"LVector4f", nullptr},
#define Dtool_Ptr_LVector4f (imports[8].type)
  {"LVecBase3f", nullptr},
#define Dtool_Ptr_LVecBase3f (imports[9].type)
  {"LPoint2f", nullptr},
#define Dtool_Ptr_LPoint2f (imports[10].type)
  {"LVector2f", nullptr},
#define Dtool_Ptr_LVector2f (imports[11].type)
  {"PandaNode", nullptr},
#define Dtool_Ptr_PandaNode (imports[12].type)
  {"Texture", nullptr},
#define Dtool_Ptr_Texture (imports[13].type)
  {"DrawableRegion", nullptr},
#define Dtool_Ptr_DrawableRegion (imports[14].type)
  {"CallbackData", nullptr},
#define Dtool_Ptr_CallbackData (imports[15].type)
  {"CallbackObject", nullptr},
#define Dtool_Ptr_CallbackObject (imports[16].type)
  {"DisplayRegion", nullptr},
#define Dtool_Ptr_DisplayRegion (imports[17].type)
  {"GraphicsOutput", nullptr},
#define Dtool_Ptr_GraphicsOutput (imports[18].type)
  {"DataNode", nullptr},
#define Dtool_Ptr_DataNode (imports[19].type)
  {"DynamicTextFont", nullptr},
#define Dtool_Ptr_DynamicTextFont (imports[20].type)
  {nullptr, nullptr},
};
#endif

// TypeHandle
#ifndef LINK_ALL_STATIC
inline static TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced) {
  nassertr(Dtool_Ptr_TypeHandle != nullptr, nullptr);
  nassertr(Dtool_Ptr_TypeHandle->_Dtool_Coerce != nullptr, nullptr);
  return ((TypeHandle *(*)(PyObject *, TypeHandle &))Dtool_Ptr_TypeHandle->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_TypeHandle;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypeHandle = &Dtool_TypeHandle;
extern TypeHandle *Dtool_Coerce_TypeHandle(PyObject *args, TypeHandle &coerced);
#endif
// ReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_ReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_ReferenceCount = &Dtool_ReferenceCount;
#endif
// TypedObject
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedObject = &Dtool_TypedObject;
#endif
// Namable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Namable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Namable = &Dtool_Namable;
#endif
// TypedReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedReferenceCount = &Dtool_TypedReferenceCount;
#endif
// TypedWritable
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritable;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritable = &Dtool_TypedWritable;
#endif
// TypedWritableReferenceCount
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_TypedWritableReferenceCount;
static struct Dtool_PyTypedObject *const Dtool_Ptr_TypedWritableReferenceCount = &Dtool_TypedWritableReferenceCount;
#endif
// LVecBase4f
#ifndef LINK_ALL_STATIC
inline static LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced) {
  nassertr(Dtool_Ptr_LVecBase4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase4f *(*)(PyObject *, LVecBase4f &))Dtool_Ptr_LVecBase4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase4f = &Dtool_LVecBase4f;
extern LVecBase4f *Dtool_Coerce_LVecBase4f(PyObject *args, LVecBase4f &coerced);
#endif
// LVector4f
#ifndef LINK_ALL_STATIC
inline static LVector4f *Dtool_Coerce_LVector4f(PyObject *args, LVector4f &coerced) {
  nassertr(Dtool_Ptr_LVector4f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVector4f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVector4f *(*)(PyObject *, LVector4f &))Dtool_Ptr_LVector4f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector4f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector4f = &Dtool_LVector4f;
extern LVector4f *Dtool_Coerce_LVector4f(PyObject *args, LVector4f &coerced);
#endif
// LVecBase3f
#ifndef LINK_ALL_STATIC
inline static LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced) {
  nassertr(Dtool_Ptr_LVecBase3f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVecBase3f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVecBase3f *(*)(PyObject *, LVecBase3f &))Dtool_Ptr_LVecBase3f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVecBase3f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVecBase3f = &Dtool_LVecBase3f;
extern LVecBase3f *Dtool_Coerce_LVecBase3f(PyObject *args, LVecBase3f &coerced);
#endif
// LPoint2f
#ifndef LINK_ALL_STATIC
inline static LPoint2f *Dtool_Coerce_LPoint2f(PyObject *args, LPoint2f &coerced) {
  nassertr(Dtool_Ptr_LPoint2f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LPoint2f->_Dtool_Coerce != nullptr, nullptr);
  return ((LPoint2f *(*)(PyObject *, LPoint2f &))Dtool_Ptr_LPoint2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LPoint2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LPoint2f = &Dtool_LPoint2f;
extern LPoint2f *Dtool_Coerce_LPoint2f(PyObject *args, LPoint2f &coerced);
#endif
// LVector2f
#ifndef LINK_ALL_STATIC
inline static LVector2f *Dtool_Coerce_LVector2f(PyObject *args, LVector2f &coerced) {
  nassertr(Dtool_Ptr_LVector2f != nullptr, nullptr);
  nassertr(Dtool_Ptr_LVector2f->_Dtool_Coerce != nullptr, nullptr);
  return ((LVector2f *(*)(PyObject *, LVector2f &))Dtool_Ptr_LVector2f->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_LVector2f;
static struct Dtool_PyTypedObject *const Dtool_Ptr_LVector2f = &Dtool_LVector2f;
extern LVector2f *Dtool_Coerce_LVector2f(PyObject *args, LVector2f &coerced);
#endif
// PandaNode
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_PandaNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_PandaNode = &Dtool_PandaNode;
#endif
// Texture
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_Texture;
static struct Dtool_PyTypedObject *const Dtool_Ptr_Texture = &Dtool_Texture;
#endif
// DrawableRegion
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_DrawableRegion;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DrawableRegion = &Dtool_DrawableRegion;
#endif
// CallbackData
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_CallbackData;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CallbackData = &Dtool_CallbackData;
#endif
// CallbackObject
#ifndef LINK_ALL_STATIC
inline static bool Dtool_ConstCoerce_CallbackObject(PyObject *args, CPT(CallbackObject) &coerced) {
  nassertr(Dtool_Ptr_CallbackObject != nullptr, false);
  nassertr(Dtool_Ptr_CallbackObject->_Dtool_ConstCoerce != nullptr, false);
  return ((bool (*)(PyObject *, CPT(CallbackObject) &))Dtool_Ptr_CallbackObject->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_CallbackObject(PyObject *args, PT(CallbackObject) &coerced) {
  nassertr(Dtool_Ptr_CallbackObject != nullptr, false);
  nassertr(Dtool_Ptr_CallbackObject->_Dtool_Coerce != nullptr, false);
  return ((bool (*)(PyObject *, PT(CallbackObject) &))Dtool_Ptr_CallbackObject->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_CallbackObject;
static struct Dtool_PyTypedObject *const Dtool_Ptr_CallbackObject = &Dtool_CallbackObject;
extern bool Dtool_ConstCoerce_CallbackObject(PyObject *args, CPT(CallbackObject) &coerced);
extern bool Dtool_Coerce_CallbackObject(PyObject *args, PT(CallbackObject) &coerced);
#endif
// DisplayRegion
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_DisplayRegion;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DisplayRegion = &Dtool_DisplayRegion;
#endif
// GraphicsOutput
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_GraphicsOutput;
static struct Dtool_PyTypedObject *const Dtool_Ptr_GraphicsOutput = &Dtool_GraphicsOutput;
#endif
// DataNode
#ifndef LINK_ALL_STATIC
#else
extern struct Dtool_PyTypedObject Dtool_DataNode;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DataNode = &Dtool_DataNode;
#endif
// DynamicTextFont
#ifndef LINK_ALL_STATIC
inline static bool Dtool_ConstCoerce_DynamicTextFont(PyObject *args, CPT(DynamicTextFont) &coerced) {
  nassertr(Dtool_Ptr_DynamicTextFont != nullptr, false);
  nassertr(Dtool_Ptr_DynamicTextFont->_Dtool_ConstCoerce != nullptr, false);
  return ((bool (*)(PyObject *, CPT(DynamicTextFont) &))Dtool_Ptr_DynamicTextFont->_Dtool_ConstCoerce)(args, coerced);
}
inline static bool Dtool_Coerce_DynamicTextFont(PyObject *args, PT(DynamicTextFont) &coerced) {
  nassertr(Dtool_Ptr_DynamicTextFont != nullptr, false);
  nassertr(Dtool_Ptr_DynamicTextFont->_Dtool_Coerce != nullptr, false);
  return ((bool (*)(PyObject *, PT(DynamicTextFont) &))Dtool_Ptr_DynamicTextFont->_Dtool_Coerce)(args, coerced);
}
#else
extern struct Dtool_PyTypedObject Dtool_DynamicTextFont;
static struct Dtool_PyTypedObject *const Dtool_Ptr_DynamicTextFont = &Dtool_DynamicTextFont;
extern bool Dtool_ConstCoerce_DynamicTextFont(PyObject *args, CPT(DynamicTextFont) &coerced);
extern bool Dtool_Coerce_DynamicTextFont(PyObject *args, PT(DynamicTextFont) &coerced);
#endif

/**
 * Python wrappers for global functions
 */
/**
 * Python wrappers for functions of class LUIColorable
 */
/**
 * Python function wrapper for:
 * inline void LUIColorable::set_color(LColor const &color)
 * inline void LUIColorable::set_color(LVecBase3 const &rgb)
 * inline void LUIColorable::set_color(float r, float g, float b, float a = 1.0)
 */
static PyObject *Dtool_LUIColorable_set_color_2(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIColorable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIColorable, (void **)&local_this, "LUIColorable.set_color")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline void LUIColorable::set_color(LColor const &color)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "color")) {
          LColor const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVecBase4f);
          if (param1_this != nullptr) {
            ((*local_this).set_color)(*param1_this);
            return Dtool_Return_None();
          }
        }
      }

      {
        // -2 inline void LUIColorable::set_color(LVecBase3 const &rgb)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "rgb")) {
          LVecBase3 const *param1_this = nullptr;
          DtoolInstance_GetPointer(param1, param1_this, *Dtool_Ptr_LVecBase3f);
          if (param1_this != nullptr) {
            ((*local_this).set_color)(*param1_this);
            return Dtool_Return_None();
          }
        }
      }

      {
        // -2 inline void LUIColorable::set_color(LColor const &color)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "color")) {
          LVecBase4f param1_local;
          LColor const *param1_this = Dtool_Coerce_LVecBase4f(param1, param1_local);
          if ((param1_this != nullptr)) {
            ((*local_this).set_color)(*param1_this);
            return Dtool_Return_None();
          }
        }
      }

      {
        // -2 inline void LUIColorable::set_color(LVecBase3 const &rgb)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "rgb")) {
          LVecBase3f param1_local;
          LVecBase3 const *param1_this = Dtool_Coerce_LVecBase3f(param1, param1_local);
          if ((param1_this != nullptr)) {
            ((*local_this).set_color)(*param1_this);
            return Dtool_Return_None();
          }
        }
      }

    }
    break;
  case 3:
  case 4:
    {
      // 1-inline void LUIColorable::set_color(float r, float g, float b, float a = 1.0)
      float param1;
      float param2;
      float param3;
      float param4 = 1.0;
      static const char *keyword_list[] = {"r", "g", "b", "a", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "fff|f:set_color", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).set_color)((float)param1, (float)param2, (float)param3, (float)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_color() takes 2, 4 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_color(const LUIColorable self, const LVecBase4f color)\n"
      "set_color(const LUIColorable self, const LVecBase3f rgb)\n"
      "set_color(const LUIColorable self, float r, float g, float b, float a)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIColorable_set_color_2_comment =
  "C++ Interface:\n"
  "set_color(const LUIColorable self, const LVecBase4f color)\n"
  "set_color(const LUIColorable self, const LVecBase3f rgb)\n"
  "set_color(const LUIColorable self, float r, float g, float b, float a)\n"
  "\n"
  "// Color\n"
  "\n"
  "// Color";
#else
static const char *Dtool_LUIColorable_set_color_2_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIColorable::set_red(float r)
 */
static PyObject *Dtool_LUIColorable_set_red_3(PyObject *self, PyObject *arg) {
  LUIColorable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIColorable, (void **)&local_this, "LUIColorable.set_red")) {
    return nullptr;
  }
  // 1-inline void LUIColorable::set_red(float r)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_red)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_red(const LUIColorable self, float r)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIColorable_set_red_3_comment =
  "C++ Interface:\n"
  "set_red(const LUIColorable self, float r)\n";
#else
static const char *Dtool_LUIColorable_set_red_3_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIColorable::set_green(float g)
 */
static PyObject *Dtool_LUIColorable_set_green_4(PyObject *self, PyObject *arg) {
  LUIColorable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIColorable, (void **)&local_this, "LUIColorable.set_green")) {
    return nullptr;
  }
  // 1-inline void LUIColorable::set_green(float g)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_green)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_green(const LUIColorable self, float g)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIColorable_set_green_4_comment =
  "C++ Interface:\n"
  "set_green(const LUIColorable self, float g)\n";
#else
static const char *Dtool_LUIColorable_set_green_4_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIColorable::set_blue(float b)
 */
static PyObject *Dtool_LUIColorable_set_blue_5(PyObject *self, PyObject *arg) {
  LUIColorable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIColorable, (void **)&local_this, "LUIColorable.set_blue")) {
    return nullptr;
  }
  // 1-inline void LUIColorable::set_blue(float b)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_blue)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_blue(const LUIColorable self, float b)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIColorable_set_blue_5_comment =
  "C++ Interface:\n"
  "set_blue(const LUIColorable self, float b)\n";
#else
static const char *Dtool_LUIColorable_set_blue_5_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIColorable::set_alpha(float a)
 */
static PyObject *Dtool_LUIColorable_set_alpha_6(PyObject *self, PyObject *arg) {
  LUIColorable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIColorable, (void **)&local_this, "LUIColorable.set_alpha")) {
    return nullptr;
  }
  // 1-inline void LUIColorable::set_alpha(float a)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_alpha)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_alpha(const LUIColorable self, float a)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIColorable_set_alpha_6_comment =
  "C++ Interface:\n"
  "set_alpha(const LUIColorable self, float a)\n";
#else
static const char *Dtool_LUIColorable_set_alpha_6_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float LUIColorable::get_red(void) const
 */
static PyObject *Dtool_LUIColorable_get_red_7(PyObject *self, PyObject *) {
  LUIColorable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIColorable)) {
    return nullptr;
  }
  // 1-inline float LUIColorable::get_red(void) const
  float return_value = ((*(const LUIColorable*)local_this).get_red)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIColorable_get_red_7_comment =
  "C++ Interface:\n"
  "get_red(LUIColorable self)\n";
#else
static const char *Dtool_LUIColorable_get_red_7_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float LUIColorable::get_green(void) const
 */
static PyObject *Dtool_LUIColorable_get_green_8(PyObject *self, PyObject *) {
  LUIColorable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIColorable)) {
    return nullptr;
  }
  // 1-inline float LUIColorable::get_green(void) const
  float return_value = ((*(const LUIColorable*)local_this).get_green)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIColorable_get_green_8_comment =
  "C++ Interface:\n"
  "get_green(LUIColorable self)\n";
#else
static const char *Dtool_LUIColorable_get_green_8_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float LUIColorable::get_blue(void) const
 */
static PyObject *Dtool_LUIColorable_get_blue_9(PyObject *self, PyObject *) {
  LUIColorable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIColorable)) {
    return nullptr;
  }
  // 1-inline float LUIColorable::get_blue(void) const
  float return_value = ((*(const LUIColorable*)local_this).get_blue)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIColorable_get_blue_9_comment =
  "C++ Interface:\n"
  "get_blue(LUIColorable self)\n";
#else
static const char *Dtool_LUIColorable_get_blue_9_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float LUIColorable::get_alpha(void) const
 */
static PyObject *Dtool_LUIColorable_get_alpha_10(PyObject *self, PyObject *) {
  LUIColorable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIColorable)) {
    return nullptr;
  }
  // 1-inline float LUIColorable::get_alpha(void) const
  float return_value = ((*(const LUIColorable*)local_this).get_alpha)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIColorable_get_alpha_10_comment =
  "C++ Interface:\n"
  "get_alpha(LUIColorable self)\n";
#else
static const char *Dtool_LUIColorable_get_alpha_10_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &LUIColorable::get_color(void) const
 */
static PyObject *Dtool_LUIColorable_get_color_11(PyObject *self, PyObject *) {
  LUIColorable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIColorable)) {
    return nullptr;
  }
  // 1-inline LColor const &LUIColorable::get_color(void) const
  LColor const *return_value = &(((*(const LUIColorable*)local_this).get_color)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LUIColorable_get_color_11_comment =
  "C++ Interface:\n"
  "get_color(LUIColorable self)\n";
#else
static const char *Dtool_LUIColorable_get_color_11_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LColor const &LUIColorable::get_composed_color(void) const
 */
static PyObject *Dtool_LUIColorable_get_composed_color_12(PyObject *self, PyObject *) {
  LUIColorable *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIColorable)) {
    return nullptr;
  }
  // 1-inline LColor const &LUIColorable::get_composed_color(void) const
  LColor const *return_value = &(((*(const LUIColorable*)local_this).get_composed_color)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LUIColorable_get_composed_color_12_comment =
  "C++ Interface:\n"
  "get_composed_color(LUIColorable self)\n";
#else
static const char *Dtool_LUIColorable_get_composed_color_12_comment = nullptr;
#endif

static PyObject *Dtool_LUIColorable_color_Getter(PyObject *self, void *) {
  const LUIColorable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIColorable, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LColor const &LUIColorable::get_color(void) const
  LColor const *return_value = &(((*(const LUIColorable*)local_this).get_color)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static int Dtool_LUIColorable_color_Setter(PyObject *self, PyObject *arg, void *) {
  LUIColorable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIColorable, (void **)&local_this, "LUIColorable.color")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete color attribute");
    return -1;
  }
  {
    // -2 inline void LUIColorable::set_color(LColor const &color)
    LColor const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase4f);
    if (arg_this != nullptr) {
      ((*local_this).set_color)(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }

  {
    // -2 inline void LUIColorable::set_color(LVecBase3 const &rgb)
    LVecBase3 const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVecBase3f);
    if (arg_this != nullptr) {
      ((*local_this).set_color)(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }

  {
    // -2 inline void LUIColorable::set_color(LColor const &color)
    LVecBase4f arg_local;
    LColor const *arg_this = Dtool_Coerce_LVecBase4f(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).set_color)(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }

  {
    // -2 inline void LUIColorable::set_color(LVecBase3 const &rgb)
    LVecBase3f arg_local;
    LVecBase3 const *arg_this = Dtool_Coerce_LVecBase3f(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).set_color)(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }

  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_color(const LUIColorable self, const LVecBase4f color)\n"
      "set_color(const LUIColorable self, const LVecBase3f rgb)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIColorable_composed_color_Getter(PyObject *self, void *) {
  const LUIColorable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIColorable, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LColor const &LUIColorable::get_composed_color(void) const
  LColor const *return_value = &(((*(const LUIColorable*)local_this).get_composed_color)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVecBase4f, false, true);
}

static PyObject *Dtool_LUIColorable_red_Getter(PyObject *self, void *) {
  const LUIColorable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIColorable, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline float LUIColorable::get_red(void) const
  float return_value = ((*(const LUIColorable*)local_this).get_red)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIColorable_red_Setter(PyObject *self, PyObject *arg, void *) {
  LUIColorable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIColorable, (void **)&local_this, "LUIColorable.red")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete red attribute");
    return -1;
  }
  // 1-inline void LUIColorable::set_red(float r)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_red)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_red(const LUIColorable self, float r)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIColorable_green_Getter(PyObject *self, void *) {
  const LUIColorable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIColorable, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline float LUIColorable::get_green(void) const
  float return_value = ((*(const LUIColorable*)local_this).get_green)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIColorable_green_Setter(PyObject *self, PyObject *arg, void *) {
  LUIColorable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIColorable, (void **)&local_this, "LUIColorable.green")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete green attribute");
    return -1;
  }
  // 1-inline void LUIColorable::set_green(float g)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_green)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_green(const LUIColorable self, float g)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIColorable_blue_Getter(PyObject *self, void *) {
  const LUIColorable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIColorable, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline float LUIColorable::get_blue(void) const
  float return_value = ((*(const LUIColorable*)local_this).get_blue)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIColorable_blue_Setter(PyObject *self, PyObject *arg, void *) {
  LUIColorable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIColorable, (void **)&local_this, "LUIColorable.blue")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete blue attribute");
    return -1;
  }
  // 1-inline void LUIColorable::set_blue(float b)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_blue)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_blue(const LUIColorable self, float b)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIColorable_alpha_Getter(PyObject *self, void *) {
  const LUIColorable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIColorable, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline float LUIColorable::get_alpha(void) const
  float return_value = ((*(const LUIColorable*)local_this).get_alpha)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIColorable_alpha_Setter(PyObject *self, PyObject *arg, void *) {
  LUIColorable *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIColorable, (void **)&local_this, "LUIColorable.alpha")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete alpha attribute");
    return -1;
  }
  // 1-inline void LUIColorable::set_alpha(float a)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_alpha)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_alpha(const LUIColorable self, float a)\n");
  }
  return -1;
}

static int Dtool_Init_LUIColorable(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_LUIColorable(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LUIColorable) {
    printf("LUIColorable ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LUIColorable *local_this = (LUIColorable *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LUIColorable) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LUIColorable(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LUIColorable) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LUIBounds
 */
/**
 * Python function wrapper for:
 * inline float LUIBounds::get_top(void) const
 */
static PyObject *Dtool_LUIBounds_get_top_26(PyObject *self, PyObject *) {
  LUIBounds *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBounds)) {
    return nullptr;
  }
  // 1-inline float LUIBounds::get_top(void) const
  float return_value = ((*(const LUIBounds*)local_this).get_top)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBounds_get_top_26_comment =
  "C++ Interface:\n"
  "get_top(LUIBounds self)\n";
#else
static const char *Dtool_LUIBounds_get_top_26_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float LUIBounds::get_right(void) const
 */
static PyObject *Dtool_LUIBounds_get_right_27(PyObject *self, PyObject *) {
  LUIBounds *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBounds)) {
    return nullptr;
  }
  // 1-inline float LUIBounds::get_right(void) const
  float return_value = ((*(const LUIBounds*)local_this).get_right)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBounds_get_right_27_comment =
  "C++ Interface:\n"
  "get_right(LUIBounds self)\n";
#else
static const char *Dtool_LUIBounds_get_right_27_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float LUIBounds::get_bottom(void) const
 */
static PyObject *Dtool_LUIBounds_get_bottom_28(PyObject *self, PyObject *) {
  LUIBounds *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBounds)) {
    return nullptr;
  }
  // 1-inline float LUIBounds::get_bottom(void) const
  float return_value = ((*(const LUIBounds*)local_this).get_bottom)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBounds_get_bottom_28_comment =
  "C++ Interface:\n"
  "get_bottom(LUIBounds self)\n";
#else
static const char *Dtool_LUIBounds_get_bottom_28_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float LUIBounds::get_left(void) const
 */
static PyObject *Dtool_LUIBounds_get_left_29(PyObject *self, PyObject *) {
  LUIBounds *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBounds)) {
    return nullptr;
  }
  // 1-inline float LUIBounds::get_left(void) const
  float return_value = ((*(const LUIBounds*)local_this).get_left)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBounds_get_left_29_comment =
  "C++ Interface:\n"
  "get_left(LUIBounds self)\n";
#else
static const char *Dtool_LUIBounds_get_left_29_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBounds::set_top(float top)
 */
static PyObject *Dtool_LUIBounds_set_top_30(PyObject *self, PyObject *arg) {
  LUIBounds *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBounds, (void **)&local_this, "LUIBounds.set_top")) {
    return nullptr;
  }
  // 1-inline void LUIBounds::set_top(float top)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_top)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_top(const LUIBounds self, float top)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBounds_set_top_30_comment =
  "C++ Interface:\n"
  "set_top(const LUIBounds self, float top)\n";
#else
static const char *Dtool_LUIBounds_set_top_30_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBounds::set_right(float right)
 */
static PyObject *Dtool_LUIBounds_set_right_31(PyObject *self, PyObject *arg) {
  LUIBounds *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBounds, (void **)&local_this, "LUIBounds.set_right")) {
    return nullptr;
  }
  // 1-inline void LUIBounds::set_right(float right)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_right)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_right(const LUIBounds self, float right)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBounds_set_right_31_comment =
  "C++ Interface:\n"
  "set_right(const LUIBounds self, float right)\n";
#else
static const char *Dtool_LUIBounds_set_right_31_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBounds::set_bottom(float bottom)
 */
static PyObject *Dtool_LUIBounds_set_bottom_32(PyObject *self, PyObject *arg) {
  LUIBounds *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBounds, (void **)&local_this, "LUIBounds.set_bottom")) {
    return nullptr;
  }
  // 1-inline void LUIBounds::set_bottom(float bottom)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_bottom)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bottom(const LUIBounds self, float bottom)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBounds_set_bottom_32_comment =
  "C++ Interface:\n"
  "set_bottom(const LUIBounds self, float bottom)\n";
#else
static const char *Dtool_LUIBounds_set_bottom_32_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBounds::set_left(float left)
 */
static PyObject *Dtool_LUIBounds_set_left_33(PyObject *self, PyObject *arg) {
  LUIBounds *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBounds, (void **)&local_this, "LUIBounds.set_left")) {
    return nullptr;
  }
  // 1-inline void LUIBounds::set_left(float left)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_left)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_left(const LUIBounds self, float left)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBounds_set_left_33_comment =
  "C++ Interface:\n"
  "set_left(const LUIBounds self, float left)\n";
#else
static const char *Dtool_LUIBounds_set_left_33_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBounds::set_bounds(LVector4 const &bounds)
 * inline void LUIBounds::set_bounds(float top, float right, float bottom, float left)
 */
static PyObject *Dtool_LUIBounds_set_bounds_34(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIBounds *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBounds, (void **)&local_this, "LUIBounds.set_bounds")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "bounds")) {
        // 1-inline void LUIBounds::set_bounds(LVector4 const &bounds)
        LVector4f arg_local;
        LVector4 const *arg_this = Dtool_Coerce_LVector4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "LUIBounds.set_bounds", "LVector4f");
        }
        ((*local_this).set_bounds)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void LUIBounds::set_bounds(float top, float right, float bottom, float left)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"top", "right", "bottom", "left", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_bounds", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).set_bounds)((float)param1, (float)param2, (float)param3, (float)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_bounds() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bounds(const LUIBounds self, const LVector4f bounds)\n"
      "set_bounds(const LUIBounds self, float top, float right, float bottom, float left)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBounds_set_bounds_34_comment =
  "C++ Interface:\n"
  "set_bounds(const LUIBounds self, const LVector4f bounds)\n"
  "set_bounds(const LUIBounds self, float top, float right, float bottom, float left)\n";
#else
static const char *Dtool_LUIBounds_set_bounds_34_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector4 const &LUIBounds::get_bounds(void) const
 */
static PyObject *Dtool_LUIBounds_get_bounds_35(PyObject *self, PyObject *) {
  LUIBounds *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBounds)) {
    return nullptr;
  }
  // 1-inline LVector4 const &LUIBounds::get_bounds(void) const
  LVector4 const *return_value = &(((*(const LUIBounds*)local_this).get_bounds)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LUIBounds_get_bounds_35_comment =
  "C++ Interface:\n"
  "get_bounds(LUIBounds self)\n";
#else
static const char *Dtool_LUIBounds_get_bounds_35_comment = nullptr;
#endif

static PyObject *Dtool_LUIBounds_top_Getter(PyObject *self, void *) {
  const LUIBounds *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBounds, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline float LUIBounds::get_top(void) const
  float return_value = ((*(const LUIBounds*)local_this).get_top)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIBounds_top_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBounds *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBounds, (void **)&local_this, "LUIBounds.top")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete top attribute");
    return -1;
  }
  // 1-inline void LUIBounds::set_top(float top)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_top)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_top(const LUIBounds self, float top)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIBounds_right_Getter(PyObject *self, void *) {
  const LUIBounds *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBounds, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline float LUIBounds::get_right(void) const
  float return_value = ((*(const LUIBounds*)local_this).get_right)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIBounds_right_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBounds *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBounds, (void **)&local_this, "LUIBounds.right")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete right attribute");
    return -1;
  }
  // 1-inline void LUIBounds::set_right(float right)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_right)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_right(const LUIBounds self, float right)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIBounds_bottom_Getter(PyObject *self, void *) {
  const LUIBounds *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBounds, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline float LUIBounds::get_bottom(void) const
  float return_value = ((*(const LUIBounds*)local_this).get_bottom)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIBounds_bottom_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBounds *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBounds, (void **)&local_this, "LUIBounds.bottom")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete bottom attribute");
    return -1;
  }
  // 1-inline void LUIBounds::set_bottom(float bottom)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_bottom)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_bottom(const LUIBounds self, float bottom)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIBounds_left_Getter(PyObject *self, void *) {
  const LUIBounds *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBounds, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline float LUIBounds::get_left(void) const
  float return_value = ((*(const LUIBounds*)local_this).get_left)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIBounds_left_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBounds *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBounds, (void **)&local_this, "LUIBounds.left")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete left attribute");
    return -1;
  }
  // 1-inline void LUIBounds::set_left(float left)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_left)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_left(const LUIBounds self, float left)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * LUIBounds::LUIBounds(void)
 * inline LUIBounds::LUIBounds(LUIBounds const &) = default
 * explicit LUIBounds::LUIBounds(LVector4 const &bounds)
 * explicit LUIBounds::LUIBounds(float fill_value)
 * LUIBounds::LUIBounds(float top, float right, float bottom, float left)
 */
static int Dtool_Init_LUIBounds(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-LUIBounds::LUIBounds(void)
      LUIBounds *return_value = new LUIBounds();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIBounds, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 explicit LUIBounds::LUIBounds(LVector4 const &bounds)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "bounds")) {
          LVector4 const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LVector4f);
          if (param0_this != nullptr) {
            LUIBounds *return_value = new LUIBounds(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIBounds, true, false);
          }
        }
      }

      {
        // -2 inline LUIBounds::LUIBounds(LUIBounds const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          LUIBounds const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LUIBounds);
          if (param0_this != nullptr) {
            LUIBounds *return_value = new LUIBounds(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIBounds, true, false);
          }
        }
      }

      {
        // -2 explicit LUIBounds::LUIBounds(float fill_value)
        float param0;
        static const char *keyword_list[] = {"fill_value", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "f:LUIBounds", (char **)keyword_list, &param0)) {
          LUIBounds *return_value = new LUIBounds((float)param0);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          if (Dtool_CheckErrorOccurred()) {
            delete return_value;
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIBounds, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 explicit LUIBounds::LUIBounds(LVector4 const &bounds)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "bounds")) {
          LVector4f param0_local;
          LVector4 const *param0_this = Dtool_Coerce_LVector4f(param0, param0_local);
          if ((param0_this != nullptr)) {
            LUIBounds *return_value = new LUIBounds(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIBounds, true, false);
          }
        }
      }

      {
        // -2 inline LUIBounds::LUIBounds(LUIBounds const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          LUIBounds param0_local;
          LUIBounds const *param0_this = Dtool_Coerce_LUIBounds(param0, param0_local);
          if ((param0_this != nullptr)) {
            LUIBounds *return_value = new LUIBounds(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIBounds, true, false);
          }
        }
      }

      // No coercion possible: explicit LUIBounds::LUIBounds(float fill_value)
    }
    break;
  case 4:
    {
      // 1-LUIBounds::LUIBounds(float top, float right, float bottom, float left)
      float param0;
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"top", "right", "bottom", "left", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:LUIBounds", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LUIBounds *return_value = new LUIBounds((float)param0, (float)param1, (float)param2, (float)param3);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIBounds, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LUIBounds() takes 0, 1 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LUIBounds()\n"
      "LUIBounds(const LVector4f bounds)\n"
      "LUIBounds(const LUIBounds param0)\n"
      "LUIBounds(float fill_value)\n"
      "LUIBounds(float top, float right, float bottom, float left)\n");
  }
  return -1;
}

LUIBounds *Dtool_Coerce_LUIBounds(PyObject *args, LUIBounds &coerced) {
  LUIBounds *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_LUIBounds)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const LUIBounds *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 4) {
      // 1-LUIBounds::LUIBounds(float top, float right, float bottom, float left)
      float param0;
      float param1;
      float param2;
      float param3;
      if (PyArg_ParseTuple(args, "ffff:LUIBounds", &param0, &param1, &param2, &param3)) {
        coerced = LUIBounds((float)param0, (float)param1, (float)param2, (float)param3);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }
  }

  return nullptr;
}

static void *Dtool_UpcastInterface_LUIBounds(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LUIBounds) {
    printf("LUIBounds ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LUIBounds *local_this = (LUIBounds *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LUIBounds) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LUIBounds(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LUIBounds) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LUIRect
 */
/**
 * Python function wrapper for:
 * inline float LUIRect::get_x(void) const
 */
static PyObject *Dtool_LUIRect_get_x_43(PyObject *self, PyObject *) {
  LUIRect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIRect)) {
    return nullptr;
  }
  // 1-inline float LUIRect::get_x(void) const
  float return_value = ((*(const LUIRect*)local_this).get_x)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIRect_get_x_43_comment =
  "C++ Interface:\n"
  "get_x(LUIRect self)\n";
#else
static const char *Dtool_LUIRect_get_x_43_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float LUIRect::get_y(void) const
 */
static PyObject *Dtool_LUIRect_get_y_44(PyObject *self, PyObject *) {
  LUIRect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIRect)) {
    return nullptr;
  }
  // 1-inline float LUIRect::get_y(void) const
  float return_value = ((*(const LUIRect*)local_this).get_y)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIRect_get_y_44_comment =
  "C++ Interface:\n"
  "get_y(LUIRect self)\n";
#else
static const char *Dtool_LUIRect_get_y_44_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float LUIRect::get_w(void) const
 */
static PyObject *Dtool_LUIRect_get_w_45(PyObject *self, PyObject *) {
  LUIRect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIRect)) {
    return nullptr;
  }
  // 1-inline float LUIRect::get_w(void) const
  float return_value = ((*(const LUIRect*)local_this).get_w)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIRect_get_w_45_comment =
  "C++ Interface:\n"
  "get_w(LUIRect self)\n";
#else
static const char *Dtool_LUIRect_get_w_45_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float LUIRect::get_h(void) const
 */
static PyObject *Dtool_LUIRect_get_h_46(PyObject *self, PyObject *) {
  LUIRect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIRect)) {
    return nullptr;
  }
  // 1-inline float LUIRect::get_h(void) const
  float return_value = ((*(const LUIRect*)local_this).get_h)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIRect_get_h_46_comment =
  "C++ Interface:\n"
  "get_h(LUIRect self)\n";
#else
static const char *Dtool_LUIRect_get_h_46_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector2 LUIRect::get_xy(void) const
 */
static PyObject *Dtool_LUIRect_get_xy_47(PyObject *self, PyObject *) {
  LUIRect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIRect)) {
    return nullptr;
  }
  // 1-inline LVector2 LUIRect::get_xy(void) const
  LVector2 *return_value = new LVector2(((*(const LUIRect*)local_this).get_xy)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LUIRect_get_xy_47_comment =
  "C++ Interface:\n"
  "get_xy(LUIRect self)\n";
#else
static const char *Dtool_LUIRect_get_xy_47_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector2 LUIRect::get_wh(void) const
 */
static PyObject *Dtool_LUIRect_get_wh_48(PyObject *self, PyObject *) {
  LUIRect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIRect)) {
    return nullptr;
  }
  // 1-inline LVector2 LUIRect::get_wh(void) const
  LVector2 *return_value = new LVector2(((*(const LUIRect*)local_this).get_wh)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LUIRect_get_wh_48_comment =
  "C++ Interface:\n"
  "get_wh(LUIRect self)\n";
#else
static const char *Dtool_LUIRect_get_wh_48_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIRect::set_x(float x)
 */
static PyObject *Dtool_LUIRect_set_x_49(PyObject *self, PyObject *arg) {
  LUIRect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIRect, (void **)&local_this, "LUIRect.set_x")) {
    return nullptr;
  }
  // 1-inline void LUIRect::set_x(float x)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_x)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_x(const LUIRect self, float x)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIRect_set_x_49_comment =
  "C++ Interface:\n"
  "set_x(const LUIRect self, float x)\n";
#else
static const char *Dtool_LUIRect_set_x_49_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIRect::set_y(float y)
 */
static PyObject *Dtool_LUIRect_set_y_50(PyObject *self, PyObject *arg) {
  LUIRect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIRect, (void **)&local_this, "LUIRect.set_y")) {
    return nullptr;
  }
  // 1-inline void LUIRect::set_y(float y)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_y)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_y(const LUIRect self, float y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIRect_set_y_50_comment =
  "C++ Interface:\n"
  "set_y(const LUIRect self, float y)\n";
#else
static const char *Dtool_LUIRect_set_y_50_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIRect::set_w(float w)
 */
static PyObject *Dtool_LUIRect_set_w_51(PyObject *self, PyObject *arg) {
  LUIRect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIRect, (void **)&local_this, "LUIRect.set_w")) {
    return nullptr;
  }
  // 1-inline void LUIRect::set_w(float w)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_w)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_w(const LUIRect self, float w)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIRect_set_w_51_comment =
  "C++ Interface:\n"
  "set_w(const LUIRect self, float w)\n";
#else
static const char *Dtool_LUIRect_set_w_51_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIRect::set_h(float h)
 */
static PyObject *Dtool_LUIRect_set_h_52(PyObject *self, PyObject *arg) {
  LUIRect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIRect, (void **)&local_this, "LUIRect.set_h")) {
    return nullptr;
  }
  // 1-inline void LUIRect::set_h(float h)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_h)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_h(const LUIRect self, float h)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIRect_set_h_52_comment =
  "C++ Interface:\n"
  "set_h(const LUIRect self, float h)\n";
#else
static const char *Dtool_LUIRect_set_h_52_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIRect::set_rect(LVector2 const &xy, LVector2 const &wh)
 * inline void LUIRect::set_rect(LVector4 const &rect)
 * inline void LUIRect::set_rect(float x, float y, float w, float h)
 */
static PyObject *Dtool_LUIRect_set_rect_53(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIRect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIRect, (void **)&local_this, "LUIRect.set_rect")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "rect")) {
        // 1-inline void LUIRect::set_rect(LVector4 const &rect)
        LVector4f arg_local;
        LVector4 const *arg_this = Dtool_Coerce_LVector4f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "LUIRect.set_rect", "LVector4f");
        }
        ((*local_this).set_rect)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-inline void LUIRect::set_rect(LVector2 const &xy, LVector2 const &wh)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"xy", "wh", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_rect", (char **)keyword_list, &param1, &param2)) {
        LVector2f param1_local;
        LVector2 const *param1_this = Dtool_Coerce_LVector2f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LUIRect.set_rect", "LVector2f");
        }
        LVector2f param2_local;
        LVector2 const *param2_this = Dtool_Coerce_LVector2f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "LUIRect.set_rect", "LVector2f");
        }
        ((*local_this).set_rect)(*param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void LUIRect::set_rect(float x, float y, float w, float h)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"x", "y", "w", "h", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_rect", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).set_rect)((float)param1, (float)param2, (float)param3, (float)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_rect() takes 2, 3 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_rect(const LUIRect self, const LVector4f rect)\n"
      "set_rect(const LUIRect self, const LVector2f xy, const LVector2f wh)\n"
      "set_rect(const LUIRect self, float x, float y, float w, float h)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIRect_set_rect_53_comment =
  "C++ Interface:\n"
  "set_rect(const LUIRect self, const LVector4f rect)\n"
  "set_rect(const LUIRect self, const LVector2f xy, const LVector2f wh)\n"
  "set_rect(const LUIRect self, float x, float y, float w, float h)\n";
#else
static const char *Dtool_LUIRect_set_rect_53_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector4 const &LUIRect::get_rect(void) const
 */
static PyObject *Dtool_LUIRect_get_rect_54(PyObject *self, PyObject *) {
  LUIRect *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIRect)) {
    return nullptr;
  }
  // 1-inline LVector4 const &LUIRect::get_rect(void) const
  LVector4 const *return_value = &(((*(const LUIRect*)local_this).get_rect)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector4f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LUIRect_get_rect_54_comment =
  "C++ Interface:\n"
  "get_rect(LUIRect self)\n";
#else
static const char *Dtool_LUIRect_get_rect_54_comment = nullptr;
#endif

static PyObject *Dtool_LUIRect_x_Getter(PyObject *self, void *) {
  const LUIRect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIRect, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline float LUIRect::get_x(void) const
  float return_value = ((*(const LUIRect*)local_this).get_x)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIRect_x_Setter(PyObject *self, PyObject *arg, void *) {
  LUIRect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIRect, (void **)&local_this, "LUIRect.x")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete x attribute");
    return -1;
  }
  // 1-inline void LUIRect::set_x(float x)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_x)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_x(const LUIRect self, float x)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIRect_y_Getter(PyObject *self, void *) {
  const LUIRect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIRect, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline float LUIRect::get_y(void) const
  float return_value = ((*(const LUIRect*)local_this).get_y)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIRect_y_Setter(PyObject *self, PyObject *arg, void *) {
  LUIRect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIRect, (void **)&local_this, "LUIRect.y")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete y attribute");
    return -1;
  }
  // 1-inline void LUIRect::set_y(float y)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_y)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_y(const LUIRect self, float y)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIRect_w_Getter(PyObject *self, void *) {
  const LUIRect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIRect, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline float LUIRect::get_w(void) const
  float return_value = ((*(const LUIRect*)local_this).get_w)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIRect_w_Setter(PyObject *self, PyObject *arg, void *) {
  LUIRect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIRect, (void **)&local_this, "LUIRect.w")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete w attribute");
    return -1;
  }
  // 1-inline void LUIRect::set_w(float w)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_w)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_w(const LUIRect self, float w)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIRect_h_Getter(PyObject *self, void *) {
  const LUIRect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIRect, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline float LUIRect::get_h(void) const
  float return_value = ((*(const LUIRect*)local_this).get_h)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIRect_h_Setter(PyObject *self, PyObject *arg, void *) {
  LUIRect *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIRect, (void **)&local_this, "LUIRect.h")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete h attribute");
    return -1;
  }
  // 1-inline void LUIRect::set_h(float h)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_h)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_h(const LUIRect self, float h)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * LUIRect::LUIRect(void)
 * inline LUIRect::LUIRect(LUIRect const &) = default
 * explicit LUIRect::LUIRect(LVector4 const &rect)
 * LUIRect::LUIRect(float x, float y, float w, float h)
 */
static int Dtool_Init_LUIRect(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-LUIRect::LUIRect(void)
      LUIRect *return_value = new LUIRect();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIRect, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 explicit LUIRect::LUIRect(LVector4 const &rect)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "rect")) {
          LVector4 const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LVector4f);
          if (param0_this != nullptr) {
            LUIRect *return_value = new LUIRect(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIRect, true, false);
          }
        }
      }

      {
        // -2 inline LUIRect::LUIRect(LUIRect const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          LUIRect const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LUIRect);
          if (param0_this != nullptr) {
            LUIRect *return_value = new LUIRect(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIRect, true, false);
          }
        }
      }

      {
        // -2 explicit LUIRect::LUIRect(LVector4 const &rect)
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds, "rect")) {
          LVector4f param0_local;
          LVector4 const *param0_this = Dtool_Coerce_LVector4f(param0, param0_local);
          if ((param0_this != nullptr)) {
            LUIRect *return_value = new LUIRect(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIRect, true, false);
          }
        }
      }

      {
        // -2 inline LUIRect::LUIRect(LUIRect const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          LUIRect param0_local;
          LUIRect const *param0_this = Dtool_Coerce_LUIRect(param0, param0_local);
          if ((param0_this != nullptr)) {
            LUIRect *return_value = new LUIRect(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            if (Dtool_CheckErrorOccurred()) {
              delete return_value;
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIRect, true, false);
          }
        }
      }

    }
    break;
  case 4:
    {
      // 1-LUIRect::LUIRect(float x, float y, float w, float h)
      float param0;
      float param1;
      float param2;
      float param3;
      static const char *keyword_list[] = {"x", "y", "w", "h", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:LUIRect", (char **)keyword_list, &param0, &param1, &param2, &param3)) {
        LUIRect *return_value = new LUIRect((float)param0, (float)param1, (float)param2, (float)param3);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        if (Dtool_CheckErrorOccurred()) {
          delete return_value;
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIRect, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LUIRect() takes 0, 1 or 4 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LUIRect()\n"
      "LUIRect(const LVector4f rect)\n"
      "LUIRect(const LUIRect param0)\n"
      "LUIRect(float x, float y, float w, float h)\n");
  }
  return -1;
}

LUIRect *Dtool_Coerce_LUIRect(PyObject *args, LUIRect &coerced) {
  LUIRect *local_this;
  if (DtoolInstance_GetPointer(args, local_this, Dtool_LUIRect)) {
    if (DtoolInstance_IS_CONST(args)) {
      // This is a const object.  Make a copy.
      coerced = *(const LUIRect *)local_this;
      return &coerced;
    }
    return local_this;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 4) {
      // 1-LUIRect::LUIRect(float x, float y, float w, float h)
      float param0;
      float param1;
      float param2;
      float param3;
      if (PyArg_ParseTuple(args, "ffff:LUIRect", &param0, &param1, &param2, &param3)) {
        coerced = LUIRect((float)param0, (float)param1, (float)param2, (float)param3);
        if (_PyErr_OCCURRED()) {
          return nullptr;
        } else {
          return &coerced;
        }
      }
      PyErr_Clear();
    }
  }

  return nullptr;
}

static void *Dtool_UpcastInterface_LUIRect(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LUIRect) {
    printf("LUIRect ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LUIRect *local_this = (LUIRect *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LUIRect) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LUIRect(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LUIRect) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LUIBaseElement
 */
/**
 * Python function wrapper for:
 * inline void LUIBaseElement::bind(std::string const &event_name, CallbackObject *callback)
 */
static PyObject *Dtool_LUIBaseElement_bind_67(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.bind")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::bind(std::string const &event_name, CallbackObject *callback)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"event_name", "callback", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:bind", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    PT(CallbackObject) param2_this;
    if (!Dtool_Coerce_CallbackObject(param2, param2_this)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LUIBaseElement.bind", "CallbackObject");
    }
    ((*local_this).bind)(std::string(param1_str, param1_len), std::move(param2_this));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "bind(const LUIBaseElement self, str event_name, CallbackObject callback)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_bind_67_comment =
  "C++ Interface:\n"
  "bind(const LUIBaseElement self, str event_name, CallbackObject callback)\n"
  "\n"
  "// Events\n"
  "\n"
  "/**\n"
  " * @brief Binds a new event handler for a given event\n"
  " * @details This binds a given event handler (a function taking the event as the\n"
  " *   first argument) to an event name. Whenever the event gets triggered, the\n"
  " *   event handler will get invoked.\n"
  " *\n"
  " *   In case the event is already bound, a warning is printed.\n"
  " *\n"
  " * @param event_name Name of the event to bind to\n"
  " * @param callback Event handler, a method taking only one argument (the event)\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_bind_67_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::unbind(std::string const &event_name)
 */
static PyObject *Dtool_LUIBaseElement_unbind_68(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.unbind")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::unbind(std::string const &event_name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).unbind)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "unbind(const LUIBaseElement self, str event_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_unbind_68_comment =
  "C++ Interface:\n"
  "unbind(const LUIBaseElement self, str event_name)\n"
  "\n"
  "/**\n"
  " * @brief Unbinds an event handler\n"
  " * @details Unbinds a event handler, in case one is bound to the given event.\n"
  " *   If there was no event handler for the given event, a warning is printed, and\n"
  " *   nothing happens.\n"
  " *\n"
  " * @param event_name Name of the event to unbind the handler for\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_unbind_68_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::unbind_all(void)
 */
static PyObject *Dtool_LUIBaseElement_unbind_all_69(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.unbind_all")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::unbind_all(void)
  ((*local_this).unbind_all)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_unbind_all_69_comment =
  "C++ Interface:\n"
  "unbind_all(const LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Unbinds all events\n"
  " * @details This unbinds the element from all events, effectively calling unbind()\n"
  " *   for every registered event. You should be careful on this, since most builtin\n"
  " *   events will rely on certain events to be bound to them.\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_unbind_all_69_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LUIBaseElement::has_event(std::string const &event_name)
 */
static PyObject *Dtool_LUIBaseElement_has_event_70(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.has_event")) {
    return nullptr;
  }
  // 1-inline bool LUIBaseElement::has_event(std::string const &event_name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*local_this).has_event)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_event(const LUIBaseElement self, str event_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_has_event_70_comment =
  "C++ Interface:\n"
  "has_event(const LUIBaseElement self, str event_name)\n"
  "\n"
  "/**\n"
  " * @brief Checks whether an event handler is bound to the given event\n"
  " * @details This checks whether there is a event handler for the event.\n"
  " *   Returns true if there is a handler bound to the event, otherwise false.\n"
  " *\n"
  " * @param event_name Name of the evenet\n"
  " * @return true if the event has an event handler, false otherwise\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_has_event_70_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LUIBaseElement::trigger_event(PointerTo< LUIEventData > data)
 * void LUIBaseElement::trigger_event(std::string const &event_name, std::wstring const &message = wstring(), LPoint2 const &coords = LPoint2(0))
 */
static PyObject *Dtool_LUIBaseElement_trigger_event_71(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.trigger_event")) {
    return nullptr;
  }
  {
    // -2 void LUIBaseElement::trigger_event(std::string const &event_name, std::wstring const &message = wstring(), LPoint2 const &coords = LPoint2(0))
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_VERSION_HEX >= 0x03020000
    PyObject *param2 = nullptr;
#else
    PyUnicodeObject *param2 = nullptr;
#endif
    PyObject *param3 = nullptr;
    static const char *keyword_list[] = {"event_name", "message", "coords", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|UO:trigger_event", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
      Py_ssize_t param2_len;
      wchar_t *param2_str = nullptr;
      std::wstring param2_wstr;
      if (param2 != nullptr) {
#if PY_VERSION_HEX >= 0x03030000
        param2_str = PyUnicode_AsWideCharString(param2, &param2_len);
#else
        param2_len = PyUnicode_GET_SIZE(param2);
        param2_str = (wchar_t *)alloca(sizeof(wchar_t) * (param2_len + 1));
      PyUnicode_AsWideChar(param2, param2_str, param2_len);
#endif
        param2_wstr.assign(param2_str, param2_len);
      } else {
        param2_wstr = std::wstring();
      }
      LPoint2 const *param3_this;
      const LPoint2f &param3_ref = LPoint2(0);
      if (param3 == nullptr) {
        param3_this = &param3_ref;
      } else {
        param3_this = nullptr;
        DtoolInstance_GetPointer(param3, param3_this, *Dtool_Ptr_LPoint2f);
      }
      if ((param3 == nullptr || param3_this != nullptr)) {
        ((*local_this).trigger_event)(std::string(param1_str, param1_len), std::wstring(std::move(param2_wstr)), *param3_this);
#if PY_VERSION_HEX >= 0x03030000
        PyMem_Free(param2_str);
#endif
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  {
    // -2 void LUIBaseElement::trigger_event(PointerTo< LUIEventData > data)
    PyObject *param1;
    if (Dtool_ExtractArg(&param1, args, kwds, "data")) {
      LUIEventData *param1_this = (LUIEventData *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LUIEventData, 1, "LUIBaseElement.trigger_event", false, false);
      if (param1_this != nullptr) {
        ((*local_this).trigger_event)(param1_this);
        return Dtool_Return_None();
      }
    }
  }

  {
    // -2 void LUIBaseElement::trigger_event(std::string const &event_name, std::wstring const &message = wstring(), LPoint2 const &coords = LPoint2(0))
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_VERSION_HEX >= 0x03020000
    PyObject *param2 = nullptr;
#else
    PyUnicodeObject *param2 = nullptr;
#endif
    PyObject *param3 = nullptr;
    static const char *keyword_list[] = {"event_name", "message", "coords", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "s#|UO:trigger_event", (char **)keyword_list, &param1_str, &param1_len, &param2, &param3)) {
      Py_ssize_t param2_len;
      wchar_t *param2_str = nullptr;
      std::wstring param2_wstr;
      if (param2 != nullptr) {
#if PY_VERSION_HEX >= 0x03030000
        param2_str = PyUnicode_AsWideCharString(param2, &param2_len);
#else
        param2_len = PyUnicode_GET_SIZE(param2);
        param2_str = (wchar_t *)alloca(sizeof(wchar_t) * (param2_len + 1));
      PyUnicode_AsWideChar(param2, param2_str, param2_len);
#endif
        param2_wstr.assign(param2_str, param2_len);
      } else {
        param2_wstr = std::wstring();
      }
      LPoint2f param3_local;
      LPoint2 const *param3_this;
      if (param3 != nullptr) {
        param3_this = Dtool_Coerce_LPoint2f(param3, param3_local);
      } else {
        param3_local = LPoint2(0);
        param3_this = &param3_local;
      }
      if ((param3 == nullptr || (param3_this != nullptr))) {
        ((*local_this).trigger_event)(std::string(param1_str, param1_len), std::wstring(std::move(param2_wstr)), *param3_this);
#if PY_VERSION_HEX >= 0x03030000
        PyMem_Free(param2_str);
#endif
        return Dtool_Return_None();
      }
    }
    PyErr_Clear();
  }

  // No coercion possible: void LUIBaseElement::trigger_event(PointerTo< LUIEventData > data)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "trigger_event(const LUIBaseElement self, str event_name, unicode message, const LPoint2f coords)\n"
      "trigger_event(const LUIBaseElement self, LUIEventData data)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_trigger_event_71_comment =
  "C++ Interface:\n"
  "trigger_event(const LUIBaseElement self, str event_name, unicode message, const LPoint2f coords)\n"
  "trigger_event(const LUIBaseElement self, LUIEventData data)\n"
  "\n"
  "/**\n"
  " * @brief Triggers an event\n"
  " * @details This triggers an event with the given name and a message. Optionally\n"
  " *   coordinates can be passed, e.g. for mousemove events.\n"
  " *   If no event handler is bound to this event, nothing happens. Otherwise the\n"
  " *   event handler is called with the event data.\n"
  " *\n"
  " * @param event_name Name of the event\n"
  " * @param message Optional message of the event\n"
  " * @param coords Optional coordinates of the event\n"
  " */\n"
  "\n"
  "/**\n"
  " * @brief Triggers an event\n"
  " * @details This triggers an event with the given EventData.\n"
  " *   If no event handler is bound to this event, nothing happens. Otherwise the\n"
  " *   event handler is called with the event data.\n"
  " *\n"
  " * @param data Event data\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_trigger_event_71_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_name(std::string const &name)
 */
static PyObject *Dtool_LUIBaseElement_set_name_72(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_name")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::set_name(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_name)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_name(const LUIBaseElement self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_name_72_comment =
  "C++ Interface:\n"
  "set_name(const LUIBaseElement self, str name)\n"
  "\n"
  "// NAME\n"
  "\n"
  "// NAME\n"
  "\n"
  "/**\n"
  " * @brief Sets the elements name\n"
  " * @details This sets the name of the element, which can get queried by get_name\n"
  " *   later on. This does not expose any functionality, and only is a help for the\n"
  " *   user.\n"
  " *\n"
  " * @param name Name of the element\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_name_72_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &LUIBaseElement::get_name(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_name_73(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline std::string const &LUIBaseElement::get_name(void) const
  std::string const &return_value = ((*(const LUIBaseElement*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_name_73_comment =
  "C++ Interface:\n"
  "get_name(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the name of the element\n"
  " * @details Returns the name of the element, or an empty string if no name\n"
  " *   was set yet.\n"
  " *\n"
  " * @return Name of the element\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_name_73_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_top_left(LPoint2 const &pos)
 */
static PyObject *Dtool_LUIBaseElement_set_top_left_74(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_top_left")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::set_top_left(LPoint2 const &pos)
  LPoint2f arg_local;
  LPoint2 const *arg_this = Dtool_Coerce_LPoint2f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LUIBaseElement.set_top_left", "LPoint2f");
  }
  ((*local_this).set_top_left)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_top_left(const LUIBaseElement self, const LPoint2f pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_top_left_74_comment =
  "C++ Interface:\n"
  "set_top_left(const LUIBaseElement self, const LPoint2f pos)\n"
  "\n"
  "// Position\n"
  "\n"
  "// Position\n"
  "\n"
  "/**\n"
  " * @brief Sets the top left position\n"
  " * @details This makes the element aligned top/left and sets its position relative\n"
  " *   to that corner.\n"
  " *\n"
  " * @param pos Distance to the top-left corner\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_top_left_74_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_top_right(LPoint2 const &pos)
 */
static PyObject *Dtool_LUIBaseElement_set_top_right_75(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_top_right")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::set_top_right(LPoint2 const &pos)
  LPoint2f arg_local;
  LPoint2 const *arg_this = Dtool_Coerce_LPoint2f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LUIBaseElement.set_top_right", "LPoint2f");
  }
  ((*local_this).set_top_right)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_top_right(const LUIBaseElement self, const LPoint2f pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_top_right_75_comment =
  "C++ Interface:\n"
  "set_top_right(const LUIBaseElement self, const LPoint2f pos)\n"
  "\n"
  "/**\n"
  " * @brief Sets the top right position\n"
  " * @details This makes the element aligned top/right and sets its position relative\n"
  " *   to that corner.\n"
  " *\n"
  " * @param pos Distance to the top-right corner\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_top_right_75_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_bottom_left(LPoint2 const &pos)
 */
static PyObject *Dtool_LUIBaseElement_set_bottom_left_76(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_bottom_left")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::set_bottom_left(LPoint2 const &pos)
  LPoint2f arg_local;
  LPoint2 const *arg_this = Dtool_Coerce_LPoint2f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LUIBaseElement.set_bottom_left", "LPoint2f");
  }
  ((*local_this).set_bottom_left)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bottom_left(const LUIBaseElement self, const LPoint2f pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_bottom_left_76_comment =
  "C++ Interface:\n"
  "set_bottom_left(const LUIBaseElement self, const LPoint2f pos)\n"
  "\n"
  "/**\n"
  " * @brief Sets the bottom left position\n"
  " * @details This makes the element aligned bottom/left and sets its position relative\n"
  " *   to that corner.\n"
  " *\n"
  " * @param pos Distance to the bottom-\37777777703\37777777666eft corner\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_bottom_left_76_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_bottom_right(LPoint2 const &pos)
 */
static PyObject *Dtool_LUIBaseElement_set_bottom_right_77(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_bottom_right")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::set_bottom_right(LPoint2 const &pos)
  LPoint2f arg_local;
  LPoint2 const *arg_this = Dtool_Coerce_LPoint2f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LUIBaseElement.set_bottom_right", "LPoint2f");
  }
  ((*local_this).set_bottom_right)(*arg_this);
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bottom_right(const LUIBaseElement self, const LPoint2f pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_bottom_right_77_comment =
  "C++ Interface:\n"
  "set_bottom_right(const LUIBaseElement self, const LPoint2f pos)\n"
  "\n"
  "/**\n"
  " * @brief Sets the bottom right position\n"
  " * @details This makes the element aligned bottom/right and sets its position relative\n"
  " *   to that corner.\n"
  " *\n"
  " * @param pos Distance to the bottom-right corner\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_bottom_right_77_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2 LUIBaseElement::get_top_left(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_top_left_78(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline LPoint2 LUIBaseElement::get_top_left(void) const
  LPoint2 *return_value = new LPoint2(((*(const LUIBaseElement*)local_this).get_top_left)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_top_left_78_comment =
  "C++ Interface:\n"
  "get_top_left(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the distance to the top left corner\n"
  " * @details This returns the distance to the top left corner. The returned value\n"
  " *   is only meaningful if the elment is aligned top left.\n"
  " * @return Distance to the top left corner\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_top_left_78_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2 LUIBaseElement::get_top_right(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_top_right_79(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline LPoint2 LUIBaseElement::get_top_right(void) const
  LPoint2 *return_value = new LPoint2(((*(const LUIBaseElement*)local_this).get_top_right)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_top_right_79_comment =
  "C++ Interface:\n"
  "get_top_right(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the distance to the top right corner\n"
  " * @details This returns the distance to the top right corner. The returned value\n"
  " *   is only meaningful if the elment is aligned top right.\n"
  " * @return Distance to the top right corner\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_top_right_79_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2 LUIBaseElement::get_bottom_left(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_bottom_left_80(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline LPoint2 LUIBaseElement::get_bottom_left(void) const
  LPoint2 *return_value = new LPoint2(((*(const LUIBaseElement*)local_this).get_bottom_left)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_bottom_left_80_comment =
  "C++ Interface:\n"
  "get_bottom_left(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the distance to the bottom left corner\n"
  " * @details This returns the distance to the bottom left corner. The returned value\n"
  " *   is only meaningful if the elment is aligned bottom left.\n"
  " * @return Distance to the bottom left corner\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_bottom_left_80_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2 LUIBaseElement::get_bottom_right(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_bottom_right_81(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline LPoint2 LUIBaseElement::get_bottom_right(void) const
  LPoint2 *return_value = new LPoint2(((*(const LUIBaseElement*)local_this).get_bottom_right)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_bottom_right_81_comment =
  "C++ Interface:\n"
  "get_bottom_right(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the distance to the bottom right corner\n"
  " * @details This returns the distance to the bottom right corner. The returned value\n"
  " *   is only meaningful if the elment is aligned bottom right.\n"
  " * @return Distance to the bottom right corner\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_bottom_right_81_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_pos(LPoint2 const &pos)
 * inline void LUIBaseElement::set_pos(float x, float y)
 */
static PyObject *Dtool_LUIBaseElement_set_pos_82(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_pos")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "pos")) {
        // 1-inline void LUIBaseElement::set_pos(LPoint2 const &pos)
        LPoint2f arg_local;
        LPoint2 const *arg_this = Dtool_Coerce_LPoint2f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "LUIBaseElement.set_pos", "LPoint2f");
        }
        ((*local_this).set_pos)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      // 1-inline void LUIBaseElement::set_pos(float x, float y)
      float param1;
      float param2;
      static const char *keyword_list[] = {"x", "y", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_pos", (char **)keyword_list, &param1, &param2)) {
        ((*local_this).set_pos)((float)param1, (float)param2);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_pos() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_pos(const LUIBaseElement self, const LPoint2f pos)\n"
      "set_pos(const LUIBaseElement self, float x, float y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_pos_82_comment =
  "C++ Interface:\n"
  "set_pos(const LUIBaseElement self, const LPoint2f pos)\n"
  "set_pos(const LUIBaseElement self, float x, float y)\n"
  "\n"
  "/**\n"
  " * @brief Sets the top left position\n"
  " * @details This is an alias for LUIBaseElement::set_top_left()\n"
  " *\n"
  " * @param pos See LUIBaseElement::set_top_left()\n"
  " */\n"
  "\n"
  "/**\n"
  " * @brief Sets the top left position\n"
  " * @details This is an alias for LUIBaseElement::set_top_left()\n"
  " *\n"
  " * @param x See LUIBaseElement::set_top_left()\n"
  " * @param y See LUIBaseElement::set_top_left()\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_pos_82_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2 LUIBaseElement::get_pos(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_pos_83(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline LPoint2 LUIBaseElement::get_pos(void) const
  LPoint2 *return_value = new LPoint2(((*(const LUIBaseElement*)local_this).get_pos)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_pos_83_comment =
  "C++ Interface:\n"
  "get_pos(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the top left position\n"
  " * @details This is an alias for LUIBaseElement::get_top_left().\n"
  " * @return Top left position\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_pos_83_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2 LUIBaseElement::get_abs_pos(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_abs_pos_84(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline LPoint2 LUIBaseElement::get_abs_pos(void) const
  LPoint2 *return_value = new LPoint2(((*(const LUIBaseElement*)local_this).get_abs_pos)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_abs_pos_84_comment =
  "C++ Interface:\n"
  "get_abs_pos(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the elements absolute position.\n"
  " * @details This returns the last frame absolute position of the element.\n"
  " *   You should not rely on this method to return correct values, since it is\n"
  " *   only valid after at least one frame has been rendered.\n"
  " * @return Absolute position in pixels of the element\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_abs_pos_84_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_top(float top)
 */
static PyObject *Dtool_LUIBaseElement_set_top_85(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_top")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::set_top(float top)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_top)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_top(const LUIBaseElement self, float top)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_top_85_comment =
  "C++ Interface:\n"
  "set_top(const LUIBaseElement self, float top)\n"
  "\n"
  "/**\n"
  " * @brief Sets the top position of the element\n"
  " * @details This makes the element aligned to the top, and sets the distance\n"
  " *   to the top.\n"
  " *\n"
  " * @param top Distance to the top\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_top_85_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_right(float right)
 */
static PyObject *Dtool_LUIBaseElement_set_right_86(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_right")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::set_right(float right)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_right)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_right(const LUIBaseElement self, float right)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_right_86_comment =
  "C++ Interface:\n"
  "set_right(const LUIBaseElement self, float right)\n"
  "\n"
  "/**\n"
  " * @brief Sets the right position of the element\n"
  " * @details This makes the element aligned to the right, and sets the distance\n"
  " *   to the right.\n"
  " *\n"
  " * @param right Distance to the right\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_right_86_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_bottom(float bottom)
 */
static PyObject *Dtool_LUIBaseElement_set_bottom_87(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_bottom")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::set_bottom(float bottom)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_bottom)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_bottom(const LUIBaseElement self, float bottom)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_bottom_87_comment =
  "C++ Interface:\n"
  "set_bottom(const LUIBaseElement self, float bottom)\n"
  "\n"
  "/**\n"
  " * @brief Sets the bottom position of the element\n"
  " * @details This makes the element aligned to the bottom, and sets the distance\n"
  " *   to the bottom.\n"
  " *\n"
  " * @param bottom Distance to the bottom\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_bottom_87_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_left(float left)
 */
static PyObject *Dtool_LUIBaseElement_set_left_88(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_left")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::set_left(float left)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_left)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_left(const LUIBaseElement self, float left)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_left_88_comment =
  "C++ Interface:\n"
  "set_left(const LUIBaseElement self, float left)\n"
  "\n"
  "/**\n"
  " * @brief Sets the left position of the element\n"
  " * @details This makes the element aligned to the left, and sets the distance\n"
  " *   to the left.\n"
  " *\n"
  " * @param left Distance to the right\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_left_88_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float LUIBaseElement::get_top(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_top_89(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline float LUIBaseElement::get_top(void) const
  float return_value = ((*(const LUIBaseElement*)local_this).get_top)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_top_89_comment =
  "C++ Interface:\n"
  "get_top(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the distance to the top\n"
  " * @details This returns the distance to the top. This value is only meaningful\n"
  " *   if the element is aligned to the top.\n"
  " *\n"
  " * @return Distance to the top.\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_top_89_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float LUIBaseElement::get_right(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_right_90(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline float LUIBaseElement::get_right(void) const
  float return_value = ((*(const LUIBaseElement*)local_this).get_right)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_right_90_comment =
  "C++ Interface:\n"
  "get_right(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the distance to the right\n"
  " * @details This returns the distance to the right. This value is only meaningful\n"
  " *   if the element is aligned to the right.\n"
  " *\n"
  " * @return Distance to the right.\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_right_90_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float LUIBaseElement::get_bottom(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_bottom_91(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline float LUIBaseElement::get_bottom(void) const
  float return_value = ((*(const LUIBaseElement*)local_this).get_bottom)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_bottom_91_comment =
  "C++ Interface:\n"
  "get_bottom(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the distance to the bottom\n"
  " * @details This returns the distance to the bottom. This value is only meaningful\n"
  " *   if the element is aligned to the bottom.\n"
  " *\n"
  " * @return Distance to the bottom.\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_bottom_91_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float LUIBaseElement::get_left(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_left_92(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline float LUIBaseElement::get_left(void) const
  float return_value = ((*(const LUIBaseElement*)local_this).get_left)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_left_92_comment =
  "C++ Interface:\n"
  "get_left(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the distance to the left\n"
  " * @details This returns the distance to the left. This value is only meaningful\n"
  " *   if the element is aligned to the left.\n"
  " *\n"
  " * @return Distance to the left.\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_left_92_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_centered(bool center_vert = true, bool center_horiz = true)
 */
static PyObject *Dtool_LUIBaseElement_set_centered_93(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_centered")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::set_centered(bool center_vert = true, bool center_horiz = true)
  PyObject *param1 = Py_True;
  PyObject *param2 = Py_True;
  static const char *keyword_list[] = {"center_vert", "center_horiz", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|OO:set_centered", (char **)keyword_list, &param1, &param2)) {
    ((*local_this).set_centered)((PyObject_IsTrue(param1) != 0), (PyObject_IsTrue(param2) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_centered(const LUIBaseElement self, bool center_vert, bool center_horiz)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_centered_93_comment =
  "C++ Interface:\n"
  "set_centered(const LUIBaseElement self, bool center_vert, bool center_horiz)\n"
  "\n"
  "/**\n"
  " * @brief Sets whether to center the element\n"
  " * @details This method controls whether to center the element horizontally\n"
  " *   or vertically. When passing false to either center_vert or center_horiz,\n"
  " *   nothing in that direction happens.\n"
  " *\n"
  " *   For example:\n"
  " *     set_centered(true, false) makes the element center vertically,\n"
  " *     but keep its horizontal position.\n"
  " *\n"
  " *     set_centered(false, true) makes the element center horizontally,\n"
  " *     but keep its vertical position.\n"
  " *\n"
  " *     set_centered(true, true) makes the element center in both dimensions\n"
  " *\n"
  " *   However, set_centered(false, false) emits a warning, since it effectively\n"
  " *   does nothing.\n"
  " *\n"
  " * @param center_vert Whether to center the element vertically\n"
  " * @param center_horiz Whether to center the element horizontally\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_centered_93_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_center_vertical(bool centered = true)
 */
static PyObject *Dtool_LUIBaseElement_set_center_vertical_94(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_center_vertical")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::set_center_vertical(bool centered = true)
  PyObject *param1 = Py_True;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "centered")) {
    ((*local_this).set_center_vertical)((PyObject_IsTrue(param1) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_center_vertical(const LUIBaseElement self, bool centered)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_center_vertical_94_comment =
  "C++ Interface:\n"
  "set_center_vertical(const LUIBaseElement self, bool centered)\n"
  "\n"
  "/**\n"
  " * @brief Sets whether to center the element vertically\n"
  " * @details This makes the element center vertically. If centered is set to false,\n"
  " *   a warning is printed. The centered parameter only exists to be able to do\n"
  " *   element.center_vertical = True in python. The parameter should never be\n"
  " *   false. To un-center an element, instead call set_top or set_bottom.\n"
  " *\n"
  " * @param centered Should always be true\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_center_vertical_94_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_center_horizontal(bool centered = true)
 */
static PyObject *Dtool_LUIBaseElement_set_center_horizontal_95(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_center_horizontal")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::set_center_horizontal(bool centered = true)
  PyObject *param1 = Py_True;
  if (Dtool_ExtractOptionalArg(&param1, args, kwds, "centered")) {
    ((*local_this).set_center_horizontal)((PyObject_IsTrue(param1) != 0));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_center_horizontal(const LUIBaseElement self, bool centered)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_center_horizontal_95_comment =
  "C++ Interface:\n"
  "set_center_horizontal(const LUIBaseElement self, bool centered)\n"
  "\n"
  "/**\n"
  " * @brief Sets whether to center the element horizontally\n"
  " * @details This makes the element center horizontally. If centered is set to false,\n"
  " *   a warning is printed. The centered parameter only exists to be able to do\n"
  " *   element.center_horizontal = True in python. The parameter should never be\n"
  " *   false. To un-center an element, instead call set_left or set_right.\n"
  " *\n"
  " * @param centered Should always be true\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_center_horizontal_95_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LUIBaseElement::is_centered(void) const
 */
static PyObject *Dtool_LUIBaseElement_is_centered_96(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline bool LUIBaseElement::is_centered(void) const
  bool return_value = ((*(const LUIBaseElement*)local_this).is_centered)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_is_centered_96_comment =
  "C++ Interface:\n"
  "is_centered(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns whether the element is centered\n"
  " * @details This returns whether the element is horizontally and vertically\n"
  " *   centered.\n"
  " *\n"
  " * @return true if the element is centered, false otherweise\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_is_centered_96_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LUIBaseElement::is_vertical_centered(void) const
 */
static PyObject *Dtool_LUIBaseElement_is_vertical_centered_97(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline bool LUIBaseElement::is_vertical_centered(void) const
  bool return_value = ((*(const LUIBaseElement*)local_this).is_vertical_centered)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_is_vertical_centered_97_comment =
  "C++ Interface:\n"
  "is_vertical_centered(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns whether the element is vertically centered\n"
  " * @details This returns whether the element is vertically centered.\n"
  " * @return true if the element is vertically centered\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_is_vertical_centered_97_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LUIBaseElement::is_horizontal_centered(void) const
 */
static PyObject *Dtool_LUIBaseElement_is_horizontal_centered_98(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline bool LUIBaseElement::is_horizontal_centered(void) const
  bool return_value = ((*(const LUIBaseElement*)local_this).is_horizontal_centered)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_is_horizontal_centered_98_comment =
  "C++ Interface:\n"
  "is_horizontal_centered(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns whether the element is horizontally centered\n"
  " * @details This returns whether the element is horizontally centered.\n"
  " * @return true if the element is horizontally centered\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_is_horizontal_centered_98_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_margin(LVector4 const &margin)
 * inline void LUIBaseElement::set_margin(float margin)
 * inline void LUIBaseElement::set_margin(float top, float right, float bottom, float left)
 */
static PyObject *Dtool_LUIBaseElement_set_margin_99(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_margin")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "margin")) {
        {
          // -2 inline void LUIBaseElement::set_margin(LVector4 const &margin)
          LVector4 const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVector4f);
          if (arg_this != nullptr) {
            ((*local_this).set_margin)(*arg_this);
            return Dtool_Return_None();
          }
        }

        {
          // -2 inline void LUIBaseElement::set_margin(float margin)
          if (PyNumber_Check(arg)) {
            ((*local_this).set_margin)((float)PyFloat_AsDouble(arg));
            return Dtool_Return_None();
          }
        }

        {
          // -2 inline void LUIBaseElement::set_margin(LVector4 const &margin)
          LVector4f arg_local;
          LVector4 const *arg_this = Dtool_Coerce_LVector4f(arg, arg_local);
          if ((arg_this != nullptr)) {
            ((*local_this).set_margin)(*arg_this);
            return Dtool_Return_None();
          }
        }

        // No coercion possible: inline void LUIBaseElement::set_margin(float margin)
      }
    }
    break;
  case 4:
    {
      // 1-inline void LUIBaseElement::set_margin(float top, float right, float bottom, float left)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"top", "right", "bottom", "left", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_margin", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).set_margin)((float)param1, (float)param2, (float)param3, (float)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_margin() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_margin(const LUIBaseElement self, const LVector4f margin)\n"
      "set_margin(const LUIBaseElement self, float margin)\n"
      "set_margin(const LUIBaseElement self, float top, float right, float bottom, float left)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_margin_99_comment =
  "C++ Interface:\n"
  "set_margin(const LUIBaseElement self, const LVector4f margin)\n"
  "set_margin(const LUIBaseElement self, float margin)\n"
  "set_margin(const LUIBaseElement self, float top, float right, float bottom, float left)\n"
  "\n"
  "// Margin\n"
  "\n"
  "// Margin\n"
  "\n"
  "/**\n"
  " * @brief Sets the margin of the element\n"
  " * @details This sets the margin of the element. The margin should be stored in\n"
  " *   the order top, right, bottom, left (as in CSS, TRouBLe). The margin controls\n"
  " *   the distance to the sides, and behaves just like in CSS.\n"
  " *\n"
  " * @param margin Margin in pixels, top, right, bottom, left\n"
  " */\n"
  "\n"
  "/**\n"
  " * @brief Sets the margin of the element\n"
  " * @details This sets the margin of the element. The margin controls the distance\n"
  " *   to the sides, and behaves just like in CSS:\n"
  " *\n"
  " * @param top Margin to the top\n"
  " * @param right Margin to the right\n"
  " * @param bottom Margin to the bottom\n"
  " * @param left Margin to the left\n"
  " */\n"
  "\n"
  "/**\n"
  " * @brief Sets the margin of the element\n"
  " * @details Sets an equal margin to all sides of the element, this is equal to\n"
  " *   calling LUIBaseElement::set_margin(margin, margin, margin, margin).\n"
  " *\n"
  " * @param margin Margin to all sides\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_margin_99_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_margin_top(float top)
 */
static PyObject *Dtool_LUIBaseElement_set_margin_top_100(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_margin_top")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::set_margin_top(float top)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_margin_top)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_margin_top(const LUIBaseElement self, float top)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_margin_top_100_comment =
  "C++ Interface:\n"
  "set_margin_top(const LUIBaseElement self, float top)\n"
  "\n"
  "/**\n"
  " * @brief Sets the top-margin\n"
  " * @details This sets only the top-margin, see LUIBaseElement::set_margin()\n"
  " *\n"
  " * @param top Margin to the top\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_margin_top_100_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_margin_right(float right)
 */
static PyObject *Dtool_LUIBaseElement_set_margin_right_101(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_margin_right")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::set_margin_right(float right)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_margin_right)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_margin_right(const LUIBaseElement self, float right)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_margin_right_101_comment =
  "C++ Interface:\n"
  "set_margin_right(const LUIBaseElement self, float right)\n"
  "\n"
  "/**\n"
  " * @brief Sets the right-margin\n"
  " * @details This sets only the right-margin, see LUIBaseElement::set_margin()\n"
  " *\n"
  " * @param right Margin to the right\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_margin_right_101_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_margin_bottom(float bottom)
 */
static PyObject *Dtool_LUIBaseElement_set_margin_bottom_102(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_margin_bottom")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::set_margin_bottom(float bottom)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_margin_bottom)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_margin_bottom(const LUIBaseElement self, float bottom)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_margin_bottom_102_comment =
  "C++ Interface:\n"
  "set_margin_bottom(const LUIBaseElement self, float bottom)\n"
  "\n"
  "/**\n"
  " * @brief Sets the bottom-margin\n"
  " * @details This sets only the bottom-margin, see LUIBaseElement::set_margin()\n"
  " *\n"
  " * @param bottom Margin to the bottom\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_margin_bottom_102_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_margin_left(float left)
 */
static PyObject *Dtool_LUIBaseElement_set_margin_left_103(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_margin_left")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::set_margin_left(float left)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_margin_left)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_margin_left(const LUIBaseElement self, float left)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_margin_left_103_comment =
  "C++ Interface:\n"
  "set_margin_left(const LUIBaseElement self, float left)\n"
  "\n"
  "/**\n"
  " * @brief Sets the left-margin\n"
  " * @details This sets only the left-margin, see LUIBaseElement::set_margin()\n"
  " *\n"
  " * @param left Margin to the left\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_margin_left_103_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float LUIBaseElement::get_margin_top(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_margin_top_104(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline float LUIBaseElement::get_margin_top(void) const
  float return_value = ((*(const LUIBaseElement*)local_this).get_margin_top)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_margin_top_104_comment =
  "C++ Interface:\n"
  "get_margin_top(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the margin to the top\n"
  " * @details This returns the margin to the top\n"
  " * @return Margin to the top\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_margin_top_104_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float LUIBaseElement::get_margin_right(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_margin_right_105(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline float LUIBaseElement::get_margin_right(void) const
  float return_value = ((*(const LUIBaseElement*)local_this).get_margin_right)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_margin_right_105_comment =
  "C++ Interface:\n"
  "get_margin_right(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the margin to the right\n"
  " * @details This returns the margin to the right\n"
  " * @return Margin to the right\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_margin_right_105_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float LUIBaseElement::get_margin_bottom(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_margin_bottom_106(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline float LUIBaseElement::get_margin_bottom(void) const
  float return_value = ((*(const LUIBaseElement*)local_this).get_margin_bottom)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_margin_bottom_106_comment =
  "C++ Interface:\n"
  "get_margin_bottom(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the margin to the bottom\n"
  " * @details This returns the margin to the bottom\n"
  " * @return Margin to the bottom\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_margin_bottom_106_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float LUIBaseElement::get_margin_left(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_margin_left_107(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline float LUIBaseElement::get_margin_left(void) const
  float return_value = ((*(const LUIBaseElement*)local_this).get_margin_left)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_margin_left_107_comment =
  "C++ Interface:\n"
  "get_margin_left(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the margin to the left\n"
  " * @details This returns the margin to the left\n"
  " * @return Margin to the left\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_margin_left_107_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LUIBounds &LUIBaseElement::get_margin(void)
 * inline LUIBounds const &LUIBaseElement::get_margin(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_margin_108(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 inline LUIBounds &LUIBaseElement::get_margin(void)
    LUIBounds *return_value = &(((*local_this).get_margin)());
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LUIBounds, false, false);
  }

  {
    // -2 inline LUIBounds const &LUIBaseElement::get_margin(void) const
    LUIBounds const *return_value = &(((*(const LUIBaseElement*)local_this).get_margin)());
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LUIBounds, false, true);
  }

  // No coercion possible: inline LUIBounds &LUIBaseElement::get_margin(void)
  // No coercion possible: inline LUIBounds const &LUIBaseElement::get_margin(void) const
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_margin_108_comment =
  "C++ Interface:\n"
  "get_margin(const LUIBaseElement self)\n"
  "get_margin(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the margin of the element.\n"
  " * @details This returns the margin of the element. This method returns a non-const\n"
  " *   reference, thus .get_margin().set_top(123) is perfectly fine. This is mainly\n"
  " *   to support property chaining in python, so the user can do .margin.left = 5\n"
  " * @return Handle to the margin bounds\n"
  " */\n"
  "\n"
  "/**\n"
  " * @brief Returns the margin of the element\n"
  " * @details This returns the margin of the element, as const-version, so the bounds\n"
  " *   are read-only.\n"
  " * @return Readonly handle to the margin bounds\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_margin_108_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_padding(LVector4 const &padding)
 * inline void LUIBaseElement::set_padding(float padding)
 * inline void LUIBaseElement::set_padding(float top, float right, float bottom, float left)
 */
static PyObject *Dtool_LUIBaseElement_set_padding_109(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_padding")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "padding")) {
        {
          // -2 inline void LUIBaseElement::set_padding(LVector4 const &padding)
          LVector4 const *arg_this = nullptr;
          DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVector4f);
          if (arg_this != nullptr) {
            ((*local_this).set_padding)(*arg_this);
            return Dtool_Return_None();
          }
        }

        {
          // -2 inline void LUIBaseElement::set_padding(float padding)
          if (PyNumber_Check(arg)) {
            ((*local_this).set_padding)((float)PyFloat_AsDouble(arg));
            return Dtool_Return_None();
          }
        }

        {
          // -2 inline void LUIBaseElement::set_padding(LVector4 const &padding)
          LVector4f arg_local;
          LVector4 const *arg_this = Dtool_Coerce_LVector4f(arg, arg_local);
          if ((arg_this != nullptr)) {
            ((*local_this).set_padding)(*arg_this);
            return Dtool_Return_None();
          }
        }

        // No coercion possible: inline void LUIBaseElement::set_padding(float padding)
      }
    }
    break;
  case 4:
    {
      // 1-inline void LUIBaseElement::set_padding(float top, float right, float bottom, float left)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"top", "right", "bottom", "left", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_padding", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).set_padding)((float)param1, (float)param2, (float)param3, (float)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_padding() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_padding(const LUIBaseElement self, const LVector4f padding)\n"
      "set_padding(const LUIBaseElement self, float padding)\n"
      "set_padding(const LUIBaseElement self, float top, float right, float bottom, float left)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_padding_109_comment =
  "C++ Interface:\n"
  "set_padding(const LUIBaseElement self, const LVector4f padding)\n"
  "set_padding(const LUIBaseElement self, float padding)\n"
  "set_padding(const LUIBaseElement self, float top, float right, float bottom, float left)\n"
  "\n"
  "// Padding\n"
  "\n"
  "// Padding\n"
  "\n"
  "/**\n"
  " * @brief Sets the padding of the element\n"
  " * @details This sets the padding of the element. The padding should be stored in\n"
  " *   the order top, right, bottom, left (as in CSS, TRouBLe). The padding controls\n"
  " *   the distance to the sides, and behaves just like in CSS.\n"
  " *\n"
  " * @param padding padding in pixels, top, right, bottom, left\n"
  " */\n"
  "\n"
  "/**\n"
  " * @brief Sets the padding of the element\n"
  " * @details This sets the padding of the element. The padding controls the distance\n"
  " *   to the sides, and behaves just like in CSS:\n"
  " *\n"
  " * @param top padding to the top\n"
  " * @param right padding to the right\n"
  " * @param bottom padding to the bottom\n"
  " * @param left padding to the left\n"
  " */\n"
  "\n"
  "/**\n"
  " * @brief Sets the padding of the element\n"
  " * @details Sets an equal padding to all sides of the element, this is equal to\n"
  " *   calling LUIBaseElement::set_padding(padding, padding, padding, padding).\n"
  " *\n"
  " * @param padding padding to all sides\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_padding_109_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_padding_top(float top)
 */
static PyObject *Dtool_LUIBaseElement_set_padding_top_110(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_padding_top")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::set_padding_top(float top)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_padding_top)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_padding_top(const LUIBaseElement self, float top)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_padding_top_110_comment =
  "C++ Interface:\n"
  "set_padding_top(const LUIBaseElement self, float top)\n"
  "\n"
  "/**\n"
  " * @brief Sets the top-padding\n"
  " * @details This sets only the top-padding, see LUIBaseElement::set_padding()\n"
  " *\n"
  " * @param top padding to the top\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_padding_top_110_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_padding_right(float right)
 */
static PyObject *Dtool_LUIBaseElement_set_padding_right_111(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_padding_right")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::set_padding_right(float right)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_padding_right)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_padding_right(const LUIBaseElement self, float right)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_padding_right_111_comment =
  "C++ Interface:\n"
  "set_padding_right(const LUIBaseElement self, float right)\n"
  "\n"
  "/**\n"
  " * @brief Sets the right-padding\n"
  " * @details This sets only the right-padding, see LUIBaseElement::set_padding()\n"
  " *\n"
  " * @param right padding to the right\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_padding_right_111_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_padding_bottom(float bottom)
 */
static PyObject *Dtool_LUIBaseElement_set_padding_bottom_112(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_padding_bottom")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::set_padding_bottom(float bottom)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_padding_bottom)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_padding_bottom(const LUIBaseElement self, float bottom)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_padding_bottom_112_comment =
  "C++ Interface:\n"
  "set_padding_bottom(const LUIBaseElement self, float bottom)\n"
  "\n"
  "/**\n"
  " * @brief Sets the bottom-padding\n"
  " * @details This sets only the bottom-padding, see LUIBaseElement::set_padding()\n"
  " *\n"
  " * @param bottom padding to the bottom\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_padding_bottom_112_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_padding_left(float left)
 */
static PyObject *Dtool_LUIBaseElement_set_padding_left_113(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_padding_left")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::set_padding_left(float left)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_padding_left)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_padding_left(const LUIBaseElement self, float left)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_padding_left_113_comment =
  "C++ Interface:\n"
  "set_padding_left(const LUIBaseElement self, float left)\n"
  "\n"
  "/**\n"
  " * @brief Sets the left-padding\n"
  " * @details This sets only the left-padding, see LUIBaseElement::set_padding()\n"
  " *\n"
  " * @param left padding to the left\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_padding_left_113_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float LUIBaseElement::get_padding_top(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_padding_top_114(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline float LUIBaseElement::get_padding_top(void) const
  float return_value = ((*(const LUIBaseElement*)local_this).get_padding_top)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_padding_top_114_comment =
  "C++ Interface:\n"
  "get_padding_top(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the padding to the top\n"
  " * @details This returns the padding to the top\n"
  " * @return padding to the top\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_padding_top_114_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float LUIBaseElement::get_padding_right(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_padding_right_115(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline float LUIBaseElement::get_padding_right(void) const
  float return_value = ((*(const LUIBaseElement*)local_this).get_padding_right)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_padding_right_115_comment =
  "C++ Interface:\n"
  "get_padding_right(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the padding to the right\n"
  " * @details This returns the padding to the right\n"
  " * @return padding to the right\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_padding_right_115_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float LUIBaseElement::get_padding_bottom(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_padding_bottom_116(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline float LUIBaseElement::get_padding_bottom(void) const
  float return_value = ((*(const LUIBaseElement*)local_this).get_padding_bottom)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_padding_bottom_116_comment =
  "C++ Interface:\n"
  "get_padding_bottom(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the padding to the bottom\n"
  " * @details This returns the padding to the bottom\n"
  " * @return padding to the bottom\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_padding_bottom_116_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float LUIBaseElement::get_padding_left(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_padding_left_117(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline float LUIBaseElement::get_padding_left(void) const
  float return_value = ((*(const LUIBaseElement*)local_this).get_padding_left)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_padding_left_117_comment =
  "C++ Interface:\n"
  "get_padding_left(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the padding to the left\n"
  " * @details This returns the padding to the left\n"
  " * @return padding to the left\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_padding_left_117_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LUIBounds &LUIBaseElement::get_padding(void)
 * inline LUIBounds const &LUIBaseElement::get_padding(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_padding_118(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  if (!DtoolInstance_IS_CONST(self)) {
    // -2 inline LUIBounds &LUIBaseElement::get_padding(void)
    LUIBounds *return_value = &(((*local_this).get_padding)());
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LUIBounds, false, false);
  }

  {
    // -2 inline LUIBounds const &LUIBaseElement::get_padding(void) const
    LUIBounds const *return_value = &(((*(const LUIBaseElement*)local_this).get_padding)());
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LUIBounds, false, true);
  }

  // No coercion possible: inline LUIBounds &LUIBaseElement::get_padding(void)
  // No coercion possible: inline LUIBounds const &LUIBaseElement::get_padding(void) const
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_padding_118_comment =
  "C++ Interface:\n"
  "get_padding(const LUIBaseElement self)\n"
  "get_padding(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the padding of the element.\n"
  " * @details This returns the padding of the element. This method returns a non-const\n"
  " *   reference, thus .get_padding().set_top(123) is perfectly fine. This is mainly\n"
  " *   to support property chaining in python, so the user can do .padding.left = 5\n"
  " * @return Handle to the padding bounds\n"
  " */\n"
  "\n"
  "/**\n"
  " * @brief Returns the padding of the element\n"
  " * @details This returns the padding of the element, as const-version, so the bounds\n"
  " *   are read-only.\n"
  " * @return Readonly handle to the padding bounds\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_padding_118_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_size(LVector2 const &size)
 * inline void LUIBaseElement::set_size(float width, float height)
 * inline void LUIBaseElement::set_size(float width, std::string const &height)
 * inline void LUIBaseElement::set_size(std::string const &width, float height)
 * inline void LUIBaseElement::set_size(std::string const &width, std::string const &height)
 */
static PyObject *Dtool_LUIBaseElement_set_size_119(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_size")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "size")) {
        // 1-inline void LUIBaseElement::set_size(LVector2 const &size)
        LVector2f arg_local;
        LVector2 const *arg_this = Dtool_Coerce_LVector2f(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "LUIBaseElement.set_size", "LVector2f");
        }
        ((*local_this).set_size)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      {
        // -2 inline void LUIBaseElement::set_size(std::string const &width, std::string const &height)
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        const char *param2_str = nullptr;
        Py_ssize_t param2_len;
        static const char *keyword_list[] = {"width", "height", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:set_size", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
          ((*local_this).set_size)(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
          return Dtool_Return_None();
        }
        PyErr_Clear();
      }

      {
        // -2 inline void LUIBaseElement::set_size(std::string const &width, float height)
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        float param2;
        static const char *keyword_list[] = {"width", "height", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#f:set_size", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
          ((*local_this).set_size)(std::string(param1_str, param1_len), (float)param2);
          return Dtool_Return_None();
        }
        PyErr_Clear();
      }

      {
        // -2 inline void LUIBaseElement::set_size(float width, std::string const &height)
        float param1;
        const char *param2_str = nullptr;
        Py_ssize_t param2_len;
        static const char *keyword_list[] = {"width", "height", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "fs#:set_size", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
          ((*local_this).set_size)((float)param1, std::string(param2_str, param2_len));
          return Dtool_Return_None();
        }
        PyErr_Clear();
      }

      {
        // -2 inline void LUIBaseElement::set_size(float width, float height)
        float param1;
        float param2;
        static const char *keyword_list[] = {"width", "height", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:set_size", (char **)keyword_list, &param1, &param2)) {
          ((*local_this).set_size)((float)param1, (float)param2);
          return Dtool_Return_None();
        }
        PyErr_Clear();
      }

      // No coercion possible: inline void LUIBaseElement::set_size(std::string const &width, std::string const &height)
      // No coercion possible: inline void LUIBaseElement::set_size(std::string const &width, float height)
      // No coercion possible: inline void LUIBaseElement::set_size(float width, std::string const &height)
      // No coercion possible: inline void LUIBaseElement::set_size(float width, float height)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_size() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_size(const LUIBaseElement self, const LVector2f size)\n"
      "set_size(const LUIBaseElement self, str width, str height)\n"
      "set_size(const LUIBaseElement self, str width, float height)\n"
      "set_size(const LUIBaseElement self, float width, str height)\n"
      "set_size(const LUIBaseElement self, float width, float height)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_size_119_comment =
  "C++ Interface:\n"
  "set_size(const LUIBaseElement self, const LVector2f size)\n"
  "set_size(const LUIBaseElement self, str width, str height)\n"
  "set_size(const LUIBaseElement self, str width, float height)\n"
  "set_size(const LUIBaseElement self, float width, str height)\n"
  "set_size(const LUIBaseElement self, float width, float height)\n"
  "\n"
  "// Size\n"
  "\n"
  "// Size\n"
  "\n"
  "/**\n"
  " * @brief Sets the size of the element\n"
  " * @details This sets the size of the element. Size can be either floats, determining\n"
  " *  the size in pixels, or valid terms for a LUIExpression, e.g. \"23%\".\n"
  " *\n"
  " * @param size width and height of the element\n"
  " */\n"
  "\n"
  "/**\n"
  " * @brief Sets the size of the element\n"
  " * @details This sets the size of the element. Size can be either floats, determining\n"
  " *  the size in pixels, or valid terms for a LUIExpression, e.g. \"23%\".\n"
  " *\n"
  " * @param width width of the element\n"
  " * @param height height of the element\n"
  " */\n"
  "\n"
  "/**\n"
  " * @brief Sets the size of the element\n"
  " * @details This sets the size of the element. Size can be either floats, determining\n"
  " *  the size in pixels, or valid terms for a LUIExpression, e.g. \"23%\".\n"
  " *\n"
  " * @param width width of the element\n"
  " * @param height height of the element\n"
  " */\n"
  "\n"
  "/**\n"
  " * @brief Sets the size of the element\n"
  " * @details This sets the size of the element. Size can be either floats, determining\n"
  " *  the size in pixels, or valid terms for a LUIExpression, e.g. \"23%\".\n"
  " *\n"
  " * @param width width of the element\n"
  " * @param height height of the element\n"
  " */\n"
  "\n"
  "/**\n"
  " * @brief Sets the size of the element\n"
  " * @details This sets the size of the element. Size can be either floats, determining\n"
  " *  the size in pixels, or valid terms for a LUIExpression, e.g. \"23%\".\n"
  " *\n"
  " * @param width width of the element\n"
  " * @param height height of the element\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_size_119_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_width(float width)
 * inline void LUIBaseElement::set_width(std::string const &width)
 */
static PyObject *Dtool_LUIBaseElement_set_width_120(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_width")) {
    return nullptr;
  }
  {
    // -2 inline void LUIBaseElement::set_width(std::string const &width)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      ((*local_this).set_width)(std::string(param1_str, param1_len));
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  {
    // -2 inline void LUIBaseElement::set_width(float width)
    if (PyNumber_Check(arg)) {
      ((*local_this).set_width)((float)PyFloat_AsDouble(arg));
      return Dtool_Return_None();
    }
  }

  // No coercion possible: inline void LUIBaseElement::set_width(std::string const &width)
  // No coercion possible: inline void LUIBaseElement::set_width(float width)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_width(const LUIBaseElement self, str width)\n"
      "set_width(const LUIBaseElement self, float width)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_width_120_comment =
  "C++ Interface:\n"
  "set_width(const LUIBaseElement self, str width)\n"
  "set_width(const LUIBaseElement self, float width)\n"
  "\n"
  "/**\n"
  " * @brief Sets the width of the element\n"
  " * @details This sets the width of the element, width can either be a float\n"
  " *   determining the size in pixels, or a valid term for a LUIExpression, e.g. \"23%\".\n"
  " *\n"
  " * @param width Width of the element\n"
  " */\n"
  "\n"
  "/**\n"
  " * @brief Sets the width of the element\n"
  " * @details This sets the width of the element, width can either be a float\n"
  " *   determining the size in pixels, or a valid term for a LUIExpression, e.g. \"23%\".\n"
  " *\n"
  " * @param width Width of the element\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_width_120_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_height(float height)
 * inline void LUIBaseElement::set_height(std::string const &height)
 */
static PyObject *Dtool_LUIBaseElement_set_height_121(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_height")) {
    return nullptr;
  }
  {
    // -2 inline void LUIBaseElement::set_height(std::string const &height)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      ((*local_this).set_height)(std::string(param1_str, param1_len));
      return Dtool_Return_None();
    }
    PyErr_Clear();
  }

  {
    // -2 inline void LUIBaseElement::set_height(float height)
    if (PyNumber_Check(arg)) {
      ((*local_this).set_height)((float)PyFloat_AsDouble(arg));
      return Dtool_Return_None();
    }
  }

  // No coercion possible: inline void LUIBaseElement::set_height(std::string const &height)
  // No coercion possible: inline void LUIBaseElement::set_height(float height)
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_height(const LUIBaseElement self, str height)\n"
      "set_height(const LUIBaseElement self, float height)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_height_121_comment =
  "C++ Interface:\n"
  "set_height(const LUIBaseElement self, str height)\n"
  "set_height(const LUIBaseElement self, float height)\n"
  "\n"
  "/**\n"
  " * @brief Sets the height of the element\n"
  " * @details This sets the height of the element, height can either be a float\n"
  " *   determining the size in pixels, or a valid term for a LUIExpression, e.g. \"23%\".\n"
  " *\n"
  " * @param height Height of the element\n"
  " */\n"
  "\n"
  "/**\n"
  " * @brief Sets the height of the element\n"
  " * @details This sets the height of the element, height can either be a float\n"
  " *   determining the size in pixels, or a valid term for a LUIExpression, e.g. \"23%\".\n"
  " *\n"
  " * @param height Height of the element\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_height_121_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float LUIBaseElement::get_width(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_width_122(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline float LUIBaseElement::get_width(void) const
  float return_value = ((*(const LUIBaseElement*)local_this).get_width)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_width_122_comment =
  "C++ Interface:\n"
  "get_width(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the width of the element\n"
  " * @details This returns an approximated width of the element. In case a fixed\n"
  " *   size was set on the element, it returns those. Otherwise it approximates\n"
  " *   the width using the last-frame width.\n"
  " * @return Approximated width\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_width_122_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float LUIBaseElement::get_height(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_height_123(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline float LUIBaseElement::get_height(void) const
  float return_value = ((*(const LUIBaseElement*)local_this).get_height)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_height_123_comment =
  "C++ Interface:\n"
  "get_height(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the height of the element\n"
  " * @details This returns an approximated height of the element. In case a fixed\n"
  " *   size was set on the element, it returns those. Otherwise it approximates\n"
  " *   the height using the last-frame height.\n"
  " * @return Approximated width\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_height_123_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::clear_width(void)
 */
static PyObject *Dtool_LUIBaseElement_clear_width_124(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.clear_width")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::clear_width(void)
  ((*local_this).clear_width)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_clear_width_124_comment =
  "C++ Interface:\n"
  "clear_width(const LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Clears the elements width\n"
  " * @details This clears the elements width expression, clearing anything set\n"
  " *   with set_width() before.\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_clear_width_124_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::clear_height(void)
 */
static PyObject *Dtool_LUIBaseElement_clear_height_125(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.clear_height")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::clear_height(void)
  ((*local_this).clear_height)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_clear_height_125_comment =
  "C++ Interface:\n"
  "clear_height(const LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Clears the elements height\n"
  " * @details This clears the elements height expression, clearing anything set\n"
  " *   with set_height() before.\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_clear_height_125_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::clear_size(void)
 */
static PyObject *Dtool_LUIBaseElement_clear_size_126(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.clear_size")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::clear_size(void)
  ((*local_this).clear_size)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_clear_size_126_comment =
  "C++ Interface:\n"
  "clear_size(const LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Clears the elements size\n"
  " * @details This clears the elements size, calling clear_width() and clear_height().\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_clear_size_126_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LUIBaseElement::has_width(void) const
 */
static PyObject *Dtool_LUIBaseElement_has_width_127(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline bool LUIBaseElement::has_width(void) const
  bool return_value = ((*(const LUIBaseElement*)local_this).has_width)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_has_width_127_comment =
  "C++ Interface:\n"
  "has_width(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns whether the element has a width expression\n"
  " * @details This checks whether there was a width set on the element, either\n"
  " *   a fixed width in pixels, or a percentage width.\n"
  " * @return true if the element has a width assigned, false otherwise\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_has_width_127_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LUIBaseElement::has_height(void) const
 */
static PyObject *Dtool_LUIBaseElement_has_height_128(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline bool LUIBaseElement::has_height(void) const
  bool return_value = ((*(const LUIBaseElement*)local_this).has_height)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_has_height_128_comment =
  "C++ Interface:\n"
  "has_height(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns whether the element has a height expression\n"
  " * @details This checks whether there was a height set on the element, either\n"
  " *   a fixed height in pixels, or a percentage height\n"
  " * @return true if the element has a height assigned, false otherwise\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_has_height_128_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LUIBaseElement::has_size(void) const
 */
static PyObject *Dtool_LUIBaseElement_has_size_129(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline bool LUIBaseElement::has_size(void) const
  bool return_value = ((*(const LUIBaseElement*)local_this).has_size)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_has_size_129_comment =
  "C++ Interface:\n"
  "has_size(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns whether the element has a size assigned\n"
  " * @details This returns whether has_width() and has_height() are both true.\n"
  " * @return True if the element has a size for both dimensions.\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_has_size_129_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector2 LUIBaseElement::get_size(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_size_130(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline LVector2 LUIBaseElement::get_size(void) const
  LVector2 *return_value = new LVector2(((*(const LUIBaseElement*)local_this).get_size)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_size_130_comment =
  "C++ Interface:\n"
  "get_size(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the size of the element\n"
  " * @details This returns an approximated size of the element. In case a fixed\n"
  " *   size was set on the element, it returns those. Otherwise it approximates\n"
  " *   the size using the last-frame size.\n"
  " * @return Approximated width\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_size_130_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_visible(bool visible)
 */
static PyObject *Dtool_LUIBaseElement_set_visible_131(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_visible")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::set_visible(bool visible)
  ((*local_this).set_visible)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_visible(const LUIBaseElement self, bool visible)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_visible_131_comment =
  "C++ Interface:\n"
  "set_visible(const LUIBaseElement self, bool visible)\n"
  "\n"
  "// Visible\n"
  "\n"
  "// Visible\n"
  "\n"
  "/**\n"
  " * @brief Sets whether the element is visible\n"
  " * @details This sets the element visible. If visible is set to false, the element\n"
  " *   will not be rendered anymore. If visible is set to true, the element\n"
  " *   will be shown.\n"
  " *\n"
  " *   If any of the objects parents is hidden, this method has no effect, and the\n"
  " *   element will always be hidden,\n"
  " *\n"
  " * @param visible Whether to render the element\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_visible_131_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LUIBaseElement::is_visible(void) const
 */
static PyObject *Dtool_LUIBaseElement_is_visible_132(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline bool LUIBaseElement::is_visible(void) const
  bool return_value = ((*(const LUIBaseElement*)local_this).is_visible)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_is_visible_132_comment =
  "C++ Interface:\n"
  "is_visible(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns whether the element is explicitly hidden or shown.\n"
  " * @details This returns the value previously set by set_visible(). It does\n"
  " *   *not* take into account whether any of the parents of the object is visible\n"
  " *   or not, so you cannot use this to determine whether the element was actually\n"
  " *   rendered or not.\n"
  " * @return Whether the element was explicitly hidden / shown\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_is_visible_132_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::hide(void)
 */
static PyObject *Dtool_LUIBaseElement_hide_133(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.hide")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::hide(void)
  ((*local_this).hide)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_hide_133_comment =
  "C++ Interface:\n"
  "hide(const LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Hides the element\n"
  " * @details This is an alias for set_visible(false)\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_hide_133_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::show(void)
 */
static PyObject *Dtool_LUIBaseElement_show_134(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.show")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::show(void)
  ((*local_this).show)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_show_134_comment =
  "C++ Interface:\n"
  "show(const LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Shows the element\n"
  " * @details This is an alias for set_visible(true)\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_show_134_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_solid(bool solid)
 */
static PyObject *Dtool_LUIBaseElement_set_solid_135(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_solid")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::set_solid(bool solid)
  ((*local_this).set_solid)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_solid(const LUIBaseElement self, bool solid)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_solid_135_comment =
  "C++ Interface:\n"
  "set_solid(const LUIBaseElement self, bool solid)\n"
  "\n"
  "// Solid\n"
  "\n"
  "// Solid";
#else
static const char *Dtool_LUIBaseElement_set_solid_135_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LUIBaseElement::get_solid(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_solid_136(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline bool LUIBaseElement::get_solid(void) const
  bool return_value = ((*(const LUIBaseElement*)local_this).get_solid)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_solid_136_comment =
  "C++ Interface:\n"
  "get_solid(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns whether element is solid\n"
  " * @details This returns the value previously set with set_solid(). See\n"
  " *   LUIBaseElement::set_solid() for further information.\n"
  " * @return Solidness of the element\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_solid_136_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LUIBaseElement::set_z_offset(float z_offset)
 */
static PyObject *Dtool_LUIBaseElement_set_z_offset_137(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_z_offset")) {
    return nullptr;
  }
  // 1-void LUIBaseElement::set_z_offset(float z_offset)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_z_offset)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_z_offset(const LUIBaseElement self, float z_offset)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_z_offset_137_comment =
  "C++ Interface:\n"
  "set_z_offset(const LUIBaseElement self, float z_offset)\n"
  "\n"
  "// Z-Index\n"
  "\n"
  "// Z-Index";
#else
static const char *Dtool_LUIBaseElement_set_z_offset_137_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float LUIBaseElement::get_z_offset(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_z_offset_138(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline float LUIBaseElement::get_z_offset(void) const
  float return_value = ((*(const LUIBaseElement*)local_this).get_z_offset)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_z_offset_138_comment =
  "C++ Interface:\n"
  "get_z_offset(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the z offset of the element\n"
  " * @details This returns the z offset previously set with set_z_offset()\n"
  " * @return z offset of the element\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_z_offset_138_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LUIBaseElement::has_focus(void) const
 */
static PyObject *Dtool_LUIBaseElement_has_focus_139(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline bool LUIBaseElement::has_focus(void) const
  bool return_value = ((*(const LUIBaseElement*)local_this).has_focus)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_has_focus_139_comment =
  "C++ Interface:\n"
  "has_focus(LUIBaseElement self)\n"
  "\n"
  "// Focus\n"
  "\n"
  "// Focus\n"
  "\n"
  "/**\n"
  " * @brief Returns whether the element is focused\n"
  " * @details This method returns whether the element currently is focused.\n"
  " *   This is usually true after a call to request_focus()\n"
  " * @return [description]\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_has_focus_139_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool LUIBaseElement::request_focus(void)
 */
static PyObject *Dtool_LUIBaseElement_request_focus_140(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.request_focus")) {
    return nullptr;
  }
  // 1-bool LUIBaseElement::request_focus(void)
  bool return_value = ((*local_this).request_focus)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_request_focus_140_comment =
  "C++ Interface:\n"
  "request_focus(const LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Attempts to request focus\n"
  " * @details This tries to request focus for the current element. If the element\n"
  " *   recieved focus successfully, true is returned, false otherwise.\n"
  " * @return Whether the element is focused\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_request_focus_140_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LUIBaseElement::blur(void)
 */
static PyObject *Dtool_LUIBaseElement_blur_141(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.blur")) {
    return nullptr;
  }
  // 1-void LUIBaseElement::blur(void)
  ((*local_this).blur)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_blur_141_comment =
  "C++ Interface:\n"
  "blur(const LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Gives focus away\n"
  " * @details This makes the element no longer focused. This always succeeds.\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_blur_141_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LUIBaseElement::has_parent(void) const
 */
static PyObject *Dtool_LUIBaseElement_has_parent_142(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline bool LUIBaseElement::has_parent(void) const
  bool return_value = ((*(const LUIBaseElement*)local_this).has_parent)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_has_parent_142_comment =
  "C++ Interface:\n"
  "has_parent(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns whether the element has a parent\n"
  " * @details This method returns whether the element is currently parented to anything\n"
  " * @return true if a parent is set, false otherwise\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_has_parent_142_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LUIBaseElement::clear_parent(void)
 */
static PyObject *Dtool_LUIBaseElement_clear_parent_143(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.clear_parent")) {
    return nullptr;
  }
  // 1-void LUIBaseElement::clear_parent(void)
  ((*local_this).clear_parent)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_clear_parent_143_comment =
  "C++ Interface:\n"
  "clear_parent(const LUIBaseElement self)\n";
#else
static const char *Dtool_LUIBaseElement_clear_parent_143_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LUIBaseElement::set_parent(LUIObject *parent)
 */
static PyObject *Dtool_LUIBaseElement_set_parent_144(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_parent")) {
    return nullptr;
  }
  // 1-void LUIBaseElement::set_parent(LUIObject *parent)
  PT(LUIObject) arg_this;
  if (!Dtool_Coerce_LUIObject(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LUIBaseElement.set_parent", "LUIObject");
  }
  ((*local_this).set_parent)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_parent(const LUIBaseElement self, LUIObject parent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_parent_144_comment =
  "C++ Interface:\n"
  "set_parent(const LUIBaseElement self, LUIObject parent)\n"
  "\n"
  "/**\n"
  " * @brief Sets the elements parent\n"
  " * @details This sets the parent of the element. This is equal to calling\n"
  " *   parent.add_child(self). If the element currently has a parent, the element\n"
  " *   is first removed from the old parent.\n"
  " *\n"
  " * @param parent New parent of the element.\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_parent_144_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LUIObject *LUIBaseElement::get_parent(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_parent_145(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline LUIObject *LUIBaseElement::get_parent(void) const
  LUIObject *return_value = ((*(const LUIBaseElement*)local_this).get_parent)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_LUIObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_parent_145_comment =
  "C++ Interface:\n"
  "get_parent(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns a handle to the parent\n"
  " * @details This returns a handle to the elements parent, or nullptr if no parent\n"
  " *   is present.\n"
  " * @return Handle to the parent\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_parent_145_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual inline bool LUIBaseElement::intersects(float x, float y) const
 */
static PyObject *Dtool_LUIBaseElement_intersects_146(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-virtual inline bool LUIBaseElement::intersects(float x, float y) const
  float param1;
  float param2;
  static const char *keyword_list[] = {"x", "y", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:intersects", (char **)keyword_list, &param1, &param2)) {
    bool return_value = ((*(const LUIBaseElement*)local_this).intersects)((float)param1, (float)param2);
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "intersects(LUIBaseElement self, float x, float y)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_intersects_146_comment =
  "C++ Interface:\n"
  "intersects(LUIBaseElement self, float x, float y)\n"
  "\n"
  "/**\n"
  " * @brief Checks if the element intersects with a point\n"
  " * @details This checks if the element intersects with a given *absolute*\n"
  " *   coordinate point. This is only valid after traversing the tree, since otherwise\n"
  " *   the absolute position is not known.\n"
  " *\n"
  " * @param x absolute x-coordinate in pixels\n"
  " * @param y absolute y-coordinate in pixels\n"
  " *\n"
  " * @return true if the coordinate intersects with the element, false otherwise\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_intersects_146_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::clear_clip_bounds(void)
 */
static PyObject *Dtool_LUIBaseElement_clear_clip_bounds_147(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.clear_clip_bounds")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::clear_clip_bounds(void)
  ((*local_this).clear_clip_bounds)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_clear_clip_bounds_147_comment =
  "C++ Interface:\n"
  "clear_clip_bounds(const LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Clears the clip bounds\n"
  " * @details This clears any clip bounds previously set with set_clip_bounds(),\n"
  " *   and thus makes the element not clip anymore.\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_clear_clip_bounds_147_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_clip_bounds(LUIBounds const &bounds)
 * inline void LUIBaseElement::set_clip_bounds(float top, float right, float bottom, float left)
 */
static PyObject *Dtool_LUIBaseElement_set_clip_bounds_148(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_clip_bounds")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "bounds")) {
        // 1-inline void LUIBaseElement::set_clip_bounds(LUIBounds const &bounds)
        LUIBounds arg_local;
        LUIBounds const *arg_this = Dtool_Coerce_LUIBounds(arg, arg_local);
        if (!(arg_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "LUIBaseElement.set_clip_bounds", "LUIBounds");
        }
        ((*local_this).set_clip_bounds)(*arg_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void LUIBaseElement::set_clip_bounds(float top, float right, float bottom, float left)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"top", "right", "bottom", "left", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_clip_bounds", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).set_clip_bounds)((float)param1, (float)param2, (float)param3, (float)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_clip_bounds() takes 2 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_clip_bounds(const LUIBaseElement self, const LUIBounds bounds)\n"
      "set_clip_bounds(const LUIBaseElement self, float top, float right, float bottom, float left)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_clip_bounds_148_comment =
  "C++ Interface:\n"
  "set_clip_bounds(const LUIBaseElement self, const LUIBounds bounds)\n"
  "set_clip_bounds(const LUIBaseElement self, float top, float right, float bottom, float left)\n"
  "\n"
  "/**\n"
  " * @brief Sets the elements clip bounds\n"
  " * @details This sets the elements clip bounds. This is equal to setting\n"
  " *   'overflow: hidden' in CSS. In case the clip bounds are (0, 0, 0, 0),\n"
  " *   the clipping will happen at the sides of the element. The bounds specify\n"
  " *   the distance of the clipping rect from the sides.\n"
  " *\n"
  " * @param bounds Distance of the clipping rect from the sides\n"
  " */\n"
  "\n"
  "/**\n"
  " * @brief Sets the elements clip bounds\n"
  " * @details This sets the elements clip bounds. This is equal to setting\n"
  " *   'overflow: hidden' in CSS. In case the clip bounds are (0, 0, 0, 0),\n"
  " *   the clipping will happen at the sides of the element. The bounds specify\n"
  " *   the distance of the clipping rect from the sides.\n"
  " *\n"
  " * @param top Distance of the clipping rect from the top\n"
  " * @param right Distance of the clipping rect from the right\n"
  " * @param bottom Distance of the clipping rect from the bottom\n"
  " * @param left Distance of the clipping rect from the left\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_clip_bounds_148_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LUIBounds const &LUIBaseElement::get_clip_bounds(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_clip_bounds_149(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline LUIBounds const &LUIBaseElement::get_clip_bounds(void) const
  LUIBounds const *return_value = &(((*(const LUIBaseElement*)local_this).get_clip_bounds)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LUIBounds, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_clip_bounds_149_comment =
  "C++ Interface:\n"
  "get_clip_bounds(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the clip bounds\n"
  " * @details This returns the clip bounds. In case no clip bounds were set, this\n"
  " *   returns (0, 0, 0, 0).\n"
  " * @return Current clip bounds\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_clip_bounds_149_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LUIRect const &LUIBaseElement::get_abs_clip_bounds(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_abs_clip_bounds_150(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline LUIRect const &LUIBaseElement::get_abs_clip_bounds(void) const
  LUIRect const *return_value = &(((*(const LUIBaseElement*)local_this).get_abs_clip_bounds)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LUIRect, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_abs_clip_bounds_150_comment =
  "C++ Interface:\n"
  "get_abs_clip_bounds(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the clip rect\n"
  " * @details This returns the clip region, in absolute coordinate space. This is only\n"
  " *   valid after a frame has been rendered.\n"
  " * @return Absolute clip rectangle\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_abs_clip_bounds_150_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LUIBaseElement::is_topmost(void) const
 */
static PyObject *Dtool_LUIBaseElement_is_topmost_151(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline bool LUIBaseElement::is_topmost(void) const
  bool return_value = ((*(const LUIBaseElement*)local_this).is_topmost)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_is_topmost_151_comment =
  "C++ Interface:\n"
  "is_topmost(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns whether the element is topmost\n"
  " * @details This returns whether the element is set to topmost, and thus gets\n"
  " *   rendered in front of all objects. This does not check if any parent of the\n"
  " *   object is topmost.\n"
  " *\n"
  " * @return True if the element is explicitly set to topmost\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_is_topmost_151_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_topmost(bool topmost)
 */
static PyObject *Dtool_LUIBaseElement_set_topmost_152(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_topmost")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::set_topmost(bool topmost)
  ((*local_this).set_topmost)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_topmost(const LUIBaseElement self, bool topmost)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_topmost_152_comment =
  "C++ Interface:\n"
  "set_topmost(const LUIBaseElement self, bool topmost)\n"
  "\n"
  "/**\n"
  " * @brief Sets the element to render topmost\n"
  " * @details This makes the element render in top of all other elements. This also\n"
  " *   affects the children of the element in case it has some. Topmost elements are\n"
  " *   rendered in a seperate render pass above all elements. They also recieve\n"
  " *   events before regular events.\n"
  " *\n"
  " *   This does affect all children elements, too. Setting this too false will have\n"
  " *   no effect if any parent of the element is set to topmost.\n"
  " *\n"
  " * @param topmost Whether to render the element topmost\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_topmost_152_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LVector2 LUIBaseElement::get_relative_pos(LPoint2 const &pos) const
 */
static PyObject *Dtool_LUIBaseElement_get_relative_pos_153(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline LVector2 LUIBaseElement::get_relative_pos(LPoint2 const &pos) const
  LPoint2f arg_local;
  LPoint2 const *arg_this = Dtool_Coerce_LPoint2f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LUIBaseElement.get_relative_pos", "LPoint2f");
  }
  LVector2 *return_value = new LVector2(((*(const LUIBaseElement*)local_this).get_relative_pos)(*arg_this));
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_relative_pos(LUIBaseElement self, const LPoint2f pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_relative_pos_153_comment =
  "C++ Interface:\n"
  "get_relative_pos(LUIBaseElement self, const LPoint2f pos)\n"
  "\n"
  "/**\n"
  " * @brief Returns the relative position of an absolute point\n"
  " * @details This returns the position of a point relative to this element. This is\n"
  " *   only valid after a frame has been rendered, since it depends on the absolute\n"
  " *   position. The relative position is computed by pos - element_pos.\n"
  " *\n"
  " * @param pos Absolute point position\n"
  " * @return Vector to that point, relative to the element\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_relative_pos_153_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseElement::set_debug_name(std::string const &debug_name)
 */
static PyObject *Dtool_LUIBaseElement_set_debug_name_154(PyObject *self, PyObject *arg) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.set_debug_name")) {
    return nullptr;
  }
  // 1-inline void LUIBaseElement::set_debug_name(std::string const &debug_name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_debug_name)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_debug_name(const LUIBaseElement self, str debug_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_set_debug_name_154_comment =
  "C++ Interface:\n"
  "set_debug_name(const LUIBaseElement self, str debug_name)\n"
  "\n"
  "/**\n"
  " * @brief Sets the debugging name\n"
  " * @details This sets the debug name, which is shown when calling\n"
  " *   LUIBaseElement::ls(). It usually is set to the class name, but can be overriden\n"
  " *   to provide additional information.\n"
  " *\n"
  " * @param debug_name Debug-Name of the object.\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_set_debug_name_154_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::string const &LUIBaseElement::get_debug_name(void) const
 */
static PyObject *Dtool_LUIBaseElement_get_debug_name_155(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseElement)) {
    return nullptr;
  }
  // 1-inline std::string const &LUIBaseElement::get_debug_name(void) const
  std::string const &return_value = ((*(const LUIBaseElement*)local_this).get_debug_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_debug_name_155_comment =
  "C++ Interface:\n"
  "get_debug_name(LUIBaseElement self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the debugging name\n"
  " * @details This returns the debug name previously set with set_debug_name()\n"
  " * \n"
  " * @return The debug name\n"
  " */";
#else
static const char *Dtool_LUIBaseElement_get_debug_name_155_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LUIBaseElement::get_class_type(void)
 */
static PyObject *Dtool_LUIBaseElement_get_class_type_211(PyObject *, PyObject *) {
  // 1-static TypeHandle LUIBaseElement::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LUIBaseElement::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_get_class_type_211_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LUIBaseElement_get_class_type_211_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * TypedReferenceCount *LUIBaseElement::upcast_to_TypedReferenceCount(void)
 */
static PyObject *Dtool_LUIBaseElement_upcast_to_TypedReferenceCount_62(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.upcast_to_TypedReferenceCount")) {
    return nullptr;
  }
  // 1-TypedReferenceCount *LUIBaseElement::upcast_to_TypedReferenceCount(void)
  TypedReferenceCount *return_value = (TypedReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_TypedReferenceCount, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_upcast_to_TypedReferenceCount_62_comment =
  "C++ Interface:\n"
  "upcast_to_TypedReferenceCount(const LUIBaseElement self)\n"
  "\n"
  "upcast from LUIBaseElement to TypedReferenceCount";
#else
static const char *Dtool_LUIBaseElement_upcast_to_TypedReferenceCount_62_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LUIColorable *LUIBaseElement::upcast_to_LUIColorable(void)
 */
static PyObject *Dtool_LUIBaseElement_upcast_to_LUIColorable_64(PyObject *self, PyObject *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.upcast_to_LUIColorable")) {
    return nullptr;
  }
  // 1-LUIColorable *LUIBaseElement::upcast_to_LUIColorable(void)
  LUIColorable *return_value = (LUIColorable *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LUIColorable, false, false);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseElement_upcast_to_LUIColorable_64_comment =
  "C++ Interface:\n"
  "upcast_to_LUIColorable(const LUIBaseElement self)\n"
  "\n"
  "upcast from LUIBaseElement to LUIColorable";
#else
static const char *Dtool_LUIBaseElement_upcast_to_LUIColorable_64_comment = nullptr;
#endif

static PyObject *Dtool_LUIBaseElement_name_Getter(PyObject *self, void *) {
  const LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBaseElement, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &LUIBaseElement::get_name(void) const
  std::string const &return_value = ((*(const LUIBaseElement*)local_this).get_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIBaseElement_name_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.name")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete name attribute");
    return -1;
  }
  // 1-inline void LUIBaseElement::set_name(std::string const &name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_name)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_name(const LUIBaseElement self, str name)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIBaseElement_debug_name_Getter(PyObject *self, void *) {
  const LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBaseElement, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string const &LUIBaseElement::get_debug_name(void) const
  std::string const &return_value = ((*(const LUIBaseElement*)local_this).get_debug_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIBaseElement_debug_name_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.debug_name")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete debug_name attribute");
    return -1;
  }
  // 1-inline void LUIBaseElement::set_debug_name(std::string const &debug_name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_debug_name)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_debug_name(const LUIBaseElement self, str debug_name)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIBaseElement_top_left_Getter(PyObject *self, void *) {
  const LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBaseElement, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPoint2 LUIBaseElement::get_top_left(void) const
  LPoint2 *return_value = new LPoint2(((*(const LUIBaseElement*)local_this).get_top_left)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
}

static int Dtool_LUIBaseElement_top_left_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.top_left")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete top_left attribute");
    return -1;
  }
  // 1-inline void LUIBaseElement::set_top_left(LPoint2 const &pos)
  LPoint2f arg_local;
  LPoint2 const *arg_this = Dtool_Coerce_LPoint2f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "LUIBaseElement.set_top_left", "LPoint2f");
    return -1;
  }
  ((*local_this).set_top_left)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_top_left(const LUIBaseElement self, const LPoint2f pos)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIBaseElement_top_right_Getter(PyObject *self, void *) {
  const LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBaseElement, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPoint2 LUIBaseElement::get_top_right(void) const
  LPoint2 *return_value = new LPoint2(((*(const LUIBaseElement*)local_this).get_top_right)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
}

static int Dtool_LUIBaseElement_top_right_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.top_right")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete top_right attribute");
    return -1;
  }
  // 1-inline void LUIBaseElement::set_top_right(LPoint2 const &pos)
  LPoint2f arg_local;
  LPoint2 const *arg_this = Dtool_Coerce_LPoint2f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "LUIBaseElement.set_top_right", "LPoint2f");
    return -1;
  }
  ((*local_this).set_top_right)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_top_right(const LUIBaseElement self, const LPoint2f pos)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIBaseElement_bottom_left_Getter(PyObject *self, void *) {
  const LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBaseElement, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPoint2 LUIBaseElement::get_bottom_left(void) const
  LPoint2 *return_value = new LPoint2(((*(const LUIBaseElement*)local_this).get_bottom_left)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
}

static int Dtool_LUIBaseElement_bottom_left_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.bottom_left")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete bottom_left attribute");
    return -1;
  }
  // 1-inline void LUIBaseElement::set_bottom_left(LPoint2 const &pos)
  LPoint2f arg_local;
  LPoint2 const *arg_this = Dtool_Coerce_LPoint2f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "LUIBaseElement.set_bottom_left", "LPoint2f");
    return -1;
  }
  ((*local_this).set_bottom_left)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_bottom_left(const LUIBaseElement self, const LPoint2f pos)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIBaseElement_bottom_right_Getter(PyObject *self, void *) {
  const LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBaseElement, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPoint2 LUIBaseElement::get_bottom_right(void) const
  LPoint2 *return_value = new LPoint2(((*(const LUIBaseElement*)local_this).get_bottom_right)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
}

static int Dtool_LUIBaseElement_bottom_right_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.bottom_right")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete bottom_right attribute");
    return -1;
  }
  // 1-inline void LUIBaseElement::set_bottom_right(LPoint2 const &pos)
  LPoint2f arg_local;
  LPoint2 const *arg_this = Dtool_Coerce_LPoint2f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "LUIBaseElement.set_bottom_right", "LPoint2f");
    return -1;
  }
  ((*local_this).set_bottom_right)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_bottom_right(const LUIBaseElement self, const LPoint2f pos)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIBaseElement_pos_Getter(PyObject *self, void *) {
  const LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBaseElement, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPoint2 LUIBaseElement::get_pos(void) const
  LPoint2 *return_value = new LPoint2(((*(const LUIBaseElement*)local_this).get_pos)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
}

static int Dtool_LUIBaseElement_pos_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.pos")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete pos attribute");
    return -1;
  }
  // 1-inline void LUIBaseElement::set_pos(LPoint2 const &pos)
  LPoint2f arg_local;
  LPoint2 const *arg_this = Dtool_Coerce_LPoint2f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "LUIBaseElement.set_pos", "LPoint2f");
    return -1;
  }
  ((*local_this).set_pos)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_pos(const LUIBaseElement self, const LPoint2f pos)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIBaseElement_abs_pos_Getter(PyObject *self, void *) {
  const LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBaseElement, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPoint2 LUIBaseElement::get_abs_pos(void) const
  LPoint2 *return_value = new LPoint2(((*(const LUIBaseElement*)local_this).get_abs_pos)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
}

static PyObject *Dtool_LUIBaseElement_top_Getter(PyObject *self, void *) {
  const LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBaseElement, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline float LUIBaseElement::get_top(void) const
  float return_value = ((*(const LUIBaseElement*)local_this).get_top)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIBaseElement_top_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.top")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete top attribute");
    return -1;
  }
  // 1-inline void LUIBaseElement::set_top(float top)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_top)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_top(const LUIBaseElement self, float top)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIBaseElement_bottom_Getter(PyObject *self, void *) {
  const LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBaseElement, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline float LUIBaseElement::get_bottom(void) const
  float return_value = ((*(const LUIBaseElement*)local_this).get_bottom)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIBaseElement_bottom_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.bottom")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete bottom attribute");
    return -1;
  }
  // 1-inline void LUIBaseElement::set_bottom(float bottom)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_bottom)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_bottom(const LUIBaseElement self, float bottom)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIBaseElement_left_Getter(PyObject *self, void *) {
  const LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBaseElement, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline float LUIBaseElement::get_left(void) const
  float return_value = ((*(const LUIBaseElement*)local_this).get_left)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIBaseElement_left_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.left")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete left attribute");
    return -1;
  }
  // 1-inline void LUIBaseElement::set_left(float left)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_left)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_left(const LUIBaseElement self, float left)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIBaseElement_right_Getter(PyObject *self, void *) {
  const LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBaseElement, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline float LUIBaseElement::get_right(void) const
  float return_value = ((*(const LUIBaseElement*)local_this).get_right)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIBaseElement_right_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.right")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete right attribute");
    return -1;
  }
  // 1-inline void LUIBaseElement::set_right(float right)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_right)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_right(const LUIBaseElement self, float right)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIBaseElement_centered_Getter(PyObject *self, void *) {
  const LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBaseElement, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool LUIBaseElement::is_centered(void) const
  bool return_value = ((*(const LUIBaseElement*)local_this).is_centered)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIBaseElement_centered_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.centered")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete centered attribute");
    return -1;
  }
  // 1-inline void LUIBaseElement::set_centered(bool center_vert, bool center_horiz)
  ((*local_this).set_centered)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_centered(const LUIBaseElement self, bool center_vert)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIBaseElement_center_vertical_Getter(PyObject *self, void *) {
  const LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBaseElement, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool LUIBaseElement::is_vertical_centered(void) const
  bool return_value = ((*(const LUIBaseElement*)local_this).is_vertical_centered)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIBaseElement_center_vertical_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.center_vertical")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete center_vertical attribute");
    return -1;
  }
  // 1-inline void LUIBaseElement::set_center_vertical(bool centered)
  ((*local_this).set_center_vertical)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_center_vertical(const LUIBaseElement self, bool centered)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIBaseElement_center_horizontal_Getter(PyObject *self, void *) {
  const LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBaseElement, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool LUIBaseElement::is_horizontal_centered(void) const
  bool return_value = ((*(const LUIBaseElement*)local_this).is_horizontal_centered)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIBaseElement_center_horizontal_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.center_horizontal")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete center_horizontal attribute");
    return -1;
  }
  // 1-inline void LUIBaseElement::set_center_horizontal(bool centered)
  ((*local_this).set_center_horizontal)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_center_horizontal(const LUIBaseElement self, bool centered)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIBaseElement_margin_Getter(PyObject *self, void *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.margin")) {
    return nullptr;
  }

  // 1-inline LUIBounds &LUIBaseElement::get_margin(void)
  LUIBounds *return_value = &(((*local_this).get_margin)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LUIBounds, false, false);
}

static int Dtool_LUIBaseElement_margin_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.margin")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete margin attribute");
    return -1;
  }
  {
    // -2 inline void LUIBaseElement::set_margin(LVector4 const &margin)
    LVector4 const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVector4f);
    if (arg_this != nullptr) {
      ((*local_this).set_margin)(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }

  {
    // -2 inline void LUIBaseElement::set_margin(float margin)
    if (PyNumber_Check(arg)) {
      ((*local_this).set_margin)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }

  {
    // -2 inline void LUIBaseElement::set_margin(LVector4 const &margin)
    LVector4f arg_local;
    LVector4 const *arg_this = Dtool_Coerce_LVector4f(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).set_margin)(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }

  // No coercion possible: inline void LUIBaseElement::set_margin(float margin)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_margin(const LUIBaseElement self, const LVector4f margin)\n"
      "set_margin(const LUIBaseElement self, float margin)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIBaseElement_padding_Getter(PyObject *self, void *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.padding")) {
    return nullptr;
  }

  // 1-inline LUIBounds &LUIBaseElement::get_padding(void)
  LUIBounds *return_value = &(((*local_this).get_padding)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LUIBounds, false, false);
}

static int Dtool_LUIBaseElement_padding_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.padding")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete padding attribute");
    return -1;
  }
  {
    // -2 inline void LUIBaseElement::set_padding(LVector4 const &padding)
    LVector4 const *arg_this = nullptr;
    DtoolInstance_GetPointer(arg, arg_this, *Dtool_Ptr_LVector4f);
    if (arg_this != nullptr) {
      ((*local_this).set_padding)(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }

  {
    // -2 inline void LUIBaseElement::set_padding(float padding)
    if (PyNumber_Check(arg)) {
      ((*local_this).set_padding)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }

  {
    // -2 inline void LUIBaseElement::set_padding(LVector4 const &padding)
    LVector4f arg_local;
    LVector4 const *arg_this = Dtool_Coerce_LVector4f(arg, arg_local);
    if ((arg_this != nullptr)) {
      ((*local_this).set_padding)(*arg_this);
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }

  // No coercion possible: inline void LUIBaseElement::set_padding(float padding)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_padding(const LUIBaseElement self, const LVector4f padding)\n"
      "set_padding(const LUIBaseElement self, float padding)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIBaseElement_size_Getter(PyObject *self, void *) {
  const LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBaseElement, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_size()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LVector2 LUIBaseElement::get_size(void) const
  LVector2 *return_value = new LVector2(((*(const LUIBaseElement*)local_this).get_size)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
}

static int Dtool_LUIBaseElement_size_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.size")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete size attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_size();
    return 0;
  }
  // 1-inline void LUIBaseElement::set_size(LVector2 const &size)
  LVector2f arg_local;
  LVector2 const *arg_this = Dtool_Coerce_LVector2f(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "LUIBaseElement.set_size", "LVector2f");
    return -1;
  }
  ((*local_this).set_size)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_size(const LUIBaseElement self, const LVector2f size)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIBaseElement_width_Getter(PyObject *self, void *) {
  const LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBaseElement, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_width()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline float LUIBaseElement::get_width(void) const
  float return_value = ((*(const LUIBaseElement*)local_this).get_width)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIBaseElement_width_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.width")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete width attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_width();
    return 0;
  }
  {
    // -2 inline void LUIBaseElement::set_width(std::string const &width)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      ((*local_this).set_width)(std::string(param1_str, param1_len));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
    PyErr_Clear();
  }

  {
    // -2 inline void LUIBaseElement::set_width(float width)
    if (PyNumber_Check(arg)) {
      ((*local_this).set_width)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }

  // No coercion possible: inline void LUIBaseElement::set_width(std::string const &width)
  // No coercion possible: inline void LUIBaseElement::set_width(float width)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_width(const LUIBaseElement self, str width)\n"
      "set_width(const LUIBaseElement self, float width)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIBaseElement_height_Getter(PyObject *self, void *) {
  const LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBaseElement, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_height()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline float LUIBaseElement::get_height(void) const
  float return_value = ((*(const LUIBaseElement*)local_this).get_height)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIBaseElement_height_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.height")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete height attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_height();
    return 0;
  }
  {
    // -2 inline void LUIBaseElement::set_height(std::string const &height)
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      ((*local_this).set_height)(std::string(param1_str, param1_len));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
    PyErr_Clear();
  }

  {
    // -2 inline void LUIBaseElement::set_height(float height)
    if (PyNumber_Check(arg)) {
      ((*local_this).set_height)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
      Notify *notify = Notify::ptr();
      if (UNLIKELY(notify->has_assert_failed())) {
        Dtool_Raise_AssertionError();
        return -1;
      }
#endif
      return 0;
    }
  }

  // No coercion possible: inline void LUIBaseElement::set_height(std::string const &height)
  // No coercion possible: inline void LUIBaseElement::set_height(float height)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_height(const LUIBaseElement self, str height)\n"
      "set_height(const LUIBaseElement self, float height)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIBaseElement_visible_Getter(PyObject *self, void *) {
  const LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBaseElement, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool LUIBaseElement::is_visible(void) const
  bool return_value = ((*(const LUIBaseElement*)local_this).is_visible)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIBaseElement_visible_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.visible")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete visible attribute");
    return -1;
  }
  // 1-inline void LUIBaseElement::set_visible(bool visible)
  ((*local_this).set_visible)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_visible(const LUIBaseElement self, bool visible)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIBaseElement_z_offset_Getter(PyObject *self, void *) {
  const LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBaseElement, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline float LUIBaseElement::get_z_offset(void) const
  float return_value = ((*(const LUIBaseElement*)local_this).get_z_offset)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIBaseElement_z_offset_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.z_offset")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete z_offset attribute");
    return -1;
  }
  // 1-void LUIBaseElement::set_z_offset(float z_offset)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_z_offset)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_z_offset(const LUIBaseElement self, float z_offset)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIBaseElement_focused_Getter(PyObject *self, void *) {
  const LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBaseElement, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool LUIBaseElement::has_focus(void) const
  bool return_value = ((*(const LUIBaseElement*)local_this).has_focus)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_LUIBaseElement_parent_Getter(PyObject *self, void *) {
  const LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBaseElement, (void **)&local_this)) {
    return nullptr;
  }

  if (!local_this->has_parent()) {
    Py_INCREF(Py_None);
    return Py_None;
  }
  // 1-inline LUIObject *LUIBaseElement::get_parent(void) const
  LUIObject *return_value = ((*(const LUIBaseElement*)local_this).get_parent)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_LUIObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_LUIBaseElement_parent_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.parent")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete parent attribute");
    return -1;
  }
  if (arg == Py_None) {
    local_this->clear_parent();
    return 0;
  }
  // 1-void LUIBaseElement::set_parent(LUIObject *parent)
  PT(LUIObject) arg_this;
  if (!Dtool_Coerce_LUIObject(arg, arg_this)) {
    Dtool_Raise_ArgTypeError(arg, 1, "LUIBaseElement.set_parent", "LUIObject");
    return -1;
  }
  ((*local_this).set_parent)(std::move(arg_this));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_parent(const LUIBaseElement self, LUIObject parent)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIBaseElement_clip_bounds_Getter(PyObject *self, void *) {
  const LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBaseElement, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LUIBounds const &LUIBaseElement::get_clip_bounds(void) const
  LUIBounds const *return_value = &(((*(const LUIBaseElement*)local_this).get_clip_bounds)());
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LUIBounds, false, true);
}

static int Dtool_LUIBaseElement_clip_bounds_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.clip_bounds")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete clip_bounds attribute");
    return -1;
  }
  // 1-inline void LUIBaseElement::set_clip_bounds(LUIBounds const &bounds)
  LUIBounds arg_local;
  LUIBounds const *arg_this = Dtool_Coerce_LUIBounds(arg, arg_local);
  if (!(arg_this != nullptr)) {
    Dtool_Raise_ArgTypeError(arg, 1, "LUIBaseElement.set_clip_bounds", "LUIBounds");
    return -1;
  }
  ((*local_this).set_clip_bounds)(*arg_this);
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_clip_bounds(const LUIBaseElement self, const LUIBounds bounds)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIBaseElement_topmost_Getter(PyObject *self, void *) {
  const LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBaseElement, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool LUIBaseElement::is_topmost(void) const
  bool return_value = ((*(const LUIBaseElement*)local_this).is_topmost)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIBaseElement_topmost_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.topmost")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete topmost attribute");
    return -1;
  }
  // 1-inline void LUIBaseElement::set_topmost(bool topmost)
  ((*local_this).set_topmost)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_topmost(const LUIBaseElement self, bool topmost)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIBaseElement_solid_Getter(PyObject *self, void *) {
  const LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBaseElement, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline bool LUIBaseElement::get_solid(void) const
  bool return_value = ((*(const LUIBaseElement*)local_this).get_solid)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIBaseElement_solid_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBaseElement *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseElement, (void **)&local_this, "LUIBaseElement.solid")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete solid attribute");
    return -1;
  }
  // 1-inline void LUIBaseElement::set_solid(bool solid)
  ((*local_this).set_solid)((PyObject_IsTrue(arg) != 0));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_solid(const LUIBaseElement self, bool solid)\n");
  }
  return -1;
}

static int Dtool_Init_LUIBaseElement(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_LUIBaseElement(PyObject *args, CPT(LUIBaseElement) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_LUIBaseElement)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  return false;
}

bool Dtool_Coerce_LUIBaseElement(PyObject *args, PT(LUIBaseElement) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_LUIBaseElement)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_LUIBaseElement(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LUIBaseElement) {
    printf("LUIBaseElement ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LUIBaseElement *local_this = (LUIBaseElement *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LUIBaseElement) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LUIColorable) {
    return (LUIColorable *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LUIBaseElement(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LUIBaseElement) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LUIColorable) {
    LUIColorable* other_this = (LUIColorable*)from_this;
    return (LUIBaseElement*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LUIBaseElement*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LUIBaseElement*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LUIBaseElement*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LUIObject
 */
/**
 * Python function wrapper for:
 * inline PointerTo< LUIElementIterator > LUIObject::get_children(void) const
 */
static PyObject *Dtool_LUIObject_get_children_191(PyObject *self, PyObject *) {
  LUIObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIObject)) {
    return nullptr;
  }
  // 1-inline PointerTo< LUIElementIterator > LUIObject::get_children(void) const
  PointerTo< LUIElementIterator > return_value = ((*(const LUIObject*)local_this).get_children)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  LUIElementIterator *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_LUIElementIterator, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LUIObject_get_children_191_comment =
  "C++ Interface:\n"
  "get_children(LUIObject self)\n";
#else
static const char *Dtool_LUIObject_get_children_191_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< LUIBaseElement > LUIObject::get_child(std::size_t index) const
 */
static PyObject *Dtool_LUIObject_get_child_192(PyObject *self, PyObject *arg) {
  LUIObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIObject)) {
    return nullptr;
  }
  // 1-inline PointerTo< LUIBaseElement > LUIObject::get_child(std::size_t index) const
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    PointerTo< LUIBaseElement > return_value = ((*(const LUIObject*)local_this).get_child)(arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    LUIBaseElement *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    if (return_ptr == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_LUIBaseElement, true, false, return_ptr->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_child(LUIObject self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIObject_get_child_192_comment =
  "C++ Interface:\n"
  "get_child(LUIObject self, int index)\n";
#else
static const char *Dtool_LUIObject_get_child_192_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< LUIBaseElement > LUIObject::add_child(PointerTo< LUIBaseElement > child)
 */
static PyObject *Dtool_LUIObject_add_child_193(PyObject *self, PyObject *arg) {
  LUIObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIObject, (void **)&local_this, "LUIObject.add_child")) {
    return nullptr;
  }
  // 1-inline PointerTo< LUIBaseElement > LUIObject::add_child(PointerTo< LUIBaseElement > child)
  PT(LUIBaseElement) arg_this;
  if (!Dtool_Coerce_LUIBaseElement(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LUIObject.add_child", "LUIBaseElement");
  }
  PointerTo< LUIBaseElement > return_value = ((*local_this).add_child)(std::move(arg_this));
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  LUIBaseElement *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_LUIBaseElement, true, false, return_ptr->as_typed_object()->get_type_index());
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add_child(const LUIObject self, LUIBaseElement child)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIObject_add_child_193_comment =
  "C++ Interface:\n"
  "add_child(const LUIObject self, LUIBaseElement child)\n";
#else
static const char *Dtool_LUIObject_add_child_193_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIObject::remove_child(PointerTo< LUIBaseElement > child)
 */
static PyObject *Dtool_LUIObject_remove_child_194(PyObject *self, PyObject *arg) {
  LUIObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIObject, (void **)&local_this, "LUIObject.remove_child")) {
    return nullptr;
  }
  // 1-inline void LUIObject::remove_child(PointerTo< LUIBaseElement > child)
  PT(LUIBaseElement) arg_this;
  if (!Dtool_Coerce_LUIBaseElement(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LUIObject.remove_child", "LUIBaseElement");
  }
  ((*local_this).remove_child)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_child(const LUIObject self, LUIBaseElement child)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIObject_remove_child_194_comment =
  "C++ Interface:\n"
  "remove_child(const LUIObject self, LUIBaseElement child)\n";
#else
static const char *Dtool_LUIObject_remove_child_194_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIObject::remove_all_children(void)
 */
static PyObject *Dtool_LUIObject_remove_all_children_195(PyObject *self, PyObject *) {
  LUIObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIObject, (void **)&local_this, "LUIObject.remove_all_children")) {
    return nullptr;
  }
  // 1-inline void LUIObject::remove_all_children(void)
  ((*local_this).remove_all_children)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LUIObject_remove_all_children_195_comment =
  "C++ Interface:\n"
  "remove_all_children(const LUIObject self)\n";
#else
static const char *Dtool_LUIObject_remove_all_children_195_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int LUIObject::get_child_count(void) const
 */
static PyObject *Dtool_LUIObject_get_child_count_196(PyObject *self, PyObject *) {
  LUIObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIObject)) {
    return nullptr;
  }
  // 1-inline int LUIObject::get_child_count(void) const
  int return_value = ((*(const LUIObject*)local_this).get_child_count)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIObject_get_child_count_196_comment =
  "C++ Interface:\n"
  "get_child_count(LUIObject self)\n";
#else
static const char *Dtool_LUIObject_get_child_count_196_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIObject::set_content_node(PointerTo< LUIObject > content_node)
 */
static PyObject *Dtool_LUIObject_set_content_node_197(PyObject *self, PyObject *arg) {
  LUIObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIObject, (void **)&local_this, "LUIObject.set_content_node")) {
    return nullptr;
  }
  // 1-inline void LUIObject::set_content_node(PointerTo< LUIObject > content_node)
  PT(LUIObject) arg_this;
  if (!Dtool_Coerce_LUIObject(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LUIObject.set_content_node", "LUIObject");
  }
  ((*local_this).set_content_node)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_content_node(const LUIObject self, LUIObject content_node)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIObject_set_content_node_197_comment =
  "C++ Interface:\n"
  "set_content_node(const LUIObject self, LUIObject content_node)\n";
#else
static const char *Dtool_LUIObject_set_content_node_197_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< LUIObject > LUIObject::get_content_node(void) const
 */
static PyObject *Dtool_LUIObject_get_content_node_198(PyObject *self, PyObject *) {
  LUIObject *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIObject)) {
    return nullptr;
  }
  // 1-inline PointerTo< LUIObject > LUIObject::get_content_node(void) const
  PointerTo< LUIObject > return_value = ((*(const LUIObject*)local_this).get_content_node)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  LUIObject *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_LUIObject, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LUIObject_get_content_node_198_comment =
  "C++ Interface:\n"
  "get_content_node(LUIObject self)\n";
#else
static const char *Dtool_LUIObject_get_content_node_198_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void LUIObject::ls(int indent = 0)
 */
static PyObject *Dtool_LUIObject_ls_199(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIObject, (void **)&local_this, "LUIObject.ls")) {
    return nullptr;
  }
  // 1-virtual void LUIObject::ls(int indent = 0)
  int param1 = 0;
  static const char *keyword_list[] = {"indent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:ls", (char **)keyword_list, &param1)) {
    ((*local_this).ls)((int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ls(const LUIObject self, int indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIObject_ls_199_comment =
  "C++ Interface:\n"
  "ls(const LUIObject self, int indent)\n";
#else
static const char *Dtool_LUIObject_ls_199_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LUIObject::get_class_type(void)
 */
static PyObject *Dtool_LUIObject_get_class_type_206(PyObject *, PyObject *) {
  // 1-static TypeHandle LUIObject::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LUIObject::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LUIObject_get_class_type_206_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LUIObject_get_class_type_206_comment = nullptr;
#endif

static PyObject *Dtool_LUIObject_children_Getter(PyObject *self, void *) {
  const LUIObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIObject, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PointerTo< LUIElementIterator > LUIObject::get_children(void) const
  PointerTo< LUIElementIterator > return_value = ((*(const LUIObject*)local_this).get_children)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  // Transfer ownership of return_value.
  LUIElementIterator *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_LUIElementIterator, true, false);
}

static PyObject *Dtool_LUIObject_child_count_Getter(PyObject *self, void *) {
  const LUIObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIObject, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline int LUIObject::get_child_count(void) const
  int return_value = ((*(const LUIObject*)local_this).get_child_count)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_LUIObject_content_node_Getter(PyObject *self, void *) {
  const LUIObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIObject, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PointerTo< LUIObject > LUIObject::get_content_node(void) const
  PointerTo< LUIObject > return_value = ((*(const LUIObject*)local_this).get_content_node)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  // Transfer ownership of return_value.
  LUIObject *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_LUIObject, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

static int Dtool_LUIObject_content_node_Setter(PyObject *self, PyObject *arg, void *) {
  LUIObject *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIObject, (void **)&local_this, "LUIObject.content_node")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete content_node attribute");
    return -1;
  }
  // 1-inline void LUIObject::set_content_node(PointerTo< LUIObject > content_node)
  PT(LUIObject) arg_this;
  if (!Dtool_Coerce_LUIObject(arg, arg_this)) {
    Dtool_Raise_ArgTypeError(arg, 1, "LUIObject.set_content_node", "LUIObject");
    return -1;
  }
  ((*local_this).set_content_node)(std::move(arg_this));
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    Dtool_Raise_AssertionError();
    return -1;
  }
#endif
  return 0;
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_content_node(const LUIObject self, LUIObject content_node)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * LUIObject::LUIObject(PyObject *self, LUIObject *parent, float x = 0.0, float y = 0.0, float w = -1.0, float h = -1.0, bool solid = false)
 * LUIObject::LUIObject(PyObject *self, float x = 0.0, float y = 0.0, float w = -1.0, float h = -1.0, bool solid = false)
 */
static int Dtool_Init_LUIObject(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-LUIObject::LUIObject(PyObject *self, float x, float y, float w, float h, bool solid)
      // Pre-initialize self for the constructor
      DTool_PyInit_Finalize(self, nullptr, &Dtool_LUIObject, false, false);
      LUIObject *return_value = new LUIObject(self);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIObject, true, false);
    }
    break;
  case 1:
  case 2:
  case 3:
  case 4:
  case 5:
  case 6:
    {
      {
        // -2 LUIObject::LUIObject(PyObject *self, LUIObject *parent, float x = 0.0, float y = 0.0, float w = -1.0, float h = -1.0, bool solid = false)
        PyObject *param0;
        float param1 = 0.0;
        float param2 = 0.0;
        float param3 = -1.0;
        float param4 = -1.0;
        PyObject *param5 = Py_False;
        static const char *keyword_list[] = {"parent", "x", "y", "w", "h", "solid", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|ffffO:LUIObject", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
          LUIObject *param0_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LUIObject, 0, "LUIObject.LUIObject", false, false);
          if (param0_this != nullptr) {
            // Pre-initialize self for the constructor
            DTool_PyInit_Finalize(self, nullptr, &Dtool_LUIObject, false, false);
            LUIObject *return_value = new LUIObject(self, param0_this, (float)param1, (float)param2, (float)param3, (float)param4, (PyObject_IsTrue(param5) != 0));
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIObject, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 LUIObject::LUIObject(PyObject *self, float x = 0.0, float y = 0.0, float w = -1.0, float h = -1.0, bool solid = false)
        float param0;
        float param1 = 0.0;
        float param2 = -1.0;
        float param3 = -1.0;
        PyObject *param4 = Py_False;
        static const char *keyword_list[] = {"x", "y", "w", "h", "solid", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "f|fffO:LUIObject", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4)) {
          // Pre-initialize self for the constructor
          DTool_PyInit_Finalize(self, nullptr, &Dtool_LUIObject, false, false);
          LUIObject *return_value = new LUIObject(self, (float)param0, (float)param1, (float)param2, (float)param3, (PyObject_IsTrue(param4) != 0));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIObject, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 LUIObject::LUIObject(PyObject *self, LUIObject *parent, float x = 0.0, float y = 0.0, float w = -1.0, float h = -1.0, bool solid = false)
        PyObject *param0;
        float param1 = 0.0;
        float param2 = 0.0;
        float param3 = -1.0;
        float param4 = -1.0;
        PyObject *param5 = Py_False;
        static const char *keyword_list[] = {"parent", "x", "y", "w", "h", "solid", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "O|ffffO:LUIObject", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5)) {
          PT(LUIObject) param0_this;
          if (Dtool_Coerce_LUIObject(param0, param0_this)) {
            // Pre-initialize self for the constructor
            DTool_PyInit_Finalize(self, nullptr, &Dtool_LUIObject, false, false);
            LUIObject *return_value = new LUIObject(self, std::move(param0_this), (float)param1, (float)param2, (float)param3, (float)param4, (PyObject_IsTrue(param5) != 0));
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIObject, true, false);
          }
        }
        PyErr_Clear();
      }

      // No coercion possible: LUIObject::LUIObject(PyObject *self, float x = 0.0, float y = 0.0, float w = -1.0, float h = -1.0, bool solid = false)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LUIObject() takes 0, 1, 2, 3, 4, 5 or 6 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LUIObject()\n"
      "LUIObject(LUIObject parent, float x, float y, float w, float h, bool solid)\n"
      "LUIObject(float x, float y, float w, float h, bool solid)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_LUIObject(PyObject *args, CPT(LUIObject) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_LUIObject)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 LUIObject::LUIObject(PyObject *self, LUIObject *parent, float x, float y, float w, float h, bool solid)
      LUIObject *arg_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LUIObject, 0, "LUIObject.LUIObject", false, false);
      if (arg_this != nullptr) {
        // Pre-initialize self for the constructor
        PyObject *self = Dtool_new_LUIObject(&Dtool_LUIObject._PyType, nullptr, nullptr);
        LUIObject *return_value = new LUIObject(self, arg_this);
        PyObject_Del(self);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = std::move(return_value);
          return true;
        }
      }
    }

    {
      // -2 LUIObject::LUIObject(PyObject *self, float x, float y, float w, float h, bool solid)
      if (PyNumber_Check(arg)) {
        // Pre-initialize self for the constructor
        PyObject *self = Dtool_new_LUIObject(&Dtool_LUIObject._PyType, nullptr, nullptr);
        LUIObject *return_value = new LUIObject(self, (float)PyFloat_AsDouble(arg));
        PyObject_Del(self);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = std::move(return_value);
          return true;
        }
      }
    }

  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 6) {
      {
        // -2 LUIObject::LUIObject(PyObject *self, LUIObject *parent, float x, float y = 0.0, float w = -1.0, float h = -1.0, bool solid = false)
        PyObject *param0;
        float param1;
        float param2 = 0.0;
        float param3 = -1.0;
        float param4 = -1.0;
        PyObject *param5 = Py_False;
        if (PyArg_ParseTuple(args, "Of|fffO:LUIObject", &param0, &param1, &param2, &param3, &param4, &param5)) {
          LUIObject *param0_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LUIObject, 0, "LUIObject.LUIObject", false, false);
          if (param0_this != nullptr) {
            // Pre-initialize self for the constructor
            PyObject *self = Dtool_new_LUIObject(&Dtool_LUIObject._PyType, nullptr, nullptr);
            LUIObject *return_value = new LUIObject(self, param0_this, (float)param1, (float)param2, (float)param3, (float)param4, (PyObject_IsTrue(param5) != 0));
            PyObject_Del(self);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = std::move(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 LUIObject::LUIObject(PyObject *self, float x, float y = 0.0, float w = -1.0, float h = -1.0, bool solid = false)
        float param0;
        float param1;
        float param2 = -1.0;
        float param3 = -1.0;
        PyObject *param4 = Py_False;
        if (PyArg_ParseTuple(args, "ff|ffO:LUIObject", &param0, &param1, &param2, &param3, &param4)) {
          // Pre-initialize self for the constructor
          PyObject *self = Dtool_new_LUIObject(&Dtool_LUIObject._PyType, nullptr, nullptr);
          LUIObject *return_value = new LUIObject(self, (float)param0, (float)param1, (float)param2, (float)param3, (PyObject_IsTrue(param4) != 0));
          PyObject_Del(self);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
        PyErr_Clear();
      }

    }
  }

  return false;
}

bool Dtool_Coerce_LUIObject(PyObject *args, PT(LUIObject) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_LUIObject)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    {
      // -2 LUIObject::LUIObject(PyObject *self, LUIObject *parent, float x, float y, float w, float h, bool solid)
      LUIObject *arg_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LUIObject, 0, "LUIObject.LUIObject", false, false);
      if (arg_this != nullptr) {
        // Pre-initialize self for the constructor
        PyObject *self = Dtool_new_LUIObject(&Dtool_LUIObject._PyType, nullptr, nullptr);
        LUIObject *return_value = new LUIObject(self, arg_this);
        PyObject_Del(self);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = std::move(return_value);
          return true;
        }
      }
    }

    {
      // -2 LUIObject::LUIObject(PyObject *self, float x, float y, float w, float h, bool solid)
      if (PyNumber_Check(arg)) {
        // Pre-initialize self for the constructor
        PyObject *self = Dtool_new_LUIObject(&Dtool_LUIObject._PyType, nullptr, nullptr);
        LUIObject *return_value = new LUIObject(self, (float)PyFloat_AsDouble(arg));
        PyObject_Del(self);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = std::move(return_value);
          return true;
        }
      }
    }

  } else {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 6) {
      {
        // -2 LUIObject::LUIObject(PyObject *self, LUIObject *parent, float x, float y = 0.0, float w = -1.0, float h = -1.0, bool solid = false)
        PyObject *param0;
        float param1;
        float param2 = 0.0;
        float param3 = -1.0;
        float param4 = -1.0;
        PyObject *param5 = Py_False;
        if (PyArg_ParseTuple(args, "Of|fffO:LUIObject", &param0, &param1, &param2, &param3, &param4, &param5)) {
          LUIObject *param0_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LUIObject, 0, "LUIObject.LUIObject", false, false);
          if (param0_this != nullptr) {
            // Pre-initialize self for the constructor
            PyObject *self = Dtool_new_LUIObject(&Dtool_LUIObject._PyType, nullptr, nullptr);
            LUIObject *return_value = new LUIObject(self, param0_this, (float)param1, (float)param2, (float)param3, (float)param4, (PyObject_IsTrue(param5) != 0));
            PyObject_Del(self);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return false;
            }
            return_value->ref();
            if (_PyErr_OCCURRED()) {
              unref_delete(return_value);
              return false;
            } else {
              coerced = std::move(return_value);
              return true;
            }
          }
        }
        PyErr_Clear();
      }

      {
        // -2 LUIObject::LUIObject(PyObject *self, float x, float y = 0.0, float w = -1.0, float h = -1.0, bool solid = false)
        float param0;
        float param1;
        float param2 = -1.0;
        float param3 = -1.0;
        PyObject *param4 = Py_False;
        if (PyArg_ParseTuple(args, "ff|ffO:LUIObject", &param0, &param1, &param2, &param3, &param4)) {
          // Pre-initialize self for the constructor
          PyObject *self = Dtool_new_LUIObject(&Dtool_LUIObject._PyType, nullptr, nullptr);
          LUIObject *return_value = new LUIObject(self, (float)param0, (float)param1, (float)param2, (float)param3, (PyObject_IsTrue(param4) != 0));
          PyObject_Del(self);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
        PyErr_Clear();
      }

    }
  }

  return false;
}

static void *Dtool_UpcastInterface_LUIObject(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LUIObject) {
    printf("LUIObject ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LUIObject *local_this = (LUIObject *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LUIObject) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LUIBaseElement) {
    return (LUIBaseElement *) local_this;
  }
  if (requested_type == Dtool_Ptr_LUIColorable) {
    return (LUIColorable *)(LUIBaseElement *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(LUIBaseElement *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(LUIBaseElement *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(LUIBaseElement *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LUIObject(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LUIObject) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LUIBaseElement) {
    LUIBaseElement* other_this = (LUIBaseElement*)from_this;
    return (LUIObject*)other_this;
  }
  if (from_type == Dtool_Ptr_LUIColorable) {
    LUIColorable* other_this = (LUIColorable*)from_this;
    return (LUIObject*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LUIObject*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LUIObject*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LUIObject*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LUIAtlas
 */
/**
 * Python function wrapper for:
 * bool LUIAtlas::load_descriptor_file(std::string const &descriptor_path)
 */
static PyObject *Dtool_LUIAtlas_load_descriptor_file_214(PyObject *self, PyObject *arg) {
  LUIAtlas *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIAtlas, (void **)&local_this, "LUIAtlas.load_descriptor_file")) {
    return nullptr;
  }
  // 1-bool LUIAtlas::load_descriptor_file(std::string const &descriptor_path)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*local_this).load_descriptor_file)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_descriptor_file(const LUIAtlas self, str descriptor_path)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIAtlas_load_descriptor_file_214_comment =
  "C++ Interface:\n"
  "load_descriptor_file(const LUIAtlas self, str descriptor_path)\n"
  "\n"
  "/**\n"
  " * @brief Loads a descriptor file\n"
  " * @details This loads a descriptor file previously created with LUIAtlasGen.\n"
  " *   When the file was loaded, true is returned, otherwise an error is printed\n"
  " *   and false is returned.\n"
  " *\n"
  " * @param descriptor_path Path to the generated atlas file, most times 'atlas.txt'\n"
  " * @return true if the atlas file was loaded, false otherwise\n"
  " */";
#else
static const char *Dtool_LUIAtlas_load_descriptor_file_214_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * bool LUIAtlas::load_texture(std::string const &texture_path)
 */
static PyObject *Dtool_LUIAtlas_load_texture_215(PyObject *self, PyObject *arg) {
  LUIAtlas *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIAtlas, (void **)&local_this, "LUIAtlas.load_texture")) {
    return nullptr;
  }
  // 1-bool LUIAtlas::load_texture(std::string const &texture_path)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*local_this).load_texture)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_texture(const LUIAtlas self, str texture_path)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIAtlas_load_texture_215_comment =
  "C++ Interface:\n"
  "load_texture(const LUIAtlas self, str texture_path)\n"
  "\n"
  "/**\n"
  " * @brief Loads an atlas texture\n"
  " * @details This loads the atlas texture, and prepares it for rendering by setting\n"
  " *   several filtering properties on the texture. If the texture was not found,\n"
  " *   returns false, otherwise returns true. Also returns false if the texture\n"
  " *   has different dimensions in width / height.\n"
  " *\n"
  " * @param texture_path Path to the atlas texture\n"
  " * @return true if the texture was loaded successfully, false otherwise\n"
  " */";
#else
static const char *Dtool_LUIAtlas_load_texture_215_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Texture *LUIAtlas::get_texture(void) const
 */
static PyObject *Dtool_LUIAtlas_get_texture_216(PyObject *self, PyObject *) {
  LUIAtlas *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIAtlas)) {
    return nullptr;
  }
  // 1-inline Texture *LUIAtlas::get_texture(void) const
  Texture *return_value = ((*(const LUIAtlas*)local_this).get_texture)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LUIAtlas_get_texture_216_comment =
  "C++ Interface:\n"
  "get_texture(LUIAtlas self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the atlas texture\n"
  " * @details This returns a handle to the atlas texture, which can be used for\n"
  " *   rendering.\n"
  " * @return Handle to the atlas texture\n"
  " */";
#else
static const char *Dtool_LUIAtlas_get_texture_216_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LUIAtlas::has_entry(std::string const &name) const
 */
static PyObject *Dtool_LUIAtlas_has_entry_217(PyObject *self, PyObject *arg) {
  LUIAtlas *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIAtlas)) {
    return nullptr;
  }
  // 1-inline bool LUIAtlas::has_entry(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*(const LUIAtlas*)local_this).has_entry)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_entry(LUIAtlas self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIAtlas_has_entry_217_comment =
  "C++ Interface:\n"
  "has_entry(LUIAtlas self, str name)\n"
  "\n"
  "/**\n"
  " * @brief Checks whether an entry exists in the atlas.\n"
  " * @details This methods checks if an entry with the given name exists in the\n"
  " *   atlas. If an entry was found, true is returned, otherwise false.\n"
  " *\n"
  " * @param name Entry name, case sensitive\n"
  " * @return true if the entry was found, false otherwise\n"
  " */";
#else
static const char *Dtool_LUIAtlas_has_entry_217_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline int LUIAtlas::get_size(void) const
 */
static PyObject *Dtool_LUIAtlas_get_size_219(PyObject *self, PyObject *) {
  LUIAtlas *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIAtlas)) {
    return nullptr;
  }
  // 1-inline int LUIAtlas::get_size(void) const
  int return_value = ((*(const LUIAtlas*)local_this).get_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIAtlas_get_size_219_comment =
  "C++ Interface:\n"
  "get_size(LUIAtlas self)\n"
  "\n"
  "/**\n"
  " * @brief Returns the atlas size.\n"
  " * @details Returns the atlas size in pixels, this is a convenience function for\n"
  " *   Texture::get_x_size(). It assumes the atlas has the same width and height.\n"
  " * @return Size of the atlas in pixels\n"
  " */";
#else
static const char *Dtool_LUIAtlas_get_size_219_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LUIAtlas::LUIAtlas(void) = default
 * inline LUIAtlas::LUIAtlas(LUIAtlas const &) = default
 */
static int Dtool_Init_LUIAtlas(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("LUIAtlas() takes no keyword arguments");
    return -1;
#endif
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-inline LUIAtlas::LUIAtlas(void) = default
      LUIAtlas *return_value = new LUIAtlas();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIAtlas, true, false);
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline LUIAtlas::LUIAtlas(LUIAtlas const &) = default
      LUIAtlas const *arg_this = (LUIAtlas *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LUIAtlas, 0, "LUIAtlas.LUIAtlas", true, true);
      if (arg_this != nullptr) {
        LUIAtlas *return_value = new LUIAtlas(*arg_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIAtlas, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LUIAtlas() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LUIAtlas()\n"
      "LUIAtlas(const LUIAtlas param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LUIAtlas(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LUIAtlas) {
    printf("LUIAtlas ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LUIAtlas *local_this = (LUIAtlas *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LUIAtlas) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LUIAtlas(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LUIAtlas) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LUIAtlas*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LUIAtlasPool
 */
/**
 * Python function wrapper for:
 * static LUIAtlasPool *LUIAtlasPool::get_global_ptr(void)
 */
static PyObject *Dtool_LUIAtlasPool_get_global_ptr_223(PyObject *, PyObject *) {
  // 1-static LUIAtlasPool *LUIAtlasPool::get_global_ptr(void)
  LUIAtlasPool *return_value = (LUIAtlasPool::get_global_ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LUIAtlasPool, false, false);
}

#ifndef NDEBUG
static const char *Dtool_LUIAtlasPool_get_global_ptr_223_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n"
  "\n"
  "/**\n"
  " * @brief Returns the global LUIAtlasPool instance\n"
  " * @details This returns the global instance of the LUIAtlasPool. If no instance\n"
  " *   exists yet, it is created first.\n"
  " * @return Handle to the global atlas pool instance\n"
  " */";
#else
static const char *Dtool_LUIAtlasPool_get_global_ptr_223_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LUIAtlasPool::load_atlas(std::string const &atlas_id, std::string const &atlas_desc_path, std::string const &atlas_tex_path)
 */
static PyObject *Dtool_LUIAtlasPool_load_atlas_224(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIAtlasPool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIAtlasPool, (void **)&local_this, "LUIAtlasPool.load_atlas")) {
    return nullptr;
  }
  // 1-void LUIAtlasPool::load_atlas(std::string const &atlas_id, std::string const &atlas_desc_path, std::string const &atlas_tex_path)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  const char *param3_str = nullptr;
  Py_ssize_t param3_len;
  static const char *keyword_list[] = {"atlas_id", "atlas_desc_path", "atlas_tex_path", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#s#:load_atlas", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len, &param3_str, &param3_len)) {
    ((*local_this).load_atlas)(std::string(param1_str, param1_len), std::string(param2_str, param2_len), std::string(param3_str, param3_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_atlas(const LUIAtlasPool self, str atlas_id, str atlas_desc_path, str atlas_tex_path)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIAtlasPool_load_atlas_224_comment =
  "C++ Interface:\n"
  "load_atlas(const LUIAtlasPool self, str atlas_id, str atlas_desc_path, str atlas_tex_path)\n"
  "\n"
  "/**\n"
  " * @brief Loads an atlas from a given filename and descriptor path\n"
  " * @details This loads an atlas with the given name from two files, the descriptor\n"
  " *   and texture file. The files should be the ones generated with LUIAtlasGen.\n"
  " *\n"
  " *   The atlas_desc_path path should point to the file which stores the atlas\n"
  " *   entries, in most cases atlas.txt. The atlas_tex_path should point to the\n"
  " *   atlas texture file, in most cases atlas.png.\n"
  " *\n"
  " *   In case the atlas fails to load, an error message is printed and nothing\n"
  " *   happens.\n"
  " *\n"
  " * @param atlas_id Name of the atlas, under which it will be stored\n"
  " * @param atlas_desc_path Path to the descriptor file\n"
  " * @param atlas_tex_path Path to the atlas texture file\n"
  " */";
#else
static const char *Dtool_LUIAtlasPool_load_atlas_224_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LUIAtlasPool::has_atlas(std::string const &atlas_id) const
 */
static PyObject *Dtool_LUIAtlasPool_has_atlas_225(PyObject *self, PyObject *arg) {
  LUIAtlasPool *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIAtlasPool)) {
    return nullptr;
  }
  // 1-inline bool LUIAtlasPool::has_atlas(std::string const &atlas_id) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*(const LUIAtlasPool*)local_this).has_atlas)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_atlas(LUIAtlasPool self, str atlas_id)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIAtlasPool_has_atlas_225_comment =
  "C++ Interface:\n"
  "has_atlas(LUIAtlasPool self, str atlas_id)\n"
  "\n"
  "/**\n"
  " * @brief Checks whether an atlas exists\n"
  " * @details This method checks if there was an atlas loaded with the given name.\n"
  " *   If this is the case, the method returns true, otherwise false.\n"
  " *\n"
  " * @param atlas_id Name of the atlas, case sensitive\n"
  " * @return true if the atlas was loaded, false otherwise\n"
  " */";
#else
static const char *Dtool_LUIAtlasPool_has_atlas_225_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< LUIAtlas > LUIAtlasPool::get_atlas(std::string const &atlas_id) const
 */
static PyObject *Dtool_LUIAtlasPool_get_atlas_226(PyObject *self, PyObject *arg) {
  LUIAtlasPool *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIAtlasPool)) {
    return nullptr;
  }
  // 1-inline PointerTo< LUIAtlas > LUIAtlasPool::get_atlas(std::string const &atlas_id) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    PointerTo< LUIAtlas > return_value = ((*(const LUIAtlasPool*)local_this).get_atlas)(std::string(param1_str, param1_len));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    // Transfer ownership of return_value.
    LUIAtlas *return_ptr = return_value.p();
    return_value.cheat() = nullptr;
    return DTool_CreatePyInstance((void *)return_ptr, *Dtool_Ptr_LUIAtlas, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_atlas(LUIAtlasPool self, str atlas_id)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIAtlasPool_get_atlas_226_comment =
  "C++ Interface:\n"
  "get_atlas(LUIAtlasPool self, str atlas_id)\n"
  "\n"
  "/**\n"
  " * @brief Returns an atlas by name\n"
  " * @details This method returns an atlas with the given name. If the name was\n"
  " *   not found, because the atlas was not loaded yet, null is returned.\n"
  " *\n"
  " * @param atlas_id Name of the atlas\n"
  " * @return Handle to the atlas, or null\n"
  " */";
#else
static const char *Dtool_LUIAtlasPool_get_atlas_226_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LUIAtlasPool::LUIAtlasPool(LUIAtlasPool const &) = default
 */
static int Dtool_Init_LUIAtlasPool(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("LUIAtlasPool() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline LUIAtlasPool::LUIAtlasPool(LUIAtlasPool const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    LUIAtlasPool const *param0_this = (LUIAtlasPool *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LUIAtlasPool, 0, "LUIAtlasPool.LUIAtlasPool", true, true);
    if (param0_this != nullptr) {
      LUIAtlasPool *return_value = new LUIAtlasPool(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      if (Dtool_CheckErrorOccurred()) {
        delete return_value;
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIAtlasPool, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LUIAtlasPool(const LUIAtlasPool param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LUIAtlasPool(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LUIAtlasPool) {
    printf("LUIAtlasPool ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LUIAtlasPool *local_this = (LUIAtlasPool *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LUIAtlasPool) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LUIAtlasPool(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LUIAtlasPool) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LUISprite
 */
/**
 * Python function wrapper for:
 * inline void LUISprite::set_uv_range(LTexCoord const &uv_begin, LTexCoord const &uv_end)
 * inline void LUISprite::set_uv_range(float u0, float v0, float u1, float v1)
 */
static PyObject *Dtool_LUISprite_set_uv_range_232(PyObject *self, PyObject *args, PyObject *kwds) {
  LUISprite *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUISprite, (void **)&local_this, "LUISprite.set_uv_range")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-inline void LUISprite::set_uv_range(LTexCoord const &uv_begin, LTexCoord const &uv_end)
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"uv_begin", "uv_end", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_uv_range", (char **)keyword_list, &param1, &param2)) {
        LPoint2f param1_local;
        LTexCoord const *param1_this = Dtool_Coerce_LPoint2f(param1, param1_local);
        if (!(param1_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param1, 1, "LUISprite.set_uv_range", "LPoint2f");
        }
        LPoint2f param2_local;
        LTexCoord const *param2_this = Dtool_Coerce_LPoint2f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "LUISprite.set_uv_range", "LPoint2f");
        }
        ((*local_this).set_uv_range)(*param1_this, *param2_this);
        return Dtool_Return_None();
      }
    }
    break;
  case 4:
    {
      // 1-inline void LUISprite::set_uv_range(float u0, float v0, float u1, float v1)
      float param1;
      float param2;
      float param3;
      float param4;
      static const char *keyword_list[] = {"u0", "v0", "u1", "v1", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ffff:set_uv_range", (char **)keyword_list, &param1, &param2, &param3, &param4)) {
        ((*local_this).set_uv_range)((float)param1, (float)param2, (float)param3, (float)param4);
        return Dtool_Return_None();
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_uv_range() takes 3 or 5 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_uv_range(const LUISprite self, const LPoint2f uv_begin, const LPoint2f uv_end)\n"
      "set_uv_range(const LUISprite self, float u0, float v0, float u1, float v1)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_uv_range_232_comment =
  "C++ Interface:\n"
  "set_uv_range(const LUISprite self, const LPoint2f uv_begin, const LPoint2f uv_end)\n"
  "set_uv_range(const LUISprite self, float u0, float v0, float u1, float v1)\n"
  "\n"
  "// Texcoord";
#else
static const char *Dtool_LUISprite_set_uv_range_232_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LTexCoord const &LUISprite::get_uv_begin(void) const
 */
static PyObject *Dtool_LUISprite_get_uv_begin_233(PyObject *self, PyObject *) {
  LUISprite *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUISprite)) {
    return nullptr;
  }
  // 1-inline LTexCoord const &LUISprite::get_uv_begin(void) const
  LTexCoord const *return_value = &(((*(const LUISprite*)local_this).get_uv_begin)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_uv_begin_233_comment =
  "C++ Interface:\n"
  "get_uv_begin(LUISprite self)\n";
#else
static const char *Dtool_LUISprite_get_uv_begin_233_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LTexCoord const &LUISprite::get_uv_end(void) const
 */
static PyObject *Dtool_LUISprite_get_uv_end_234(PyObject *self, PyObject *) {
  LUISprite *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUISprite)) {
    return nullptr;
  }
  // 1-inline LTexCoord const &LUISprite::get_uv_end(void) const
  LTexCoord const *return_value = &(((*(const LUISprite*)local_this).get_uv_end)());
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, false, true);
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_uv_end_234_comment =
  "C++ Interface:\n"
  "get_uv_end(LUISprite self)\n";
#else
static const char *Dtool_LUISprite_get_uv_end_234_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * Rejected Remap [inline void LUISprite::set_texture(LUIAtlasDescriptor const &descriptor, bool resize)]
 * inline void LUISprite::set_texture(Texture *tex, bool resize = true)
 * inline void LUISprite::set_texture(std::string const &source, bool resize = true)
 * inline void LUISprite::set_texture(std::string const &entry_name, std::string const &atlas_id, bool resize = true)
 */
static PyObject *Dtool_LUISprite_set_texture_235(PyObject *self, PyObject *args, PyObject *kwds) {
  LUISprite *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUISprite, (void **)&local_this, "LUISprite.set_texture")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      {
        // -2 inline void LUISprite::set_texture(Texture *tex, bool resize)
        PyObject *param1;
        if (Dtool_ExtractArg(&param1, args, kwds, "tex")) {
          Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "LUISprite.set_texture", false, false);
          if (param1_this != nullptr) {
            ((*local_this).set_texture)(param1_this);
            return Dtool_Return_None();
          }
        }
      }

      {
        // -2 inline void LUISprite::set_texture(std::string const &source, bool resize)
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        static const char *keyword_list[] = {"source", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:set_texture", (char **)keyword_list, &param1_str, &param1_len)) {
          ((*local_this).set_texture)(std::string(param1_str, param1_len));
          return Dtool_Return_None();
        }
        PyErr_Clear();
      }

      // No coercion possible: inline void LUISprite::set_texture(Texture *tex, bool resize)
      // No coercion possible: inline void LUISprite::set_texture(std::string const &source, bool resize)
    }
    break;
  case 2:
  case 3:
    {
      {
        // -2 inline void LUISprite::set_texture(std::string const &entry_name, std::string const &atlas_id, bool resize = true)
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        const char *param2_str = nullptr;
        Py_ssize_t param2_len;
        PyObject *param3 = Py_True;
        static const char *keyword_list[] = {"entry_name", "atlas_id", "resize", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#|O:set_texture", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len, &param3)) {
          ((*local_this).set_texture)(std::string(param1_str, param1_len), std::string(param2_str, param2_len), (PyObject_IsTrue(param3) != 0));
          return Dtool_Return_None();
        }
        PyErr_Clear();
      }

      {
        // -2 inline void LUISprite::set_texture(Texture *tex, bool resize = true)
        PyObject *param1;
        PyObject *param2;
        static const char *keyword_list[] = {"tex", "resize", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:set_texture", (char **)keyword_list, &param1, &param2)) {
          Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "LUISprite.set_texture", false, false);
          if (param1_this != nullptr) {
            ((*local_this).set_texture)(param1_this, (PyObject_IsTrue(param2) != 0));
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 inline void LUISprite::set_texture(std::string const &source, bool resize = true)
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        PyObject *param2;
        static const char *keyword_list[] = {"source", "resize", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:set_texture", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
          ((*local_this).set_texture)(std::string(param1_str, param1_len), (PyObject_IsTrue(param2) != 0));
          return Dtool_Return_None();
        }
        PyErr_Clear();
      }

      // No coercion possible: inline void LUISprite::set_texture(std::string const &entry_name, std::string const &atlas_id, bool resize = true)
      // No coercion possible: inline void LUISprite::set_texture(Texture *tex, bool resize = true)
      // No coercion possible: inline void LUISprite::set_texture(std::string const &source, bool resize = true)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "set_texture() takes 2, 3 or 4 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_texture(const LUISprite self, Texture tex)\n"
      "set_texture(const LUISprite self, str source)\n"
      "set_texture(const LUISprite self, str entry_name, str atlas_id, bool resize)\n"
      "set_texture(const LUISprite self, Texture tex, bool resize)\n"
      "set_texture(const LUISprite self, str source, bool resize)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_set_texture_235_comment =
  "C++ Interface:\n"
  "set_texture(const LUISprite self, Texture tex)\n"
  "set_texture(const LUISprite self, str source)\n"
  "set_texture(const LUISprite self, str entry_name, str atlas_id, bool resize)\n"
  "set_texture(const LUISprite self, Texture tex, bool resize)\n"
  "set_texture(const LUISprite self, str source, bool resize)\n"
  "\n"
  "// Texture";
#else
static const char *Dtool_LUISprite_set_texture_235_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline Texture *LUISprite::get_texture(void) const
 */
static PyObject *Dtool_LUISprite_get_texture_236(PyObject *self, PyObject *) {
  LUISprite *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUISprite)) {
    return nullptr;
  }
  // 1-inline Texture *LUISprite::get_texture(void) const
  Texture *return_value = ((*(const LUISprite*)local_this).get_texture)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_texture_236_comment =
  "C++ Interface:\n"
  "get_texture(LUISprite self)\n";
#else
static const char *Dtool_LUISprite_get_texture_236_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUISprite::print_vertices(void)
 */
static PyObject *Dtool_LUISprite_print_vertices_237(PyObject *self, PyObject *) {
  LUISprite *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUISprite, (void **)&local_this, "LUISprite.print_vertices")) {
    return nullptr;
  }
  // 1-inline void LUISprite::print_vertices(void)
  ((*local_this).print_vertices)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_print_vertices_237_comment =
  "C++ Interface:\n"
  "print_vertices(const LUISprite self)\n";
#else
static const char *Dtool_LUISprite_print_vertices_237_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * virtual void LUISprite::ls(int indent = 0)
 */
static PyObject *Dtool_LUISprite_ls_238(PyObject *self, PyObject *args, PyObject *kwds) {
  LUISprite *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUISprite, (void **)&local_this, "LUISprite.ls")) {
    return nullptr;
  }
  // 1-virtual void LUISprite::ls(int indent = 0)
  int param1 = 0;
  static const char *keyword_list[] = {"indent", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "|i:ls", (char **)keyword_list, &param1)) {
    ((*local_this).ls)((int)param1);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "ls(const LUISprite self, int indent)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_ls_238_comment =
  "C++ Interface:\n"
  "ls(const LUISprite self, int indent)\n";
#else
static const char *Dtool_LUISprite_ls_238_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LUISprite::get_class_type(void)
 */
static PyObject *Dtool_LUISprite_get_class_type_242(PyObject *, PyObject *) {
  // 1-static TypeHandle LUISprite::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LUISprite::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LUISprite_get_class_type_242_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LUISprite_get_class_type_242_comment = nullptr;
#endif

static PyObject *Dtool_LUISprite_texture_Getter(PyObject *self, void *) {
  const LUISprite *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUISprite, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline Texture *LUISprite::get_texture(void) const
  Texture *return_value = ((*(const LUISprite*)local_this).get_texture)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_Texture, true, false, return_value->as_typed_object()->get_type_index());
  }
}

/**
 * Python function wrapper for:
 * LUISprite::LUISprite(PyObject *self, LUIObject *parent, Texture *texture, float x = 0.0, float y = 0.0, float w = 0.0, float h = 0.0, LColor const &color = LColor(1))
 * LUISprite::LUISprite(PyObject *self, LUIObject *parent, std::string const &image, float x = 0.0, float y = 0.0, float w = 0.0, float h = 0.0, LColor const &color = LColor(1))
 * LUISprite::LUISprite(PyObject *self, LUIObject *parent, std::string const &entry_id, std::string const &atlas_id, float x = 0.0, float y = 0.0, float w = 0.0, float h = 0.0, LColor const &color = LColor(1))
 */
static int Dtool_Init_LUISprite(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      {
        // -2 LUISprite::LUISprite(PyObject *self, LUIObject *parent, Texture *texture, float x, float y, float w, float h, LColor const &color)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"parent", "texture", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:LUISprite", (char **)keyword_list, &param0, &param1)) {
          LUIObject *param0_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LUIObject, 0, "LUISprite.LUISprite", false, false);
          Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "LUISprite.LUISprite", false, false);
          if (param0_this != nullptr && param1_this != nullptr) {
            // Pre-initialize self for the constructor
            DTool_PyInit_Finalize(self, nullptr, &Dtool_LUISprite, false, false);
            LUISprite *return_value = new LUISprite(self, param0_this, param1_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUISprite, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 LUISprite::LUISprite(PyObject *self, LUIObject *parent, std::string const &image, float x, float y, float w, float h, LColor const &color)
        PyObject *param0;
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        static const char *keyword_list[] = {"parent", "image", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:LUISprite", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
          LUIObject *param0_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LUIObject, 0, "LUISprite.LUISprite", false, false);
          if (param0_this != nullptr) {
            // Pre-initialize self for the constructor
            DTool_PyInit_Finalize(self, nullptr, &Dtool_LUISprite, false, false);
            LUISprite *return_value = new LUISprite(self, param0_this, std::string(param1_str, param1_len));
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUISprite, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 LUISprite::LUISprite(PyObject *self, LUIObject *parent, Texture *texture, float x, float y, float w, float h, LColor const &color)
        PyObject *param0;
        PyObject *param1;
        static const char *keyword_list[] = {"parent", "texture", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OO:LUISprite", (char **)keyword_list, &param0, &param1)) {
          PT(LUIObject) param0_this;
          Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "LUISprite.LUISprite", false, false);
          if (Dtool_Coerce_LUIObject(param0, param0_this) && param1_this != nullptr) {
            // Pre-initialize self for the constructor
            DTool_PyInit_Finalize(self, nullptr, &Dtool_LUISprite, false, false);
            LUISprite *return_value = new LUISprite(self, std::move(param0_this), param1_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUISprite, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 LUISprite::LUISprite(PyObject *self, LUIObject *parent, std::string const &image, float x, float y, float w, float h, LColor const &color)
        PyObject *param0;
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        static const char *keyword_list[] = {"parent", "image", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:LUISprite", (char **)keyword_list, &param0, &param1_str, &param1_len)) {
          PT(LUIObject) param0_this;
          if (Dtool_Coerce_LUIObject(param0, param0_this)) {
            // Pre-initialize self for the constructor
            DTool_PyInit_Finalize(self, nullptr, &Dtool_LUISprite, false, false);
            LUISprite *return_value = new LUISprite(self, std::move(param0_this), std::string(param1_str, param1_len));
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUISprite, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
  case 3:
  case 4:
  case 5:
  case 6:
  case 7:
  case 8:
    {
      {
        // -2 LUISprite::LUISprite(PyObject *self, LUIObject *parent, std::string const &entry_id, std::string const &atlas_id, float x = 0.0, float y = 0.0, float w = 0.0, float h = 0.0, LColor const &color = LColor(1))
        PyObject *param0;
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        const char *param2_str = nullptr;
        Py_ssize_t param2_len;
        float param3 = 0.0;
        float param4 = 0.0;
        float param5 = 0.0;
        float param6 = 0.0;
        PyObject *param7 = nullptr;
        static const char *keyword_list[] = {"parent", "entry_id", "atlas_id", "x", "y", "w", "h", "color", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#s#|ffffO:LUISprite", (char **)keyword_list, &param0, &param1_str, &param1_len, &param2_str, &param2_len, &param3, &param4, &param5, &param6, &param7)) {
          LUIObject *param0_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LUIObject, 0, "LUISprite.LUISprite", false, false);
          LColor const *param7_this;
          const LVecBase4f &param7_ref = LColor(1);
          if (param7 == nullptr) {
            param7_this = &param7_ref;
          } else {
            param7_this = nullptr;
            DtoolInstance_GetPointer(param7, param7_this, *Dtool_Ptr_LVecBase4f);
          }
          if (param0_this != nullptr && (param7 == nullptr || param7_this != nullptr)) {
            // Pre-initialize self for the constructor
            DTool_PyInit_Finalize(self, nullptr, &Dtool_LUISprite, false, false);
            LUISprite *return_value = new LUISprite(self, param0_this, std::string(param1_str, param1_len), std::string(param2_str, param2_len), (float)param3, (float)param4, (float)param5, (float)param6, *param7_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUISprite, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 LUISprite::LUISprite(PyObject *self, LUIObject *parent, Texture *texture, float x = 0.0, float y = 0.0, float w = 0.0, float h = 0.0, LColor const &color = LColor(1))
        PyObject *param0;
        PyObject *param1;
        float param2;
        float param3 = 0.0;
        float param4 = 0.0;
        float param5 = 0.0;
        PyObject *param6 = nullptr;
        static const char *keyword_list[] = {"parent", "texture", "x", "y", "w", "h", "color", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOf|fffO:LUISprite", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6)) {
          LUIObject *param0_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LUIObject, 0, "LUISprite.LUISprite", false, false);
          Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "LUISprite.LUISprite", false, false);
          LColor const *param6_this;
          const LVecBase4f &param6_ref = LColor(1);
          if (param6 == nullptr) {
            param6_this = &param6_ref;
          } else {
            param6_this = nullptr;
            DtoolInstance_GetPointer(param6, param6_this, *Dtool_Ptr_LVecBase4f);
          }
          if (param0_this != nullptr && param1_this != nullptr && (param6 == nullptr || param6_this != nullptr)) {
            // Pre-initialize self for the constructor
            DTool_PyInit_Finalize(self, nullptr, &Dtool_LUISprite, false, false);
            LUISprite *return_value = new LUISprite(self, param0_this, param1_this, (float)param2, (float)param3, (float)param4, (float)param5, *param6_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUISprite, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 LUISprite::LUISprite(PyObject *self, LUIObject *parent, std::string const &image, float x = 0.0, float y = 0.0, float w = 0.0, float h = 0.0, LColor const &color = LColor(1))
        PyObject *param0;
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        float param2;
        float param3 = 0.0;
        float param4 = 0.0;
        float param5 = 0.0;
        PyObject *param6 = nullptr;
        static const char *keyword_list[] = {"parent", "image", "x", "y", "w", "h", "color", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#f|fffO:LUISprite", (char **)keyword_list, &param0, &param1_str, &param1_len, &param2, &param3, &param4, &param5, &param6)) {
          LUIObject *param0_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LUIObject, 0, "LUISprite.LUISprite", false, false);
          LColor const *param6_this;
          const LVecBase4f &param6_ref = LColor(1);
          if (param6 == nullptr) {
            param6_this = &param6_ref;
          } else {
            param6_this = nullptr;
            DtoolInstance_GetPointer(param6, param6_this, *Dtool_Ptr_LVecBase4f);
          }
          if (param0_this != nullptr && (param6 == nullptr || param6_this != nullptr)) {
            // Pre-initialize self for the constructor
            DTool_PyInit_Finalize(self, nullptr, &Dtool_LUISprite, false, false);
            LUISprite *return_value = new LUISprite(self, param0_this, std::string(param1_str, param1_len), (float)param2, (float)param3, (float)param4, (float)param5, *param6_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUISprite, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 LUISprite::LUISprite(PyObject *self, LUIObject *parent, std::string const &entry_id, std::string const &atlas_id, float x = 0.0, float y = 0.0, float w = 0.0, float h = 0.0, LColor const &color = LColor(1))
        PyObject *param0;
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        const char *param2_str = nullptr;
        Py_ssize_t param2_len;
        float param3 = 0.0;
        float param4 = 0.0;
        float param5 = 0.0;
        float param6 = 0.0;
        PyObject *param7 = nullptr;
        static const char *keyword_list[] = {"parent", "entry_id", "atlas_id", "x", "y", "w", "h", "color", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#s#|ffffO:LUISprite", (char **)keyword_list, &param0, &param1_str, &param1_len, &param2_str, &param2_len, &param3, &param4, &param5, &param6, &param7)) {
          PT(LUIObject) param0_this;
          LVecBase4f param7_local;
          LColor const *param7_this;
          if (param7 != nullptr) {
            param7_this = Dtool_Coerce_LVecBase4f(param7, param7_local);
          } else {
            param7_local = LColor(1);
            param7_this = &param7_local;
          }
          if (Dtool_Coerce_LUIObject(param0, param0_this) && (param7 == nullptr || (param7_this != nullptr))) {
            // Pre-initialize self for the constructor
            DTool_PyInit_Finalize(self, nullptr, &Dtool_LUISprite, false, false);
            LUISprite *return_value = new LUISprite(self, std::move(param0_this), std::string(param1_str, param1_len), std::string(param2_str, param2_len), (float)param3, (float)param4, (float)param5, (float)param6, *param7_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUISprite, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 LUISprite::LUISprite(PyObject *self, LUIObject *parent, Texture *texture, float x = 0.0, float y = 0.0, float w = 0.0, float h = 0.0, LColor const &color = LColor(1))
        PyObject *param0;
        PyObject *param1;
        float param2;
        float param3 = 0.0;
        float param4 = 0.0;
        float param5 = 0.0;
        PyObject *param6 = nullptr;
        static const char *keyword_list[] = {"parent", "texture", "x", "y", "w", "h", "color", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "OOf|fffO:LUISprite", (char **)keyword_list, &param0, &param1, &param2, &param3, &param4, &param5, &param6)) {
          PT(LUIObject) param0_this;
          Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "LUISprite.LUISprite", false, false);
          LVecBase4f param6_local;
          LColor const *param6_this;
          if (param6 != nullptr) {
            param6_this = Dtool_Coerce_LVecBase4f(param6, param6_local);
          } else {
            param6_local = LColor(1);
            param6_this = &param6_local;
          }
          if (Dtool_Coerce_LUIObject(param0, param0_this) && param1_this != nullptr && (param6 == nullptr || (param6_this != nullptr))) {
            // Pre-initialize self for the constructor
            DTool_PyInit_Finalize(self, nullptr, &Dtool_LUISprite, false, false);
            LUISprite *return_value = new LUISprite(self, std::move(param0_this), param1_this, (float)param2, (float)param3, (float)param4, (float)param5, *param6_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUISprite, true, false);
          }
        }
        PyErr_Clear();
      }

      {
        // -2 LUISprite::LUISprite(PyObject *self, LUIObject *parent, std::string const &image, float x = 0.0, float y = 0.0, float w = 0.0, float h = 0.0, LColor const &color = LColor(1))
        PyObject *param0;
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
        float param2;
        float param3 = 0.0;
        float param4 = 0.0;
        float param5 = 0.0;
        PyObject *param6 = nullptr;
        static const char *keyword_list[] = {"parent", "image", "x", "y", "w", "h", "color", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#f|fffO:LUISprite", (char **)keyword_list, &param0, &param1_str, &param1_len, &param2, &param3, &param4, &param5, &param6)) {
          PT(LUIObject) param0_this;
          LVecBase4f param6_local;
          LColor const *param6_this;
          if (param6 != nullptr) {
            param6_this = Dtool_Coerce_LVecBase4f(param6, param6_local);
          } else {
            param6_local = LColor(1);
            param6_this = &param6_local;
          }
          if (Dtool_Coerce_LUIObject(param0, param0_this) && (param6 == nullptr || (param6_this != nullptr))) {
            // Pre-initialize self for the constructor
            DTool_PyInit_Finalize(self, nullptr, &Dtool_LUISprite, false, false);
            LUISprite *return_value = new LUISprite(self, std::move(param0_this), std::string(param1_str, param1_len), (float)param2, (float)param3, (float)param4, (float)param5, *param6_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUISprite, true, false);
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LUISprite() takes 2, 3, 4, 5, 6, 7 or 8 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LUISprite(LUIObject parent, Texture texture)\n"
      "LUISprite(LUIObject parent, str image)\n"
      "LUISprite(LUIObject parent, str entry_id, str atlas_id, float x, float y, float w, float h, const LVecBase4f color)\n"
      "LUISprite(LUIObject parent, Texture texture, float x, float y, float w, float h, const LVecBase4f color)\n"
      "LUISprite(LUIObject parent, str image, float x, float y, float w, float h, const LVecBase4f color)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_LUISprite(PyObject *args, CPT(LUISprite) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_LUISprite)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        {
          // -2 LUISprite::LUISprite(PyObject *self, LUIObject *parent, Texture *texture, float x, float y, float w, float h, LColor const &color)
          PyObject *param0;
          PyObject *param1;
          if (PyArg_UnpackTuple(args, "LUISprite", 2, 2, &param0, &param1)) {
            LUIObject *param0_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LUIObject, 0, "LUISprite.LUISprite", false, false);
            Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "LUISprite.LUISprite", false, false);
            if (param0_this != nullptr && param1_this != nullptr) {
              // Pre-initialize self for the constructor
              PyObject *self = Dtool_new_LUISprite(&Dtool_LUISprite._PyType, nullptr, nullptr);
              LUISprite *return_value = new LUISprite(self, param0_this, param1_this);
              PyObject_Del(self);
              if (return_value == nullptr) {
                PyErr_NoMemory();
                return false;
              }
              return_value->ref();
              if (_PyErr_OCCURRED()) {
                unref_delete(return_value);
                return false;
              } else {
                coerced = std::move(return_value);
                return true;
              }
            }
          }
          PyErr_Clear();
        }

        {
          // -2 LUISprite::LUISprite(PyObject *self, LUIObject *parent, std::string const &image, float x, float y, float w, float h, LColor const &color)
          PyObject *param0;
          const char *param1_str = nullptr;
          Py_ssize_t param1_len;
          if (PyArg_ParseTuple(args, "Os#:LUISprite", &param0, &param1_str, &param1_len)) {
            LUIObject *param0_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LUIObject, 0, "LUISprite.LUISprite", false, false);
            if (param0_this != nullptr) {
              // Pre-initialize self for the constructor
              PyObject *self = Dtool_new_LUISprite(&Dtool_LUISprite._PyType, nullptr, nullptr);
              LUISprite *return_value = new LUISprite(self, param0_this, std::string(param1_str, param1_len));
              PyObject_Del(self);
              if (return_value == nullptr) {
                PyErr_NoMemory();
                return false;
              }
              return_value->ref();
              if (_PyErr_OCCURRED()) {
                unref_delete(return_value);
                return false;
              } else {
                coerced = std::move(return_value);
                return true;
              }
            }
          }
          PyErr_Clear();
        }

        break;
      }
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8: {
        {
          // -2 LUISprite::LUISprite(PyObject *self, LUIObject *parent, std::string const &entry_id, std::string const &atlas_id, float x = 0.0, float y = 0.0, float w = 0.0, float h = 0.0, LColor const &color = LColor(1))
          PyObject *param0;
          const char *param1_str = nullptr;
          Py_ssize_t param1_len;
          const char *param2_str = nullptr;
          Py_ssize_t param2_len;
          float param3 = 0.0;
          float param4 = 0.0;
          float param5 = 0.0;
          float param6 = 0.0;
          PyObject *param7 = nullptr;
          if (PyArg_ParseTuple(args, "Os#s#|ffffO:LUISprite", &param0, &param1_str, &param1_len, &param2_str, &param2_len, &param3, &param4, &param5, &param6, &param7)) {
            LUIObject *param0_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LUIObject, 0, "LUISprite.LUISprite", false, false);
            LColor const *param7_this;
            const LVecBase4f &param7_ref = LColor(1);
            if (param7 == nullptr) {
              param7_this = &param7_ref;
            } else {
              param7_this = nullptr;
              DtoolInstance_GetPointer(param7, param7_this, *Dtool_Ptr_LVecBase4f);
            }
            if (param0_this != nullptr && (param7 == nullptr || param7_this != nullptr)) {
              // Pre-initialize self for the constructor
              PyObject *self = Dtool_new_LUISprite(&Dtool_LUISprite._PyType, nullptr, nullptr);
              LUISprite *return_value = new LUISprite(self, param0_this, std::string(param1_str, param1_len), std::string(param2_str, param2_len), (float)param3, (float)param4, (float)param5, (float)param6, *param7_this);
              PyObject_Del(self);
              if (return_value == nullptr) {
                PyErr_NoMemory();
                return false;
              }
              return_value->ref();
              if (_PyErr_OCCURRED()) {
                unref_delete(return_value);
                return false;
              } else {
                coerced = std::move(return_value);
                return true;
              }
            }
          }
          PyErr_Clear();
        }

        {
          // -2 LUISprite::LUISprite(PyObject *self, LUIObject *parent, Texture *texture, float x = 0.0, float y = 0.0, float w = 0.0, float h = 0.0, LColor const &color = LColor(1))
          PyObject *param0;
          PyObject *param1;
          float param2;
          float param3 = 0.0;
          float param4 = 0.0;
          float param5 = 0.0;
          PyObject *param6 = nullptr;
          if (PyArg_ParseTuple(args, "OOf|fffO:LUISprite", &param0, &param1, &param2, &param3, &param4, &param5, &param6)) {
            LUIObject *param0_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LUIObject, 0, "LUISprite.LUISprite", false, false);
            Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "LUISprite.LUISprite", false, false);
            LColor const *param6_this;
            const LVecBase4f &param6_ref = LColor(1);
            if (param6 == nullptr) {
              param6_this = &param6_ref;
            } else {
              param6_this = nullptr;
              DtoolInstance_GetPointer(param6, param6_this, *Dtool_Ptr_LVecBase4f);
            }
            if (param0_this != nullptr && param1_this != nullptr && (param6 == nullptr || param6_this != nullptr)) {
              // Pre-initialize self for the constructor
              PyObject *self = Dtool_new_LUISprite(&Dtool_LUISprite._PyType, nullptr, nullptr);
              LUISprite *return_value = new LUISprite(self, param0_this, param1_this, (float)param2, (float)param3, (float)param4, (float)param5, *param6_this);
              PyObject_Del(self);
              if (return_value == nullptr) {
                PyErr_NoMemory();
                return false;
              }
              return_value->ref();
              if (_PyErr_OCCURRED()) {
                unref_delete(return_value);
                return false;
              } else {
                coerced = std::move(return_value);
                return true;
              }
            }
          }
          PyErr_Clear();
        }

        {
          // -2 LUISprite::LUISprite(PyObject *self, LUIObject *parent, std::string const &image, float x = 0.0, float y = 0.0, float w = 0.0, float h = 0.0, LColor const &color = LColor(1))
          PyObject *param0;
          const char *param1_str = nullptr;
          Py_ssize_t param1_len;
          float param2;
          float param3 = 0.0;
          float param4 = 0.0;
          float param5 = 0.0;
          PyObject *param6 = nullptr;
          if (PyArg_ParseTuple(args, "Os#f|fffO:LUISprite", &param0, &param1_str, &param1_len, &param2, &param3, &param4, &param5, &param6)) {
            LUIObject *param0_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LUIObject, 0, "LUISprite.LUISprite", false, false);
            LColor const *param6_this;
            const LVecBase4f &param6_ref = LColor(1);
            if (param6 == nullptr) {
              param6_this = &param6_ref;
            } else {
              param6_this = nullptr;
              DtoolInstance_GetPointer(param6, param6_this, *Dtool_Ptr_LVecBase4f);
            }
            if (param0_this != nullptr && (param6 == nullptr || param6_this != nullptr)) {
              // Pre-initialize self for the constructor
              PyObject *self = Dtool_new_LUISprite(&Dtool_LUISprite._PyType, nullptr, nullptr);
              LUISprite *return_value = new LUISprite(self, param0_this, std::string(param1_str, param1_len), (float)param2, (float)param3, (float)param4, (float)param5, *param6_this);
              PyObject_Del(self);
              if (return_value == nullptr) {
                PyErr_NoMemory();
                return false;
              }
              return_value->ref();
              if (_PyErr_OCCURRED()) {
                unref_delete(return_value);
                return false;
              } else {
                coerced = std::move(return_value);
                return true;
              }
            }
          }
          PyErr_Clear();
        }

        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_LUISprite(PyObject *args, PT(LUISprite) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_LUISprite)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        {
          // -2 LUISprite::LUISprite(PyObject *self, LUIObject *parent, Texture *texture, float x, float y, float w, float h, LColor const &color)
          PyObject *param0;
          PyObject *param1;
          if (PyArg_UnpackTuple(args, "LUISprite", 2, 2, &param0, &param1)) {
            LUIObject *param0_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LUIObject, 0, "LUISprite.LUISprite", false, false);
            Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "LUISprite.LUISprite", false, false);
            if (param0_this != nullptr && param1_this != nullptr) {
              // Pre-initialize self for the constructor
              PyObject *self = Dtool_new_LUISprite(&Dtool_LUISprite._PyType, nullptr, nullptr);
              LUISprite *return_value = new LUISprite(self, param0_this, param1_this);
              PyObject_Del(self);
              if (return_value == nullptr) {
                PyErr_NoMemory();
                return false;
              }
              return_value->ref();
              if (_PyErr_OCCURRED()) {
                unref_delete(return_value);
                return false;
              } else {
                coerced = std::move(return_value);
                return true;
              }
            }
          }
          PyErr_Clear();
        }

        {
          // -2 LUISprite::LUISprite(PyObject *self, LUIObject *parent, std::string const &image, float x, float y, float w, float h, LColor const &color)
          PyObject *param0;
          const char *param1_str = nullptr;
          Py_ssize_t param1_len;
          if (PyArg_ParseTuple(args, "Os#:LUISprite", &param0, &param1_str, &param1_len)) {
            LUIObject *param0_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LUIObject, 0, "LUISprite.LUISprite", false, false);
            if (param0_this != nullptr) {
              // Pre-initialize self for the constructor
              PyObject *self = Dtool_new_LUISprite(&Dtool_LUISprite._PyType, nullptr, nullptr);
              LUISprite *return_value = new LUISprite(self, param0_this, std::string(param1_str, param1_len));
              PyObject_Del(self);
              if (return_value == nullptr) {
                PyErr_NoMemory();
                return false;
              }
              return_value->ref();
              if (_PyErr_OCCURRED()) {
                unref_delete(return_value);
                return false;
              } else {
                coerced = std::move(return_value);
                return true;
              }
            }
          }
          PyErr_Clear();
        }

        break;
      }
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8: {
        {
          // -2 LUISprite::LUISprite(PyObject *self, LUIObject *parent, std::string const &entry_id, std::string const &atlas_id, float x = 0.0, float y = 0.0, float w = 0.0, float h = 0.0, LColor const &color = LColor(1))
          PyObject *param0;
          const char *param1_str = nullptr;
          Py_ssize_t param1_len;
          const char *param2_str = nullptr;
          Py_ssize_t param2_len;
          float param3 = 0.0;
          float param4 = 0.0;
          float param5 = 0.0;
          float param6 = 0.0;
          PyObject *param7 = nullptr;
          if (PyArg_ParseTuple(args, "Os#s#|ffffO:LUISprite", &param0, &param1_str, &param1_len, &param2_str, &param2_len, &param3, &param4, &param5, &param6, &param7)) {
            LUIObject *param0_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LUIObject, 0, "LUISprite.LUISprite", false, false);
            LColor const *param7_this;
            const LVecBase4f &param7_ref = LColor(1);
            if (param7 == nullptr) {
              param7_this = &param7_ref;
            } else {
              param7_this = nullptr;
              DtoolInstance_GetPointer(param7, param7_this, *Dtool_Ptr_LVecBase4f);
            }
            if (param0_this != nullptr && (param7 == nullptr || param7_this != nullptr)) {
              // Pre-initialize self for the constructor
              PyObject *self = Dtool_new_LUISprite(&Dtool_LUISprite._PyType, nullptr, nullptr);
              LUISprite *return_value = new LUISprite(self, param0_this, std::string(param1_str, param1_len), std::string(param2_str, param2_len), (float)param3, (float)param4, (float)param5, (float)param6, *param7_this);
              PyObject_Del(self);
              if (return_value == nullptr) {
                PyErr_NoMemory();
                return false;
              }
              return_value->ref();
              if (_PyErr_OCCURRED()) {
                unref_delete(return_value);
                return false;
              } else {
                coerced = std::move(return_value);
                return true;
              }
            }
          }
          PyErr_Clear();
        }

        {
          // -2 LUISprite::LUISprite(PyObject *self, LUIObject *parent, Texture *texture, float x = 0.0, float y = 0.0, float w = 0.0, float h = 0.0, LColor const &color = LColor(1))
          PyObject *param0;
          PyObject *param1;
          float param2;
          float param3 = 0.0;
          float param4 = 0.0;
          float param5 = 0.0;
          PyObject *param6 = nullptr;
          if (PyArg_ParseTuple(args, "OOf|fffO:LUISprite", &param0, &param1, &param2, &param3, &param4, &param5, &param6)) {
            LUIObject *param0_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LUIObject, 0, "LUISprite.LUISprite", false, false);
            Texture *param1_this = (Texture *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_Texture, 1, "LUISprite.LUISprite", false, false);
            LColor const *param6_this;
            const LVecBase4f &param6_ref = LColor(1);
            if (param6 == nullptr) {
              param6_this = &param6_ref;
            } else {
              param6_this = nullptr;
              DtoolInstance_GetPointer(param6, param6_this, *Dtool_Ptr_LVecBase4f);
            }
            if (param0_this != nullptr && param1_this != nullptr && (param6 == nullptr || param6_this != nullptr)) {
              // Pre-initialize self for the constructor
              PyObject *self = Dtool_new_LUISprite(&Dtool_LUISprite._PyType, nullptr, nullptr);
              LUISprite *return_value = new LUISprite(self, param0_this, param1_this, (float)param2, (float)param3, (float)param4, (float)param5, *param6_this);
              PyObject_Del(self);
              if (return_value == nullptr) {
                PyErr_NoMemory();
                return false;
              }
              return_value->ref();
              if (_PyErr_OCCURRED()) {
                unref_delete(return_value);
                return false;
              } else {
                coerced = std::move(return_value);
                return true;
              }
            }
          }
          PyErr_Clear();
        }

        {
          // -2 LUISprite::LUISprite(PyObject *self, LUIObject *parent, std::string const &image, float x = 0.0, float y = 0.0, float w = 0.0, float h = 0.0, LColor const &color = LColor(1))
          PyObject *param0;
          const char *param1_str = nullptr;
          Py_ssize_t param1_len;
          float param2;
          float param3 = 0.0;
          float param4 = 0.0;
          float param5 = 0.0;
          PyObject *param6 = nullptr;
          if (PyArg_ParseTuple(args, "Os#f|fffO:LUISprite", &param0, &param1_str, &param1_len, &param2, &param3, &param4, &param5, &param6)) {
            LUIObject *param0_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LUIObject, 0, "LUISprite.LUISprite", false, false);
            LColor const *param6_this;
            const LVecBase4f &param6_ref = LColor(1);
            if (param6 == nullptr) {
              param6_this = &param6_ref;
            } else {
              param6_this = nullptr;
              DtoolInstance_GetPointer(param6, param6_this, *Dtool_Ptr_LVecBase4f);
            }
            if (param0_this != nullptr && (param6 == nullptr || param6_this != nullptr)) {
              // Pre-initialize self for the constructor
              PyObject *self = Dtool_new_LUISprite(&Dtool_LUISprite._PyType, nullptr, nullptr);
              LUISprite *return_value = new LUISprite(self, param0_this, std::string(param1_str, param1_len), (float)param2, (float)param3, (float)param4, (float)param5, *param6_this);
              PyObject_Del(self);
              if (return_value == nullptr) {
                PyErr_NoMemory();
                return false;
              }
              return_value->ref();
              if (_PyErr_OCCURRED()) {
                unref_delete(return_value);
                return false;
              } else {
                coerced = std::move(return_value);
                return true;
              }
            }
          }
          PyErr_Clear();
        }

        break;
      }
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_LUISprite(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LUISprite) {
    printf("LUISprite ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LUISprite *local_this = (LUISprite *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LUISprite) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LUIBaseElement) {
    return (LUIBaseElement *) local_this;
  }
  if (requested_type == Dtool_Ptr_LUIColorable) {
    return (LUIColorable *)(LUIBaseElement *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(LUIBaseElement *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(LUIBaseElement *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(LUIBaseElement *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LUISprite(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LUISprite) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LUIBaseElement) {
    LUIBaseElement* other_this = (LUIBaseElement*)from_this;
    return (LUISprite*)other_this;
  }
  if (from_type == Dtool_Ptr_LUIColorable) {
    LUIColorable* other_this = (LUIColorable*)from_this;
    return (LUISprite*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LUISprite*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LUISprite*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LUISprite*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LUIElementIterator
 */
/**
 * Python function wrapper for:
 * inline LUIElementIterator::LUIElementIterator(LUIElementIterator const &) = default
 */
static int Dtool_Init_LUIElementIterator(PyObject *self, PyObject *args, PyObject *kwds) {
  if (kwds != nullptr && PyDict_Size(kwds) > 0) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes no keyword arguments");
    return -1;
#else
    Dtool_Raise_TypeError("LUIElementIterator() takes no keyword arguments");
    return -1;
#endif
  }
  // 1-inline LUIElementIterator::LUIElementIterator(LUIElementIterator const &) = default
  PyObject *param0;
  if (PyTuple_GET_SIZE(args) == 1) {
    param0 = PyTuple_GET_ITEM(args, 0);
    LUIElementIterator const *param0_this = (LUIElementIterator *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LUIElementIterator, 0, "LUIElementIterator.LUIElementIterator", true, true);
    if (param0_this != nullptr) {
      LUIElementIterator *return_value = new LUIElementIterator(*param0_this);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIElementIterator, true, false);
    }
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LUIElementIterator(const LUIElementIterator param0)\n");
  }
  return -1;
}

static void *Dtool_UpcastInterface_LUIElementIterator(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LUIElementIterator) {
    printf("LUIElementIterator ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LUIElementIterator *local_this = (LUIElementIterator *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LUIElementIterator) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LUIElementIterator(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LUIElementIterator) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LUIElementIterator*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LUIRoot
 */
/**
 * Python function wrapper for:
 * inline PointerTo< LUIObject > LUIRoot::node(void)
 */
static PyObject *Dtool_LUIRoot_node_249(PyObject *self, PyObject *) {
  LUIRoot *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIRoot, (void **)&local_this, "LUIRoot.node")) {
    return nullptr;
  }
  // 1-inline PointerTo< LUIObject > LUIRoot::node(void)
  PointerTo< LUIObject > return_value = ((*local_this).node)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  LUIObject *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_LUIObject, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LUIRoot_node_249_comment =
  "C++ Interface:\n"
  "node(const LUIRoot self)\n";
#else
static const char *Dtool_LUIRoot_node_249_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static inline void LUIRoot::set_use_glsl_130(bool use_glsl_130)
 */
static PyObject *Dtool_LUIRoot_set_use_glsl_130_250(PyObject *, PyObject *arg) {
  // 1-static inline void LUIRoot::set_use_glsl_130(bool use_glsl_130)
  (LUIRoot::set_use_glsl_130)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_use_glsl_130(bool use_glsl_130)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIRoot_set_use_glsl_130_250_comment =
  "C++ Interface:\n"
  "set_use_glsl_130(bool use_glsl_130)\n"
  "\n"
  "/**\n"
  " * @brief Sets whether to use GLSL 1.30 instead of 1.20\n"
  " * @details This controls whether GLSL 1.30 is used instead of 1.20. It can\n"
  " *   provide a performance benefit although it also bumps the OpenGL requirement.\n"
  " *\n"
  " * @param use_glsl_130 Whether to use GLSL 1.30\n"
  " */";
#else
static const char *Dtool_LUIRoot_set_use_glsl_130_250_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LUIRoot::LUIRoot(LUIRoot const &) = default
 * LUIRoot::LUIRoot(float width, float height)
 */
static int Dtool_Init_LUIRoot(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    if (kwds == nullptr || PyDict_GET_SIZE(kwds) == 0) {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      // 1-inline LUIRoot::LUIRoot(LUIRoot const &) = default
      CPT(LUIRoot) arg_this;
      if (!Dtool_ConstCoerce_LUIRoot(arg, arg_this)) {
        Dtool_Raise_ArgTypeError(arg, 0, "LUIRoot.LUIRoot", "LUIRoot");
        return -1;
      }
      LUIRoot *return_value = new LUIRoot(*std::move(arg_this));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIRoot, true, false);
    }
    break;
  case 2:
    {
      // 1-LUIRoot::LUIRoot(float width, float height)
      float param0;
      float param1;
      static const char *keyword_list[] = {"width", "height", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "ff:LUIRoot", (char **)keyword_list, &param0, &param1)) {
        LUIRoot *return_value = new LUIRoot((float)param0, (float)param1);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIRoot, true, false);
      }
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LUIRoot() takes 1 or 2 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LUIRoot(const LUIRoot param0)\n"
      "LUIRoot(float width, float height)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_LUIRoot(PyObject *args, CPT(LUIRoot) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_LUIRoot)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-LUIRoot::LUIRoot(float width, float height)
      float param0;
      float param1;
      if (PyArg_ParseTuple(args, "ff:LUIRoot", &param0, &param1)) {
        LUIRoot *return_value = new LUIRoot((float)param0, (float)param1);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = std::move(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_LUIRoot(PyObject *args, PT(LUIRoot) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_LUIRoot)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-LUIRoot::LUIRoot(float width, float height)
      float param0;
      float param1;
      if (PyArg_ParseTuple(args, "ff:LUIRoot", &param0, &param1)) {
        LUIRoot *return_value = new LUIRoot((float)param0, (float)param1);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return false;
        }
        return_value->ref();
        if (_PyErr_OCCURRED()) {
          unref_delete(return_value);
          return false;
        } else {
          coerced = std::move(return_value);
          return true;
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_LUIRoot(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LUIRoot) {
    printf("LUIRoot ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LUIRoot *local_this = (LUIRoot *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LUIRoot) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LUIRoot(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LUIRoot) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LUIRoot*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LUIInputHandler
 */
/**
 * Python function wrapper for:
 * static TypeHandle LUIInputHandler::get_class_type(void)
 */
static PyObject *Dtool_LUIInputHandler_get_class_type_254(PyObject *, PyObject *) {
  // 1-static TypeHandle LUIInputHandler::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LUIInputHandler::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LUIInputHandler_get_class_type_254_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LUIInputHandler_get_class_type_254_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LUIInputHandler::LUIInputHandler(LUIInputHandler const &) = default
 * LUIInputHandler::LUIInputHandler(std::string const &name = string())
 */
static int Dtool_Init_LUIInputHandler(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 0:
    {
      // 1-LUIInputHandler::LUIInputHandler(std::string const &name)
      LUIInputHandler *return_value = new LUIInputHandler();
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIInputHandler, true, false);
    }
    break;
  case 1:
    {
      {
        // -2 inline LUIInputHandler::LUIInputHandler(LUIInputHandler const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          LUIInputHandler const *param0_this = nullptr;
          DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LUIInputHandler);
          if (param0_this != nullptr) {
            LUIInputHandler *return_value = new LUIInputHandler(*param0_this);
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIInputHandler, true, false);
          }
        }
      }

      {
        // -2 LUIInputHandler::LUIInputHandler(std::string const &name)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        static const char *keyword_list[] = {"name", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "s#:LUIInputHandler", (char **)keyword_list, &param0_str, &param0_len)) {
          LUIInputHandler *return_value = new LUIInputHandler(std::string(param0_str, param0_len));
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return -1;
          }
          return_value->ref();
          if (Dtool_CheckErrorOccurred()) {
            unref_delete(return_value);
            return -1;
          }
          return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIInputHandler, true, false);
        }
        PyErr_Clear();
      }

      {
        // -2 inline LUIInputHandler::LUIInputHandler(LUIInputHandler const &) = default
        PyObject *param0;
        if (Dtool_ExtractArg(&param0, args, kwds)) {
          CPT(LUIInputHandler) param0_this;
          if (Dtool_ConstCoerce_LUIInputHandler(param0, param0_this)) {
            LUIInputHandler *return_value = new LUIInputHandler(*std::move(param0_this));
            if (return_value == nullptr) {
              PyErr_NoMemory();
              return -1;
            }
            return_value->ref();
            if (Dtool_CheckErrorOccurred()) {
              unref_delete(return_value);
              return -1;
            }
            return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIInputHandler, true, false);
          }
        }
      }

      // No coercion possible: LUIInputHandler::LUIInputHandler(std::string const &name)
    }
    break;
#ifndef NDEBUG
  default:
    PyErr_Format(PyExc_TypeError,
                 "LUIInputHandler() takes 0 or 1 arguments (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LUIInputHandler()\n"
      "LUIInputHandler(const LUIInputHandler param0)\n"
      "LUIInputHandler(str name)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_LUIInputHandler(PyObject *args, CPT(LUIInputHandler) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_LUIInputHandler)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-LUIInputHandler::LUIInputHandler(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      LUIInputHandler *return_value = new LUIInputHandler(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

bool Dtool_Coerce_LUIInputHandler(PyObject *args, PT(LUIInputHandler) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_LUIInputHandler)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-LUIInputHandler::LUIInputHandler(std::string const &name)
    const char *param0_str = nullptr;
    Py_ssize_t param0_len;
#if PY_MAJOR_VERSION >= 3
    param0_str = PyUnicode_AsUTF8AndSize(arg, &param0_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param0_str, &param0_len) == -1) {
      param0_str = nullptr;
    }
#endif
    if (param0_str != nullptr) {
      LUIInputHandler *return_value = new LUIInputHandler(std::string(param0_str, param0_len));
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
    PyErr_Clear();
  }
  return false;
}

static void *Dtool_UpcastInterface_LUIInputHandler(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LUIInputHandler) {
    printf("LUIInputHandler ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LUIInputHandler *local_this = (LUIInputHandler *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LUIInputHandler) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DataNode) {
    return (DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_Namable) {
    return (Namable *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_PandaNode) {
    return (PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritable) {
    return (TypedWritable *)(TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedWritableReferenceCount) {
    return (TypedWritableReferenceCount *)(PandaNode *)(DataNode *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LUIInputHandler(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LUIInputHandler) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DataNode) {
    DataNode* other_this = (DataNode*)from_this;
    return (LUIInputHandler*)other_this;
  }
  if (from_type == Dtool_Ptr_Namable) {
    Namable* other_this = (Namable*)from_this;
    return (LUIInputHandler*)other_this;
  }
  if (from_type == Dtool_Ptr_PandaNode) {
    PandaNode* other_this = (PandaNode*)from_this;
    return (LUIInputHandler*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LUIInputHandler*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LUIInputHandler*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritable) {
    TypedWritable* other_this = (TypedWritable*)from_this;
    return (LUIInputHandler*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedWritableReferenceCount) {
    TypedWritableReferenceCount* other_this = (TypedWritableReferenceCount*)from_this;
    return (LUIInputHandler*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LUIRegion
 */
/**
 * Python function wrapper for:
 * static inline LUIRegion *LUIRegion::make(std::string const &context_name, GraphicsOutput *window)
 * static inline LUIRegion *LUIRegion::make(std::string const &context_name, GraphicsOutput *window, LVecBase4 const &dimensions)
 */
static PyObject *Dtool_LUIRegion_make_257(PyObject *, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 2:
    {
      // 1-static inline LUIRegion *LUIRegion::make(std::string const &context_name, GraphicsOutput *window)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      PyObject *param1;
      static const char *keyword_list[] = {"context_name", "window", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:make", (char **)keyword_list, &param0_str, &param0_len, &param1)) {
        GraphicsOutput *param1_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GraphicsOutput, 1, "LUIRegion.make", false, true);
        if (param1_this != nullptr) {
          LUIRegion *return_value = (LUIRegion::make)(std::string(param0_str, param0_len), param1_this);
          if (return_value != nullptr) {
            return_value->ref();
          }
          if (Dtool_CheckErrorOccurred()) {
            if (return_value != nullptr) {
              unref_delete(return_value);
            }
            return nullptr;
          }
          if (return_value == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_LUIRegion, true, false, return_value->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
  case 3:
    {
      // 1-static inline LUIRegion *LUIRegion::make(std::string const &context_name, GraphicsOutput *window, LVecBase4 const &dimensions)
      const char *param0_str = nullptr;
      Py_ssize_t param0_len;
      PyObject *param1;
      PyObject *param2;
      static const char *keyword_list[] = {"context_name", "window", "dimensions", nullptr};
      if (PyArg_ParseTupleAndKeywords(args, kwds, "s#OO:make", (char **)keyword_list, &param0_str, &param0_len, &param1, &param2)) {
        GraphicsOutput *param1_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GraphicsOutput, 1, "LUIRegion.make", false, true);
        LVecBase4f param2_local;
        LVecBase4 const *param2_this = Dtool_Coerce_LVecBase4f(param2, param2_local);
        if (!(param2_this != nullptr)) {
          return Dtool_Raise_ArgTypeError(param2, 2, "LUIRegion.make", "LVecBase4f");
        }
        if (param1_this != nullptr) {
          LUIRegion *return_value = (LUIRegion::make)(std::string(param0_str, param0_len), param1_this, *param2_this);
          if (return_value != nullptr) {
            return_value->ref();
          }
          if (Dtool_CheckErrorOccurred()) {
            if (return_value != nullptr) {
              unref_delete(return_value);
            }
            return nullptr;
          }
          if (return_value == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_LUIRegion, true, false, return_value->as_typed_object()->get_type_index());
          }
        }
      }
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "make() takes 2 or 3 arguments (%d given)",
                        parameter_count);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "make(str context_name, GraphicsOutput window)\n"
      "make(str context_name, GraphicsOutput window, const LVecBase4f dimensions)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIRegion_make_257_comment =
  "C++ Interface:\n"
  "make(str context_name, GraphicsOutput window)\n"
  "make(str context_name, GraphicsOutput window, const LVecBase4f dimensions)\n";
#else
static const char *Dtool_LUIRegion_make_257_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LUIObject *LUIRegion::get_root(void) const
 */
static PyObject *Dtool_LUIRegion_get_root_258(PyObject *self, PyObject *) {
  LUIRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIRegion)) {
    return nullptr;
  }
  // 1-inline LUIObject *LUIRegion::get_root(void) const
  LUIObject *return_value = ((*(const LUIRegion*)local_this).get_root)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_LUIObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LUIRegion_get_root_258_comment =
  "C++ Interface:\n"
  "get_root(LUIRegion self)\n";
#else
static const char *Dtool_LUIRegion_get_root_258_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIRegion::set_input_handler(LUIInputHandler *handler)
 */
static PyObject *Dtool_LUIRegion_set_input_handler_260(PyObject *self, PyObject *arg) {
  LUIRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIRegion, (void **)&local_this, "LUIRegion.set_input_handler")) {
    return nullptr;
  }
  // 1-inline void LUIRegion::set_input_handler(LUIInputHandler *handler)
  PT(LUIInputHandler) arg_this;
  if (!Dtool_Coerce_LUIInputHandler(arg, arg_this)) {
    return Dtool_Raise_ArgTypeError(arg, 1, "LUIRegion.set_input_handler", "LUIInputHandler");
  }
  ((*local_this).set_input_handler)(std::move(arg_this));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_input_handler(const LUIRegion self, LUIInputHandler handler)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIRegion_set_input_handler_260_comment =
  "C++ Interface:\n"
  "set_input_handler(const LUIRegion self, LUIInputHandler handler)\n";
#else
static const char *Dtool_LUIRegion_set_input_handler_260_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LUIInputHandler *LUIRegion::get_input_handler(void) const
 */
static PyObject *Dtool_LUIRegion_get_input_handler_261(PyObject *self, PyObject *) {
  LUIRegion *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIRegion)) {
    return nullptr;
  }
  // 1-inline LUIInputHandler *LUIRegion::get_input_handler(void) const
  LUIInputHandler *return_value = ((*(const LUIRegion*)local_this).get_input_handler)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_LUIInputHandler, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LUIRegion_get_input_handler_261_comment =
  "C++ Interface:\n"
  "get_input_handler(LUIRegion self)\n";
#else
static const char *Dtool_LUIRegion_get_input_handler_261_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIRegion::set_render_wireframe(bool wireframe)
 */
static PyObject *Dtool_LUIRegion_set_render_wireframe_262(PyObject *self, PyObject *arg) {
  LUIRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIRegion, (void **)&local_this, "LUIRegion.set_render_wireframe")) {
    return nullptr;
  }
  // 1-inline void LUIRegion::set_render_wireframe(bool wireframe)
  ((*local_this).set_render_wireframe)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_render_wireframe(const LUIRegion self, bool wireframe)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIRegion_set_render_wireframe_262_comment =
  "C++ Interface:\n"
  "set_render_wireframe(const LUIRegion self, bool wireframe)\n";
#else
static const char *Dtool_LUIRegion_set_render_wireframe_262_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIRegion::toggle_render_wireframe(void)
 */
static PyObject *Dtool_LUIRegion_toggle_render_wireframe_263(PyObject *self, PyObject *) {
  LUIRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIRegion, (void **)&local_this, "LUIRegion.toggle_render_wireframe")) {
    return nullptr;
  }
  // 1-inline void LUIRegion::toggle_render_wireframe(void)
  ((*local_this).toggle_render_wireframe)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LUIRegion_toggle_render_wireframe_263_comment =
  "C++ Interface:\n"
  "toggle_render_wireframe(const LUIRegion self)\n";
#else
static const char *Dtool_LUIRegion_toggle_render_wireframe_263_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LUIRegion::get_class_type(void)
 */
static PyObject *Dtool_LUIRegion_get_class_type_264(PyObject *, PyObject *) {
  // 1-static TypeHandle LUIRegion::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LUIRegion::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LUIRegion_get_class_type_264_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LUIRegion_get_class_type_264_comment = nullptr;
#endif

static PyObject *Dtool_LUIRegion_root_Getter(PyObject *self, void *) {
  const LUIRegion *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIRegion, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LUIObject *LUIRegion::get_root(void) const
  LUIObject *return_value = ((*(const LUIRegion*)local_this).get_root)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_LUIObject, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_Init_LUIRegion(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

bool Dtool_ConstCoerce_LUIRegion(PyObject *args, CPT(LUIRegion) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_LUIRegion)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-static inline LUIRegion *LUIRegion::make(std::string const &context_name, GraphicsOutput *window)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        PyObject *param1;
        if (PyArg_ParseTuple(args, "s#O:make", &param0_str, &param0_len, &param1)) {
          GraphicsOutput *param1_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GraphicsOutput, 1, "LUIRegion.make", false, false);
          if (param1_this != nullptr) {
            LUIRegion *return_value = (LUIRegion::make)(std::string(param0_str, param0_len), param1_this);
            if (return_value != nullptr) {
              return_value->ref();
            }
            if (_PyErr_OCCURRED()) {
              if (return_value != nullptr) {
                unref_delete(return_value);
              }
              return false;
            } else {
              coerced = std::move(DCAST(LUIRegion, return_value));
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-static inline LUIRegion *LUIRegion::make(std::string const &context_name, GraphicsOutput *window, LVecBase4 const &dimensions)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        PyObject *param1;
        PyObject *param2;
        if (PyArg_ParseTuple(args, "s#OO:make", &param0_str, &param0_len, &param1, &param2)) {
          GraphicsOutput *param1_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GraphicsOutput, 1, "LUIRegion.make", false, false);
          LVecBase4 const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVecBase4f);
          if (param1_this != nullptr && param2_this != nullptr) {
            LUIRegion *return_value = (LUIRegion::make)(std::string(param0_str, param0_len), param1_this, *param2_this);
            if (return_value != nullptr) {
              return_value->ref();
            }
            if (_PyErr_OCCURRED()) {
              if (return_value != nullptr) {
                unref_delete(return_value);
              }
              return false;
            } else {
              coerced = std::move(DCAST(LUIRegion, return_value));
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

bool Dtool_Coerce_LUIRegion(PyObject *args, PT(LUIRegion) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_LUIRegion)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    switch (PyTuple_GET_SIZE(args)) {
      case 2: {
        // 1-static inline LUIRegion *LUIRegion::make(std::string const &context_name, GraphicsOutput *window)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        PyObject *param1;
        if (PyArg_ParseTuple(args, "s#O:make", &param0_str, &param0_len, &param1)) {
          GraphicsOutput *param1_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GraphicsOutput, 1, "LUIRegion.make", false, false);
          if (param1_this != nullptr) {
            LUIRegion *return_value = (LUIRegion::make)(std::string(param0_str, param0_len), param1_this);
            if (return_value != nullptr) {
              return_value->ref();
            }
            if (_PyErr_OCCURRED()) {
              if (return_value != nullptr) {
                unref_delete(return_value);
              }
              return false;
            } else {
              coerced = std::move(DCAST(LUIRegion, return_value));
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
      case 3: {
        // 1-static inline LUIRegion *LUIRegion::make(std::string const &context_name, GraphicsOutput *window, LVecBase4 const &dimensions)
        const char *param0_str = nullptr;
        Py_ssize_t param0_len;
        PyObject *param1;
        PyObject *param2;
        if (PyArg_ParseTuple(args, "s#OO:make", &param0_str, &param0_len, &param1, &param2)) {
          GraphicsOutput *param1_this = (GraphicsOutput *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_GraphicsOutput, 1, "LUIRegion.make", false, false);
          LVecBase4 const *param2_this = nullptr;
          DtoolInstance_GetPointer(param2, param2_this, *Dtool_Ptr_LVecBase4f);
          if (param1_this != nullptr && param2_this != nullptr) {
            LUIRegion *return_value = (LUIRegion::make)(std::string(param0_str, param0_len), param1_this, *param2_this);
            if (return_value != nullptr) {
              return_value->ref();
            }
            if (_PyErr_OCCURRED()) {
              if (return_value != nullptr) {
                unref_delete(return_value);
              }
              return false;
            } else {
              coerced = std::move(DCAST(LUIRegion, return_value));
              return true;
            }
          }
        }
        PyErr_Clear();
        break;
      }
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_LUIRegion(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LUIRegion) {
    printf("LUIRegion ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LUIRegion *local_this = (LUIRegion *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LUIRegion) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_DisplayRegion) {
    return (DisplayRegion *) local_this;
  }
  if (requested_type == Dtool_Ptr_DrawableRegion) {
    return (DrawableRegion *)(DisplayRegion *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(DisplayRegion *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(DisplayRegion *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(DisplayRegion *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LUIRegion(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LUIRegion) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_DisplayRegion) {
    DisplayRegion* other_this = (DisplayRegion*)from_this;
    return (LUIRegion*)other_this;
  }
  if (from_type == Dtool_Ptr_DrawableRegion) {
    DrawableRegion* other_this = (DrawableRegion*)from_this;
    return (LUIRegion*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LUIRegion*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LUIRegion*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LUIRegion*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LUIFontPool
 */
/**
 * Python function wrapper for:
 * static LUIFontPool *LUIFontPool::get_global_ptr(void)
 */
static PyObject *Dtool_LUIFontPool_get_global_ptr_266(PyObject *, PyObject *) {
  // 1-static LUIFontPool *LUIFontPool::get_global_ptr(void)
  LUIFontPool *return_value = (LUIFontPool::get_global_ptr)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LUIFontPool, false, false);
}

#ifndef NDEBUG
static const char *Dtool_LUIFontPool_get_global_ptr_266_comment =
  "C++ Interface:\n"
  "get_global_ptr()\n";
#else
static const char *Dtool_LUIFontPool_get_global_ptr_266_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LUIFontPool::load_font(std::string const &name, std::string const &font_file)
 */
static PyObject *Dtool_LUIFontPool_load_font_267(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIFontPool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIFontPool, (void **)&local_this, "LUIFontPool.load_font")) {
    return nullptr;
  }
  // 1-void LUIFontPool::load_font(std::string const &name, std::string const &font_file)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  const char *param2_str = nullptr;
  Py_ssize_t param2_len;
  static const char *keyword_list[] = {"name", "font_file", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#s#:load_font", (char **)keyword_list, &param1_str, &param1_len, &param2_str, &param2_len)) {
    ((*local_this).load_font)(std::string(param1_str, param1_len), std::string(param2_str, param2_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "load_font(const LUIFontPool self, str name, str font_file)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIFontPool_load_font_267_comment =
  "C++ Interface:\n"
  "load_font(const LUIFontPool self, str name, str font_file)\n";
#else
static const char *Dtool_LUIFontPool_load_font_267_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LUIFontPool::register_font(std::string const &name, PointerTo< DynamicTextFont > font)
 */
static PyObject *Dtool_LUIFontPool_register_font_268(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIFontPool *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIFontPool, (void **)&local_this, "LUIFontPool.register_font")) {
    return nullptr;
  }
  // 1-void LUIFontPool::register_font(std::string const &name, PointerTo< DynamicTextFont > font)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
  PyObject *param2;
  static const char *keyword_list[] = {"name", "font", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "s#O:register_font", (char **)keyword_list, &param1_str, &param1_len, &param2)) {
    PT(DynamicTextFont) param2_this;
    if (!Dtool_Coerce_DynamicTextFont(param2, param2_this)) {
      return Dtool_Raise_ArgTypeError(param2, 2, "LUIFontPool.register_font", "DynamicTextFont");
    }
    ((*local_this).register_font)(std::string(param1_str, param1_len), std::move(param2_this));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "register_font(const LUIFontPool self, str name, DynamicTextFont font)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIFontPool_register_font_268_comment =
  "C++ Interface:\n"
  "register_font(const LUIFontPool self, str name, DynamicTextFont font)\n";
#else
static const char *Dtool_LUIFontPool_register_font_268_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LUIFontPool::has_font(std::string const &name) const
 */
static PyObject *Dtool_LUIFontPool_has_font_269(PyObject *self, PyObject *arg) {
  LUIFontPool *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIFontPool)) {
    return nullptr;
  }
  // 1-inline bool LUIFontPool::has_font(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    bool return_value = ((*(const LUIFontPool*)local_this).has_font)(std::string(param1_str, param1_len));
    return Dtool_Return_Bool(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "has_font(LUIFontPool self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIFontPool_has_font_269_comment =
  "C++ Interface:\n"
  "has_font(LUIFontPool self, str name)\n";
#else
static const char *Dtool_LUIFontPool_has_font_269_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DynamicTextFont *LUIFontPool::get_font(std::string const &name) const
 */
static PyObject *Dtool_LUIFontPool_get_font_270(PyObject *self, PyObject *arg) {
  LUIFontPool *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIFontPool)) {
    return nullptr;
  }
  // 1-inline DynamicTextFont *LUIFontPool::get_font(std::string const &name) const
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    DynamicTextFont *return_value = ((*(const LUIFontPool*)local_this).get_font)(std::string(param1_str, param1_len));
    if (return_value != nullptr) {
      return_value->ref();
    }
    if (Dtool_CheckErrorOccurred()) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return nullptr;
    }
    if (return_value == nullptr) {
      Py_INCREF(Py_None);
      return Py_None;
    } else {
      return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DynamicTextFont, true, false, return_value->as_typed_object()->get_type_index());
    }
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_font(LUIFontPool self, str name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIFontPool_get_font_270_comment =
  "C++ Interface:\n"
  "get_font(LUIFontPool self, str name)\n";
#else
static const char *Dtool_LUIFontPool_get_font_270_comment = nullptr;
#endif

static int Dtool_Init_LUIFontPool(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_LUIFontPool(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LUIFontPool) {
    printf("LUIFontPool ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LUIFontPool *local_this = (LUIFontPool *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LUIFontPool) {
    return local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LUIFontPool(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LUIFontPool) {
    return from_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LUIText
 */
/**
 * Python function wrapper for:
 * inline void LUIText::set_font(std::string const &font_name)
 */
static PyObject *Dtool_LUIText_set_font_273(PyObject *self, PyObject *arg) {
  LUIText *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIText, (void **)&local_this, "LUIText.set_font")) {
    return nullptr;
  }
  // 1-inline void LUIText::set_font(std::string const &font_name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_font)(std::string(param1_str, param1_len));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_font(const LUIText self, str font_name)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIText_set_font_273_comment =
  "C++ Interface:\n"
  "set_font(const LUIText self, str font_name)\n";
#else
static const char *Dtool_LUIText_set_font_273_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline DynamicTextFont *LUIText::get_font(void) const
 */
static PyObject *Dtool_LUIText_get_font_274(PyObject *self, PyObject *) {
  LUIText *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIText)) {
    return nullptr;
  }
  // 1-inline DynamicTextFont *LUIText::get_font(void) const
  DynamicTextFont *return_value = ((*(const LUIText*)local_this).get_font)();
  if (return_value != nullptr) {
    return_value->ref();
  }
  if (Dtool_CheckErrorOccurred()) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DynamicTextFont, true, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LUIText_get_font_274_comment =
  "C++ Interface:\n"
  "get_font(LUIText self)\n";
#else
static const char *Dtool_LUIText_get_font_274_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIText::set_text(std::wstring const &text)
 */
static PyObject *Dtool_LUIText_set_text_275(PyObject *self, PyObject *arg) {
  LUIText *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIText, (void **)&local_this, "LUIText.set_text")) {
    return nullptr;
  }
  // 1-inline void LUIText::set_text(std::wstring const &text)
#if PY_VERSION_HEX >= 0x03020000
  PyObject *param1;
#else
  PyUnicodeObject *param1;
#endif
  if (PyArg_Parse(arg, "U:set_text", &param1)) {
#if PY_VERSION_HEX >= 0x03030000
    Py_ssize_t param1_len;
    wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
    Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
    wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
    PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
    ((*local_this).set_text)(std::wstring(param1_str, param1_len));
#if PY_VERSION_HEX >= 0x03030000
    PyMem_Free(param1_str);
#endif
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_text(const LUIText self, unicode text)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIText_set_text_275_comment =
  "C++ Interface:\n"
  "set_text(const LUIText self, unicode text)\n";
#else
static const char *Dtool_LUIText_set_text_275_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::wstring const &LUIText::get_text(void) const
 */
static PyObject *Dtool_LUIText_get_text_276(PyObject *self, PyObject *) {
  LUIText *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIText)) {
    return nullptr;
  }
  // 1-inline std::wstring const &LUIText::get_text(void) const
  std::wstring const &return_value = ((*(const LUIText*)local_this).get_text)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIText_get_text_276_comment =
  "C++ Interface:\n"
  "get_text(LUIText self)\n";
#else
static const char *Dtool_LUIText_get_text_276_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIText::set_font_size(float size)
 */
static PyObject *Dtool_LUIText_set_font_size_277(PyObject *self, PyObject *arg) {
  LUIText *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIText, (void **)&local_this, "LUIText.set_font_size")) {
    return nullptr;
  }
  // 1-inline void LUIText::set_font_size(float size)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_font_size)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_font_size(const LUIText self, float size)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIText_set_font_size_277_comment =
  "C++ Interface:\n"
  "set_font_size(const LUIText self, float size)\n";
#else
static const char *Dtool_LUIText_set_font_size_277_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float LUIText::get_font_size(void) const
 */
static PyObject *Dtool_LUIText_get_font_size_278(PyObject *self, PyObject *) {
  LUIText *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIText)) {
    return nullptr;
  }
  // 1-inline float LUIText::get_font_size(void) const
  float return_value = ((*(const LUIText*)local_this).get_font_size)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIText_get_font_size_278_comment =
  "C++ Interface:\n"
  "get_font_size(LUIText self)\n";
#else
static const char *Dtool_LUIText_get_font_size_278_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIText::set_wordwrap(bool wrap)
 */
static PyObject *Dtool_LUIText_set_wordwrap_279(PyObject *self, PyObject *arg) {
  LUIText *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIText, (void **)&local_this, "LUIText.set_wordwrap")) {
    return nullptr;
  }
  // 1-inline void LUIText::set_wordwrap(bool wrap)
  ((*local_this).set_wordwrap)((PyObject_IsTrue(arg) != 0));
  return Dtool_Return_None();
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_wordwrap(const LUIText self, bool wrap)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIText_set_wordwrap_279_comment =
  "C++ Interface:\n"
  "set_wordwrap(const LUIText self, bool wrap)\n";
#else
static const char *Dtool_LUIText_set_wordwrap_279_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LUIText::get_wordwrap(void) const
 */
static PyObject *Dtool_LUIText_get_wordwrap_280(PyObject *self, PyObject *) {
  LUIText *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIText)) {
    return nullptr;
  }
  // 1-inline bool LUIText::get_wordwrap(void) const
  bool return_value = ((*(const LUIText*)local_this).get_wordwrap)();
  return Dtool_Return_Bool(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIText_get_wordwrap_280_comment =
  "C++ Interface:\n"
  "get_wordwrap(LUIText self)\n";
#else
static const char *Dtool_LUIText_get_wordwrap_280_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * int LUIText::get_char_index(float pos) const
 */
static PyObject *Dtool_LUIText_get_char_index_281(PyObject *self, PyObject *arg) {
  LUIText *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIText)) {
    return nullptr;
  }
  // 1-int LUIText::get_char_index(float pos) const
  if (PyNumber_Check(arg)) {
    int return_value = ((*(const LUIText*)local_this).get_char_index)((float)PyFloat_AsDouble(arg));
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_char_index(LUIText self, float pos)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIText_get_char_index_281_comment =
  "C++ Interface:\n"
  "get_char_index(LUIText self, float pos)\n";
#else
static const char *Dtool_LUIText_get_char_index_281_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * float LUIText::get_char_pos(int char_index) const
 */
static PyObject *Dtool_LUIText_get_char_pos_282(PyObject *self, PyObject *arg) {
  LUIText *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIText)) {
    return nullptr;
  }
  // 1-float LUIText::get_char_pos(int char_index) const
  if (PyLongOrInt_Check(arg)) {
    long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
    if (arg_val < INT_MIN || arg_val > INT_MAX) {
      return PyErr_Format(PyExc_OverflowError,
                          "value %ld out of range for signed integer",
                          arg_val);
    }
#endif
    float return_value = ((*(const LUIText*)local_this).get_char_pos)((int)arg_val);
    if (Dtool_CheckErrorOccurred()) {
      return nullptr;
    }
    return Dtool_WrapValue(return_value);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_char_pos(LUIText self, int char_index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIText_get_char_pos_282_comment =
  "C++ Interface:\n"
  "get_char_pos(LUIText self, int char_index)\n";
#else
static const char *Dtool_LUIText_get_char_pos_282_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LUIText::get_class_type(void)
 */
static PyObject *Dtool_LUIText_get_class_type_291(PyObject *, PyObject *) {
  // 1-static TypeHandle LUIText::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LUIText::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LUIText_get_class_type_291_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LUIText_get_class_type_291_comment = nullptr;
#endif

static PyObject *Dtool_LUIText_font_Getter(PyObject *self, void *) {
  const LUIText *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIText, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline DynamicTextFont *LUIText::get_font(void) const
  DynamicTextFont *return_value = ((*(const LUIText*)local_this).get_font)();
  if (return_value != nullptr) {
    return_value->ref();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    if (return_value != nullptr) {
      unref_delete(return_value);
    }
    return Dtool_Raise_AssertionError();
  }
#endif
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_DynamicTextFont, true, false, return_value->as_typed_object()->get_type_index());
  }
}

static int Dtool_LUIText_font_Setter(PyObject *self, PyObject *arg, void *) {
  LUIText *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIText, (void **)&local_this, "LUIText.font")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete font attribute");
    return -1;
  }
  // 1-inline void LUIText::set_font(std::string const &font_name)
  const char *param1_str = nullptr;
  Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
  param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
  if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
    param1_str = nullptr;
  }
#endif
  if (param1_str != nullptr) {
    ((*local_this).set_font)(std::string(param1_str, param1_len));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_font(const LUIText self, str font_name)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIText_text_Getter(PyObject *self, void *) {
  const LUIText *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIText, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::wstring const &LUIText::get_text(void) const
  std::wstring const &return_value = ((*(const LUIText*)local_this).get_text)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIText_text_Setter(PyObject *self, PyObject *arg, void *) {
  LUIText *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIText, (void **)&local_this, "LUIText.text")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete text attribute");
    return -1;
  }
  // 1-inline void LUIText::set_text(std::wstring const &text)
#if PY_VERSION_HEX >= 0x03020000
  PyObject *param1;
#else
  PyUnicodeObject *param1;
#endif
  if (PyArg_Parse(arg, "U:set_text", &param1)) {
#if PY_VERSION_HEX >= 0x03030000
    Py_ssize_t param1_len;
    wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
    Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
    wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
    PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
    ((*local_this).set_text)(std::wstring(param1_str, param1_len));
#if PY_VERSION_HEX >= 0x03030000
    PyMem_Free(param1_str);
#endif
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_text(const LUIText self, unicode text)\n");
  }
  return -1;
}

static PyObject *Dtool_LUIText_font_size_Getter(PyObject *self, void *) {
  const LUIText *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIText, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline float LUIText::get_font_size(void) const
  float return_value = ((*(const LUIText*)local_this).get_font_size)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIText_font_size_Setter(PyObject *self, PyObject *arg, void *) {
  LUIText *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIText, (void **)&local_this, "LUIText.font_size")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete font_size attribute");
    return -1;
  }
  // 1-inline void LUIText::set_font_size(float size)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_font_size)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_font_size(const LUIText self, float size)\n");
  }
  return -1;
}

/**
 * Python function wrapper for:
 * LUIText::LUIText(PyObject *self, LUIObject *parent, std::wstring const &text, std::string const &font_name = "default", float font_size = 16.0, float x = 0.0, float y = 0.0, bool wordwrap = false)
 */
static int Dtool_Init_LUIText(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-LUIText::LUIText(PyObject *self, LUIObject *parent, std::wstring const &text, std::string const &font_name = "default", float font_size = 16.0, float x = 0.0, float y = 0.0, bool wordwrap = false)
  PyObject *param0;
#if PY_VERSION_HEX >= 0x03020000
  PyObject *param1;
#else
  PyUnicodeObject *param1;
#endif
  const char *param2_str = "default";
  Py_ssize_t param2_len = 7;
  float param3 = 16.0;
  float param4 = 0.0;
  float param5 = 0.0;
  PyObject *param6 = Py_False;
  static const char *keyword_list[] = {"parent", "text", "font_name", "font_size", "x", "y", "wordwrap", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "OU|s#fffO:LUIText", (char **)keyword_list, &param0, &param1, &param2_str, &param2_len, &param3, &param4, &param5, &param6)) {
    PT(LUIObject) param0_this;
    if (!Dtool_Coerce_LUIObject(param0, param0_this)) {
      Dtool_Raise_ArgTypeError(param0, 0, "LUIText.LUIText", "LUIObject");
      return -1;
    }
#if PY_VERSION_HEX >= 0x03030000
    Py_ssize_t param1_len;
    wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
    Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
    wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
    PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
    // Pre-initialize self for the constructor
    DTool_PyInit_Finalize(self, nullptr, &Dtool_LUIText, false, false);
    LUIText *return_value = new LUIText(self, std::move(param0_this), std::wstring(param1_str, param1_len), std::string(param2_str, param2_len), (float)param3, (float)param4, (float)param5, (PyObject_IsTrue(param6) != 0));
#if PY_VERSION_HEX >= 0x03030000
    PyMem_Free(param1_str);
#endif
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIText, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LUIText(LUIObject parent, unicode text, str font_name, float font_size, float x, float y, bool wordwrap)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_LUIText(PyObject *args, CPT(LUIText) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_LUIText)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 7) {
      // 1-LUIText::LUIText(PyObject *self, LUIObject *parent, std::wstring const &text, std::string const &font_name = "default", float font_size = 16.0, float x = 0.0, float y = 0.0, bool wordwrap = false)
      PyObject *param0;
#if PY_VERSION_HEX >= 0x03020000
      PyObject *param1;
#else
      PyUnicodeObject *param1;
#endif
      const char *param2_str = "default";
      Py_ssize_t param2_len = 7;
      float param3 = 16.0;
      float param4 = 0.0;
      float param5 = 0.0;
      PyObject *param6 = Py_False;
      if (PyArg_ParseTuple(args, "OU|s#fffO:LUIText", &param0, &param1, &param2_str, &param2_len, &param3, &param4, &param5, &param6)) {
        LUIObject *param0_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LUIObject, 0, "LUIText.LUIText", false, false);
#if PY_VERSION_HEX >= 0x03030000
        Py_ssize_t param1_len;
        wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
        Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
        wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
        PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
        if (param0_this != nullptr) {
          // Pre-initialize self for the constructor
          PyObject *self = Dtool_new_LUIText(&Dtool_LUIText._PyType, nullptr, nullptr);
          LUIText *return_value = new LUIText(self, param0_this, std::wstring(param1_str, param1_len), std::string(param2_str, param2_len), (float)param3, (float)param4, (float)param5, (PyObject_IsTrue(param6) != 0));
#if PY_VERSION_HEX >= 0x03030000
          PyMem_Free(param1_str);
#endif
          PyObject_Del(self);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_LUIText(PyObject *args, PT(LUIText) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_LUIText)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (PyTuple_Check(args)) {
    Py_ssize_t size = PyTuple_GET_SIZE(args);
    if (size >= 2 && size <= 7) {
      // 1-LUIText::LUIText(PyObject *self, LUIObject *parent, std::wstring const &text, std::string const &font_name = "default", float font_size = 16.0, float x = 0.0, float y = 0.0, bool wordwrap = false)
      PyObject *param0;
#if PY_VERSION_HEX >= 0x03020000
      PyObject *param1;
#else
      PyUnicodeObject *param1;
#endif
      const char *param2_str = "default";
      Py_ssize_t param2_len = 7;
      float param3 = 16.0;
      float param4 = 0.0;
      float param5 = 0.0;
      PyObject *param6 = Py_False;
      if (PyArg_ParseTuple(args, "OU|s#fffO:LUIText", &param0, &param1, &param2_str, &param2_len, &param3, &param4, &param5, &param6)) {
        LUIObject *param0_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LUIObject, 0, "LUIText.LUIText", false, false);
#if PY_VERSION_HEX >= 0x03030000
        Py_ssize_t param1_len;
        wchar_t *param1_str = PyUnicode_AsWideCharString(param1, &param1_len);
#else
        Py_ssize_t param1_len = PyUnicode_GET_SIZE(param1);
        wchar_t *param1_str = (wchar_t *)alloca(sizeof(wchar_t) * (param1_len + 1));
        PyUnicode_AsWideChar(param1, param1_str, param1_len);
#endif
        if (param0_this != nullptr) {
          // Pre-initialize self for the constructor
          PyObject *self = Dtool_new_LUIText(&Dtool_LUIText._PyType, nullptr, nullptr);
          LUIText *return_value = new LUIText(self, param0_this, std::wstring(param1_str, param1_len), std::string(param2_str, param2_len), (float)param3, (float)param4, (float)param5, (PyObject_IsTrue(param6) != 0));
#if PY_VERSION_HEX >= 0x03030000
          PyMem_Free(param1_str);
#endif
          PyObject_Del(self);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_LUIText(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LUIText) {
    printf("LUIText ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LUIText *local_this = (LUIText *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LUIText) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LUIBaseElement) {
    return (LUIBaseElement *)(LUIObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_LUIColorable) {
    return (LUIColorable *)(LUIBaseElement *)(LUIObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_LUIObject) {
    return (LUIObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(LUIBaseElement *)(LUIObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(LUIBaseElement *)(LUIObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(LUIBaseElement *)(LUIObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LUIText(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LUIText) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LUIBaseElement) {
    LUIBaseElement* other_this = (LUIBaseElement*)from_this;
    return (LUIText*)other_this;
  }
  if (from_type == Dtool_Ptr_LUIColorable) {
    LUIColorable* other_this = (LUIColorable*)from_this;
    return (LUIText*)other_this;
  }
  if (from_type == Dtool_Ptr_LUIObject) {
    LUIObject* other_this = (LUIObject*)from_this;
    return (LUIText*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LUIText*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LUIText*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LUIText*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LUIEventData
 */
/**
 * Python function wrapper for:
 * inline std::string LUIEventData::get_name(void) const
 */
static PyObject *Dtool_LUIEventData_get_name_299(PyObject *self, PyObject *) {
  LUIEventData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIEventData)) {
    return nullptr;
  }
  // 1-inline std::string LUIEventData::get_name(void) const
  std::string return_value = ((*(const LUIEventData*)local_this).get_name)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIEventData_get_name_299_comment =
  "C++ Interface:\n"
  "get_name(LUIEventData self)\n";
#else
static const char *Dtool_LUIEventData_get_name_299_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline PointerTo< LUIBaseElement > LUIEventData::get_sender(void) const
 */
static PyObject *Dtool_LUIEventData_get_sender_300(PyObject *self, PyObject *) {
  LUIEventData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIEventData)) {
    return nullptr;
  }
  // 1-inline PointerTo< LUIBaseElement > LUIEventData::get_sender(void) const
  PointerTo< LUIBaseElement > return_value = ((*(const LUIEventData*)local_this).get_sender)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  // Transfer ownership of return_value.
  LUIBaseElement *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_LUIBaseElement, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LUIEventData_get_sender_300_comment =
  "C++ Interface:\n"
  "get_sender(LUIEventData self)\n";
#else
static const char *Dtool_LUIEventData_get_sender_300_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LPoint2 LUIEventData::get_coordinates(void) const
 */
static PyObject *Dtool_LUIEventData_get_coordinates_301(PyObject *self, PyObject *) {
  LUIEventData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIEventData)) {
    return nullptr;
  }
  // 1-inline LPoint2 LUIEventData::get_coordinates(void) const
  LPoint2 *return_value = new LPoint2(((*(const LUIEventData*)local_this).get_coordinates)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LUIEventData_get_coordinates_301_comment =
  "C++ Interface:\n"
  "get_coordinates(LUIEventData self)\n";
#else
static const char *Dtool_LUIEventData_get_coordinates_301_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::wstring LUIEventData::get_message(void) const
 */
static PyObject *Dtool_LUIEventData_get_message_302(PyObject *self, PyObject *) {
  LUIEventData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIEventData)) {
    return nullptr;
  }
  // 1-inline std::wstring LUIEventData::get_message(void) const
  std::wstring return_value = ((*(const LUIEventData*)local_this).get_message)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIEventData_get_message_302_comment =
  "C++ Interface:\n"
  "get_message(LUIEventData self)\n";
#else
static const char *Dtool_LUIEventData_get_message_302_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline std::size_t LUIEventData::get_key_modifiers(void) const
 */
static PyObject *Dtool_LUIEventData_get_key_modifiers_303(PyObject *self, PyObject *) {
  LUIEventData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIEventData)) {
    return nullptr;
  }
  // 1-inline std::size_t LUIEventData::get_key_modifiers(void) const
  std::size_t return_value = ((*(const LUIEventData*)local_this).get_key_modifiers)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIEventData_get_key_modifiers_303_comment =
  "C++ Interface:\n"
  "get_key_modifiers(LUIEventData self)\n";
#else
static const char *Dtool_LUIEventData_get_key_modifiers_303_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline bool LUIEventData::get_modifier_state(LUIEventData::KeyModifiers modifier) const
 * inline bool LUIEventData::get_modifier_state(std::string const &modifier_name) const
 */
static PyObject *Dtool_LUIEventData_get_modifier_state_304(PyObject *self, PyObject *arg) {
  LUIEventData *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIEventData)) {
    return nullptr;
  }
  {
    // -2 inline bool LUIEventData::get_modifier_state(std::string const &modifier_name) const
    const char *param1_str = nullptr;
    Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
    param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
    if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
      param1_str = nullptr;
    }
#endif
    if (param1_str != nullptr) {
      bool return_value = ((*(const LUIEventData*)local_this).get_modifier_state)(std::string(param1_str, param1_len));
      return Dtool_Return_Bool(return_value);
    }
    PyErr_Clear();
  }

  {
    // -2 inline bool LUIEventData::get_modifier_state(LUIEventData::KeyModifiers modifier) const
    if (PyLongOrInt_Check(arg)) {
      long arg_val = PyLongOrInt_AS_LONG(arg);
#if (SIZEOF_LONG > SIZEOF_INT) && !defined(NDEBUG)
      if (arg_val < INT_MIN || arg_val > INT_MAX) {
        return PyErr_Format(PyExc_OverflowError,
                            "value %ld out of range for signed integer",
                            arg_val);
      }
#endif
      bool return_value = ((*(const LUIEventData*)local_this).get_modifier_state)((LUIEventData::KeyModifiers)arg_val);
      return Dtool_Return_Bool(return_value);
    }
  }

  // No coercion possible: inline bool LUIEventData::get_modifier_state(std::string const &modifier_name) const
  // No coercion possible: inline bool LUIEventData::get_modifier_state(LUIEventData::KeyModifiers modifier) const
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "get_modifier_state(LUIEventData self, str modifier_name)\n"
      "get_modifier_state(LUIEventData self, int modifier)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIEventData_get_modifier_state_304_comment =
  "C++ Interface:\n"
  "get_modifier_state(LUIEventData self, str modifier_name)\n"
  "get_modifier_state(LUIEventData self, int modifier)\n"
  "\n"
  "// Same as getModifierState in JS";
#else
static const char *Dtool_LUIEventData_get_modifier_state_304_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LUIEventData::get_class_type(void)
 */
static PyObject *Dtool_LUIEventData_get_class_type_314(PyObject *, PyObject *) {
  // 1-static TypeHandle LUIEventData::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LUIEventData::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LUIEventData_get_class_type_314_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LUIEventData_get_class_type_314_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * CallbackData *LUIEventData::upcast_to_CallbackData(void)
 */
static PyObject *Dtool_LUIEventData_upcast_to_CallbackData_294(PyObject *self, PyObject *) {
  LUIEventData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIEventData, (void **)&local_this, "LUIEventData.upcast_to_CallbackData")) {
    return nullptr;
  }
  // 1-CallbackData *LUIEventData::upcast_to_CallbackData(void)
  CallbackData *return_value = (CallbackData *)local_this;
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  if (return_value == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_CallbackData, false, false, return_value->as_typed_object()->get_type_index());
  }
}

#ifndef NDEBUG
static const char *Dtool_LUIEventData_upcast_to_CallbackData_294_comment =
  "C++ Interface:\n"
  "upcast_to_CallbackData(const LUIEventData self)\n"
  "\n"
  "upcast from LUIEventData to CallbackData";
#else
static const char *Dtool_LUIEventData_upcast_to_CallbackData_294_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * ReferenceCount *LUIEventData::upcast_to_ReferenceCount(void)
 */
static PyObject *Dtool_LUIEventData_upcast_to_ReferenceCount_296(PyObject *self, PyObject *) {
  LUIEventData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIEventData, (void **)&local_this, "LUIEventData.upcast_to_ReferenceCount")) {
    return nullptr;
  }
  // 1-ReferenceCount *LUIEventData::upcast_to_ReferenceCount(void)
  ReferenceCount *return_value = (ReferenceCount *)local_this;
  return_value->ref();
  if (Dtool_CheckErrorOccurred()) {
    unref_delete(return_value);
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_ReferenceCount, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LUIEventData_upcast_to_ReferenceCount_296_comment =
  "C++ Interface:\n"
  "upcast_to_ReferenceCount(const LUIEventData self)\n"
  "\n"
  "upcast from LUIEventData to ReferenceCount";
#else
static const char *Dtool_LUIEventData_upcast_to_ReferenceCount_296_comment = nullptr;
#endif

static PyObject *Dtool_LUIEventData_name_Getter(PyObject *self, void *) {
  const LUIEventData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIEventData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::string LUIEventData::get_name(void) const
  std::string return_value = ((*(const LUIEventData*)local_this).get_name)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_LUIEventData_sender_Getter(PyObject *self, void *) {
  const LUIEventData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIEventData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline PointerTo< LUIBaseElement > LUIEventData::get_sender(void) const
  PointerTo< LUIBaseElement > return_value = ((*(const LUIEventData*)local_this).get_sender)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  // Transfer ownership of return_value.
  LUIBaseElement *return_ptr = return_value.p();
  return_value.cheat() = nullptr;
  if (return_ptr == nullptr) {
    Py_INCREF(Py_None);
    return Py_None;
  } else {
    return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_LUIBaseElement, true, false, return_ptr->as_typed_object()->get_type_index());
  }
}

static PyObject *Dtool_LUIEventData_coordinates_Getter(PyObject *self, void *) {
  const LUIEventData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIEventData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline LPoint2 LUIEventData::get_coordinates(void) const
  LPoint2 *return_value = new LPoint2(((*(const LUIEventData*)local_this).get_coordinates)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    delete return_value;
    return Dtool_Raise_AssertionError();
  }
#endif
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LPoint2f, true, false);
}

static PyObject *Dtool_LUIEventData_message_Getter(PyObject *self, void *) {
  const LUIEventData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIEventData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::wstring LUIEventData::get_message(void) const
  std::wstring return_value = ((*(const LUIEventData*)local_this).get_message)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static PyObject *Dtool_LUIEventData_key_modifiers_Getter(PyObject *self, void *) {
  const LUIEventData *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIEventData, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline std::size_t LUIEventData::get_key_modifiers(void) const
  std::size_t return_value = ((*(const LUIEventData*)local_this).get_key_modifiers)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_Init_LUIEventData(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_LUIEventData(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LUIEventData) {
    printf("LUIEventData ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LUIEventData *local_this = (LUIEventData *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LUIEventData) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_CallbackData) {
    return (CallbackData *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(CallbackData *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LUIEventData(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LUIEventData) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_CallbackData) {
    CallbackData* other_this = (CallbackData*)from_this;
    return (LUIEventData*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LUIEventData*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LUIEventData*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LUIBaseLayout
 */
/**
 * Python function wrapper for:
 * void LUIBaseLayout::add(PointerTo< LUIBaseElement > object, float cell_height)
 * void LUIBaseLayout::add(PointerTo< LUIBaseElement > object, std::string const &cell_mode = "?")
 */
static PyObject *Dtool_LUIBaseLayout_add_316(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIBaseLayout *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseLayout, (void **)&local_this, "LUIBaseLayout.add")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  switch (parameter_count) {
  case 1:
    {
      PyObject *arg;
      if (Dtool_ExtractArg(&arg, args, kwds, "object")) {
        // 1-void LUIBaseLayout::add(PointerTo< LUIBaseElement > object, std::string const &cell_mode)
        PT(LUIBaseElement) arg_this;
        if (!Dtool_Coerce_LUIBaseElement(arg, arg_this)) {
          return Dtool_Raise_ArgTypeError(arg, 1, "LUIBaseLayout.add", "LUIBaseElement");
        }
        ((*local_this).add)(std::move(arg_this));
        return Dtool_Return_None();
      }
    }
    break;
  case 2:
    {
      {
        // -2 void LUIBaseLayout::add(PointerTo< LUIBaseElement > object, std::string const &cell_mode)
        PyObject *param1;
        const char *param2_str = nullptr;
        Py_ssize_t param2_len;
        static const char *keyword_list[] = {"object", "cell_mode", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:add", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
          LUIBaseElement *param1_this = (LUIBaseElement *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LUIBaseElement, 1, "LUIBaseLayout.add", false, false);
          if (param1_this != nullptr) {
            ((*local_this).add)(param1_this, std::string(param2_str, param2_len));
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void LUIBaseLayout::add(PointerTo< LUIBaseElement > object, float cell_height)
        PyObject *param1;
        float param2;
        static const char *keyword_list[] = {"object", "cell_height", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:add", (char **)keyword_list, &param1, &param2)) {
          LUIBaseElement *param1_this = (LUIBaseElement *)DTOOL_Call_GetPointerThisClass(param1, Dtool_Ptr_LUIBaseElement, 1, "LUIBaseLayout.add", false, false);
          if (param1_this != nullptr) {
            ((*local_this).add)(param1_this, (float)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void LUIBaseLayout::add(PointerTo< LUIBaseElement > object, std::string const &cell_mode)
        PyObject *param1;
        const char *param2_str = nullptr;
        Py_ssize_t param2_len;
        static const char *keyword_list[] = {"object", "cell_mode", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Os#:add", (char **)keyword_list, &param1, &param2_str, &param2_len)) {
          PT(LUIBaseElement) param1_this;
          if (Dtool_Coerce_LUIBaseElement(param1, param1_this)) {
            ((*local_this).add)(std::move(param1_this), std::string(param2_str, param2_len));
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

      {
        // -2 void LUIBaseLayout::add(PointerTo< LUIBaseElement > object, float cell_height)
        PyObject *param1;
        float param2;
        static const char *keyword_list[] = {"object", "cell_height", nullptr};
        if (PyArg_ParseTupleAndKeywords(args, kwds, "Of:add", (char **)keyword_list, &param1, &param2)) {
          PT(LUIBaseElement) param1_this;
          if (Dtool_Coerce_LUIBaseElement(param1, param1_this)) {
            ((*local_this).add)(std::move(param1_this), (float)param2);
            return Dtool_Return_None();
          }
        }
        PyErr_Clear();
      }

    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "add() takes 2 or 3 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "add(const LUIBaseLayout self, LUIBaseElement object)\n"
      "add(const LUIBaseLayout self, LUIBaseElement object, str cell_mode)\n"
      "add(const LUIBaseLayout self, LUIBaseElement object, float cell_height)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseLayout_add_316_comment =
  "C++ Interface:\n"
  "add(const LUIBaseLayout self, LUIBaseElement object)\n"
  "add(const LUIBaseLayout self, LUIBaseElement object, str cell_mode)\n"
  "add(const LUIBaseLayout self, LUIBaseElement object, float cell_height)\n";
#else
static const char *Dtool_LUIBaseLayout_add_316_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LUIBaseLayout::reset(void)
 */
static PyObject *Dtool_LUIBaseLayout_reset_317(PyObject *self, PyObject *) {
  LUIBaseLayout *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseLayout, (void **)&local_this, "LUIBaseLayout.reset")) {
    return nullptr;
  }
  // 1-void LUIBaseLayout::reset(void)
  ((*local_this).reset)();
  return Dtool_Return_None();
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseLayout_reset_317_comment =
  "C++ Interface:\n"
  "reset(const LUIBaseLayout self)\n";
#else
static const char *Dtool_LUIBaseLayout_reset_317_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * void LUIBaseLayout::remove_cell(std::size_t index)
 */
static PyObject *Dtool_LUIBaseLayout_remove_cell_318(PyObject *self, PyObject *arg) {
  LUIBaseLayout *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseLayout, (void **)&local_this, "LUIBaseLayout.remove_cell")) {
    return nullptr;
  }
  // 1-void LUIBaseLayout::remove_cell(std::size_t index)
  if (PyLongOrInt_Check(arg)) {
    size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
    if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
      return nullptr;
    }
#endif
    ((*local_this).remove_cell)(arg_val);
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "remove_cell(const LUIBaseLayout self, int index)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseLayout_remove_cell_318_comment =
  "C++ Interface:\n"
  "remove_cell(const LUIBaseLayout self, int index)\n";
#else
static const char *Dtool_LUIBaseLayout_remove_cell_318_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * PointerTo< LUIObject > LUIBaseLayout::cell(void)
 * PointerTo< LUIObject > LUIBaseLayout::cell(float cell_height)
 * PointerTo< LUIObject > LUIBaseLayout::cell(std::string const &cell_mode)
 */
static PyObject *Dtool_LUIBaseLayout_cell_319(PyObject *self, PyObject *args) {
  LUIBaseLayout *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseLayout, (void **)&local_this, "LUIBaseLayout.cell")) {
    return nullptr;
  }
  int parameter_count = (int)PyTuple_Size(args);
  switch (parameter_count) {
  case 0:
    {
      // 1-PointerTo< LUIObject > LUIBaseLayout::cell(void)
      PointerTo< LUIObject > return_value = ((*local_this).cell)();
      if (Dtool_CheckErrorOccurred()) {
        return nullptr;
      }
      // Transfer ownership of return_value.
      LUIObject *return_ptr = return_value.p();
      return_value.cheat() = nullptr;
      if (return_ptr == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_LUIObject, true, false, return_ptr->as_typed_object()->get_type_index());
      }
    }
    break;
  case 1:
    {
      PyObject *arg = PyTuple_GET_ITEM(args, 0);
      {
        // -2 PointerTo< LUIObject > LUIBaseLayout::cell(std::string const &cell_mode)
        const char *param1_str = nullptr;
        Py_ssize_t param1_len;
#if PY_MAJOR_VERSION >= 3
        param1_str = PyUnicode_AsUTF8AndSize(arg, &param1_len);
#else
        if (PyString_AsStringAndSize(arg, (char **)&param1_str, &param1_len) == -1) {
          param1_str = nullptr;
        }
#endif
        if (param1_str != nullptr) {
          PointerTo< LUIObject > return_value = ((*local_this).cell)(std::string(param1_str, param1_len));
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          LUIObject *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_LUIObject, true, false, return_ptr->as_typed_object()->get_type_index());
          }
        }
        PyErr_Clear();
      }

      {
        // -2 PointerTo< LUIObject > LUIBaseLayout::cell(float cell_height)
        if (PyNumber_Check(arg)) {
          PointerTo< LUIObject > return_value = ((*local_this).cell)((float)PyFloat_AsDouble(arg));
          if (Dtool_CheckErrorOccurred()) {
            return nullptr;
          }
          // Transfer ownership of return_value.
          LUIObject *return_ptr = return_value.p();
          return_value.cheat() = nullptr;
          if (return_ptr == nullptr) {
            Py_INCREF(Py_None);
            return Py_None;
          } else {
            return DTool_CreatePyInstanceTyped((void *)return_ptr, *Dtool_Ptr_LUIObject, true, false, return_ptr->as_typed_object()->get_type_index());
          }
        }
      }

      // No coercion possible: PointerTo< LUIObject > LUIBaseLayout::cell(std::string const &cell_mode)
      // No coercion possible: PointerTo< LUIObject > LUIBaseLayout::cell(float cell_height)
    }
    break;
#ifndef NDEBUG
  default:
    return PyErr_Format(PyExc_TypeError,
                        "cell() takes 1 or 2 arguments (%d given)",
                        parameter_count + 1);
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "cell(const LUIBaseLayout self)\n"
      "cell(const LUIBaseLayout self, str cell_mode)\n"
      "cell(const LUIBaseLayout self, float cell_height)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseLayout_cell_319_comment =
  "C++ Interface:\n"
  "cell(const LUIBaseLayout self)\n"
  "cell(const LUIBaseLayout self, str cell_mode)\n"
  "cell(const LUIBaseLayout self, float cell_height)\n";
#else
static const char *Dtool_LUIBaseLayout_cell_319_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline void LUIBaseLayout::set_spacing(float spacing)
 */
static PyObject *Dtool_LUIBaseLayout_set_spacing_320(PyObject *self, PyObject *arg) {
  LUIBaseLayout *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseLayout, (void **)&local_this, "LUIBaseLayout.set_spacing")) {
    return nullptr;
  }
  // 1-inline void LUIBaseLayout::set_spacing(float spacing)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_spacing)((float)PyFloat_AsDouble(arg));
    return Dtool_Return_None();
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "set_spacing(const LUIBaseLayout self, float spacing)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseLayout_set_spacing_320_comment =
  "C++ Interface:\n"
  "set_spacing(const LUIBaseLayout self, float spacing)\n";
#else
static const char *Dtool_LUIBaseLayout_set_spacing_320_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline float LUIBaseLayout::get_spacing(void) const
 */
static PyObject *Dtool_LUIBaseLayout_get_spacing_321(PyObject *self, PyObject *) {
  LUIBaseLayout *local_this = nullptr;
  if (!DtoolInstance_GetPointer(self, local_this, Dtool_LUIBaseLayout)) {
    return nullptr;
  }
  // 1-inline float LUIBaseLayout::get_spacing(void) const
  float return_value = ((*(const LUIBaseLayout*)local_this).get_spacing)();
  if (Dtool_CheckErrorOccurred()) {
    return nullptr;
  }
  return Dtool_WrapValue(return_value);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseLayout_get_spacing_321_comment =
  "C++ Interface:\n"
  "get_spacing(LUIBaseLayout self)\n";
#else
static const char *Dtool_LUIBaseLayout_get_spacing_321_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * static TypeHandle LUIBaseLayout::get_class_type(void)
 */
static PyObject *Dtool_LUIBaseLayout_get_class_type_323(PyObject *, PyObject *) {
  // 1-static TypeHandle LUIBaseLayout::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LUIBaseLayout::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LUIBaseLayout_get_class_type_323_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LUIBaseLayout_get_class_type_323_comment = nullptr;
#endif

static PyObject *Dtool_LUIBaseLayout_spacing_Getter(PyObject *self, void *) {
  const LUIBaseLayout *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIBaseLayout, (void **)&local_this)) {
    return nullptr;
  }

  // 1-inline float LUIBaseLayout::get_spacing(void) const
  float return_value = ((*(const LUIBaseLayout*)local_this).get_spacing)();
#ifndef NDEBUG
  Notify *notify = Notify::ptr();
  if (UNLIKELY(notify->has_assert_failed())) {
    return Dtool_Raise_AssertionError();
  }
#endif
  return Dtool_WrapValue(return_value);
}

static int Dtool_LUIBaseLayout_spacing_Setter(PyObject *self, PyObject *arg, void *) {
  LUIBaseLayout *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIBaseLayout, (void **)&local_this, "LUIBaseLayout.spacing")) {
    return -1;
  }

  if (arg == nullptr) {
    Dtool_Raise_TypeError("can't delete spacing attribute");
    return -1;
  }
  // 1-inline void LUIBaseLayout::set_spacing(float spacing)
  if (PyNumber_Check(arg)) {
    ((*local_this).set_spacing)((float)PyFloat_AsDouble(arg));
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      Dtool_Raise_AssertionError();
      return -1;
    }
#endif
    return 0;
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "set_spacing(const LUIBaseLayout self, float spacing)\n");
  }
  return -1;
}

static int Dtool_Init_LUIBaseLayout(PyObject *self, PyObject *args, PyObject *kwds) {
  Dtool_Raise_TypeError("cannot init abstract class");
  return -1;
}

static void *Dtool_UpcastInterface_LUIBaseLayout(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LUIBaseLayout) {
    printf("LUIBaseLayout ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LUIBaseLayout *local_this = (LUIBaseLayout *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LUIBaseLayout) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LUIBaseElement) {
    return (LUIBaseElement *)(LUIObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_LUIColorable) {
    return (LUIColorable *)(LUIBaseElement *)(LUIObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_LUIObject) {
    return (LUIObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(LUIBaseElement *)(LUIObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(LUIBaseElement *)(LUIObject *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(LUIBaseElement *)(LUIObject *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LUIBaseLayout(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LUIBaseLayout) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LUIBaseElement) {
    LUIBaseElement* other_this = (LUIBaseElement*)from_this;
    return (LUIBaseLayout*)other_this;
  }
  if (from_type == Dtool_Ptr_LUIColorable) {
    LUIColorable* other_this = (LUIColorable*)from_this;
    return (LUIBaseLayout*)other_this;
  }
  if (from_type == Dtool_Ptr_LUIObject) {
    LUIObject* other_this = (LUIObject*)from_this;
    return (LUIBaseLayout*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LUIBaseLayout*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LUIBaseLayout*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LUIBaseLayout*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LUIVerticalLayout
 */
/**
 * Python function wrapper for:
 * static TypeHandle LUIVerticalLayout::get_class_type(void)
 */
static PyObject *Dtool_LUIVerticalLayout_get_class_type_327(PyObject *, PyObject *) {
  // 1-static TypeHandle LUIVerticalLayout::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LUIVerticalLayout::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LUIVerticalLayout_get_class_type_327_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LUIVerticalLayout_get_class_type_327_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LUIVerticalLayout::LUIVerticalLayout(PyObject *self, LUIObject *parent, float spacing = 0.0)
 */
static int Dtool_Init_LUIVerticalLayout(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-LUIVerticalLayout::LUIVerticalLayout(PyObject *self, LUIObject *parent, float spacing = 0.0)
  PyObject *param0;
  float param1 = 0.0;
  static const char *keyword_list[] = {"parent", "spacing", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|f:LUIVerticalLayout", (char **)keyword_list, &param0, &param1)) {
    PT(LUIObject) param0_this;
    if (!Dtool_Coerce_LUIObject(param0, param0_this)) {
      Dtool_Raise_ArgTypeError(param0, 0, "LUIVerticalLayout.LUIVerticalLayout", "LUIObject");
      return -1;
    }
    // Pre-initialize self for the constructor
    DTool_PyInit_Finalize(self, nullptr, &Dtool_LUIVerticalLayout, false, false);
    LUIVerticalLayout *return_value = new LUIVerticalLayout(self, std::move(param0_this), (float)param1);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIVerticalLayout, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LUIVerticalLayout(LUIObject parent, float spacing)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_LUIVerticalLayout(PyObject *args, CPT(LUIVerticalLayout) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_LUIVerticalLayout)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-LUIVerticalLayout::LUIVerticalLayout(PyObject *self, LUIObject *parent, float spacing)
    LUIObject *arg_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LUIObject, 0, "LUIVerticalLayout.LUIVerticalLayout", false, false);
    if (arg_this != nullptr) {
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_LUIVerticalLayout(&Dtool_LUIVerticalLayout._PyType, nullptr, nullptr);
      LUIVerticalLayout *return_value = new LUIVerticalLayout(self, arg_this);
      PyObject_Del(self);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-LUIVerticalLayout::LUIVerticalLayout(PyObject *self, LUIObject *parent, float spacing)
      PyObject *param0;
      float param1;
      if (PyArg_ParseTuple(args, "Of:LUIVerticalLayout", &param0, &param1)) {
        LUIObject *param0_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LUIObject, 0, "LUIVerticalLayout.LUIVerticalLayout", false, false);
        if (param0_this != nullptr) {
          // Pre-initialize self for the constructor
          PyObject *self = Dtool_new_LUIVerticalLayout(&Dtool_LUIVerticalLayout._PyType, nullptr, nullptr);
          LUIVerticalLayout *return_value = new LUIVerticalLayout(self, param0_this, (float)param1);
          PyObject_Del(self);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_LUIVerticalLayout(PyObject *args, PT(LUIVerticalLayout) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_LUIVerticalLayout)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-LUIVerticalLayout::LUIVerticalLayout(PyObject *self, LUIObject *parent, float spacing)
    LUIObject *arg_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LUIObject, 0, "LUIVerticalLayout.LUIVerticalLayout", false, false);
    if (arg_this != nullptr) {
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_LUIVerticalLayout(&Dtool_LUIVerticalLayout._PyType, nullptr, nullptr);
      LUIVerticalLayout *return_value = new LUIVerticalLayout(self, arg_this);
      PyObject_Del(self);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-LUIVerticalLayout::LUIVerticalLayout(PyObject *self, LUIObject *parent, float spacing)
      PyObject *param0;
      float param1;
      if (PyArg_ParseTuple(args, "Of:LUIVerticalLayout", &param0, &param1)) {
        LUIObject *param0_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LUIObject, 0, "LUIVerticalLayout.LUIVerticalLayout", false, false);
        if (param0_this != nullptr) {
          // Pre-initialize self for the constructor
          PyObject *self = Dtool_new_LUIVerticalLayout(&Dtool_LUIVerticalLayout._PyType, nullptr, nullptr);
          LUIVerticalLayout *return_value = new LUIVerticalLayout(self, param0_this, (float)param1);
          PyObject_Del(self);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_LUIVerticalLayout(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LUIVerticalLayout) {
    printf("LUIVerticalLayout ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LUIVerticalLayout *local_this = (LUIVerticalLayout *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LUIVerticalLayout) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LUIBaseElement) {
    return (LUIBaseElement *)(LUIObject *)(LUIBaseLayout *) local_this;
  }
  if (requested_type == Dtool_Ptr_LUIBaseLayout) {
    return (LUIBaseLayout *) local_this;
  }
  if (requested_type == Dtool_Ptr_LUIColorable) {
    return (LUIColorable *)(LUIBaseElement *)(LUIObject *)(LUIBaseLayout *) local_this;
  }
  if (requested_type == Dtool_Ptr_LUIObject) {
    return (LUIObject *)(LUIBaseLayout *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(LUIBaseElement *)(LUIObject *)(LUIBaseLayout *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(LUIBaseElement *)(LUIObject *)(LUIBaseLayout *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(LUIBaseElement *)(LUIObject *)(LUIBaseLayout *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LUIVerticalLayout(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LUIVerticalLayout) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LUIBaseElement) {
    LUIBaseElement* other_this = (LUIBaseElement*)from_this;
    return (LUIVerticalLayout*)other_this;
  }
  if (from_type == Dtool_Ptr_LUIBaseLayout) {
    LUIBaseLayout* other_this = (LUIBaseLayout*)from_this;
    return (LUIVerticalLayout*)other_this;
  }
  if (from_type == Dtool_Ptr_LUIColorable) {
    LUIColorable* other_this = (LUIColorable*)from_this;
    return (LUIVerticalLayout*)other_this;
  }
  if (from_type == Dtool_Ptr_LUIObject) {
    LUIObject* other_this = (LUIObject*)from_this;
    return (LUIVerticalLayout*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LUIVerticalLayout*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LUIVerticalLayout*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LUIVerticalLayout*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LUIHorizontalLayout
 */
/**
 * Python function wrapper for:
 * static TypeHandle LUIHorizontalLayout::get_class_type(void)
 */
static PyObject *Dtool_LUIHorizontalLayout_get_class_type_331(PyObject *, PyObject *) {
  // 1-static TypeHandle LUIHorizontalLayout::get_class_type(void)
  TypeHandle *return_value = new TypeHandle((LUIHorizontalLayout::get_class_type)());
  if (return_value == nullptr) {
    return PyErr_NoMemory();
  }
  if (Dtool_CheckErrorOccurred()) {
    delete return_value;
    return nullptr;
  }
  return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_TypeHandle, true, false);
}

#ifndef NDEBUG
static const char *Dtool_LUIHorizontalLayout_get_class_type_331_comment =
  "C++ Interface:\n"
  "get_class_type()\n";
#else
static const char *Dtool_LUIHorizontalLayout_get_class_type_331_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * LUIHorizontalLayout::LUIHorizontalLayout(PyObject *self, LUIObject *parent, float spacing = 0.0)
 */
static int Dtool_Init_LUIHorizontalLayout(PyObject *self, PyObject *args, PyObject *kwds) {
  // 1-LUIHorizontalLayout::LUIHorizontalLayout(PyObject *self, LUIObject *parent, float spacing = 0.0)
  PyObject *param0;
  float param1 = 0.0;
  static const char *keyword_list[] = {"parent", "spacing", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "O|f:LUIHorizontalLayout", (char **)keyword_list, &param0, &param1)) {
    PT(LUIObject) param0_this;
    if (!Dtool_Coerce_LUIObject(param0, param0_this)) {
      Dtool_Raise_ArgTypeError(param0, 0, "LUIHorizontalLayout.LUIHorizontalLayout", "LUIObject");
      return -1;
    }
    // Pre-initialize self for the constructor
    DTool_PyInit_Finalize(self, nullptr, &Dtool_LUIHorizontalLayout, false, false);
    LUIHorizontalLayout *return_value = new LUIHorizontalLayout(self, std::move(param0_this), (float)param1);
    if (return_value == nullptr) {
      PyErr_NoMemory();
      return -1;
    }
    return_value->ref();
    if (Dtool_CheckErrorOccurred()) {
      unref_delete(return_value);
      return -1;
    }
    return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIHorizontalLayout, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LUIHorizontalLayout(LUIObject parent, float spacing)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_LUIHorizontalLayout(PyObject *args, CPT(LUIHorizontalLayout) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_LUIHorizontalLayout)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-LUIHorizontalLayout::LUIHorizontalLayout(PyObject *self, LUIObject *parent, float spacing)
    LUIObject *arg_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LUIObject, 0, "LUIHorizontalLayout.LUIHorizontalLayout", false, false);
    if (arg_this != nullptr) {
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_LUIHorizontalLayout(&Dtool_LUIHorizontalLayout._PyType, nullptr, nullptr);
      LUIHorizontalLayout *return_value = new LUIHorizontalLayout(self, arg_this);
      PyObject_Del(self);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-LUIHorizontalLayout::LUIHorizontalLayout(PyObject *self, LUIObject *parent, float spacing)
      PyObject *param0;
      float param1;
      if (PyArg_ParseTuple(args, "Of:LUIHorizontalLayout", &param0, &param1)) {
        LUIObject *param0_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LUIObject, 0, "LUIHorizontalLayout.LUIHorizontalLayout", false, false);
        if (param0_this != nullptr) {
          // Pre-initialize self for the constructor
          PyObject *self = Dtool_new_LUIHorizontalLayout(&Dtool_LUIHorizontalLayout._PyType, nullptr, nullptr);
          LUIHorizontalLayout *return_value = new LUIHorizontalLayout(self, param0_this, (float)param1);
          PyObject_Del(self);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

bool Dtool_Coerce_LUIHorizontalLayout(PyObject *args, PT(LUIHorizontalLayout) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_LUIHorizontalLayout)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-LUIHorizontalLayout::LUIHorizontalLayout(PyObject *self, LUIObject *parent, float spacing)
    LUIObject *arg_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(arg, Dtool_Ptr_LUIObject, 0, "LUIHorizontalLayout.LUIHorizontalLayout", false, false);
    if (arg_this != nullptr) {
      // Pre-initialize self for the constructor
      PyObject *self = Dtool_new_LUIHorizontalLayout(&Dtool_LUIHorizontalLayout._PyType, nullptr, nullptr);
      LUIHorizontalLayout *return_value = new LUIHorizontalLayout(self, arg_this);
      PyObject_Del(self);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  } else {
    if (PyTuple_GET_SIZE(args) == 2) {
      // 1-LUIHorizontalLayout::LUIHorizontalLayout(PyObject *self, LUIObject *parent, float spacing)
      PyObject *param0;
      float param1;
      if (PyArg_ParseTuple(args, "Of:LUIHorizontalLayout", &param0, &param1)) {
        LUIObject *param0_this = (LUIObject *)DTOOL_Call_GetPointerThisClass(param0, Dtool_Ptr_LUIObject, 0, "LUIHorizontalLayout.LUIHorizontalLayout", false, false);
        if (param0_this != nullptr) {
          // Pre-initialize self for the constructor
          PyObject *self = Dtool_new_LUIHorizontalLayout(&Dtool_LUIHorizontalLayout._PyType, nullptr, nullptr);
          LUIHorizontalLayout *return_value = new LUIHorizontalLayout(self, param0_this, (float)param1);
          PyObject_Del(self);
          if (return_value == nullptr) {
            PyErr_NoMemory();
            return false;
          }
          return_value->ref();
          if (_PyErr_OCCURRED()) {
            unref_delete(return_value);
            return false;
          } else {
            coerced = std::move(return_value);
            return true;
          }
        }
      }
      PyErr_Clear();
    }
  }

  return false;
}

static void *Dtool_UpcastInterface_LUIHorizontalLayout(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LUIHorizontalLayout) {
    printf("LUIHorizontalLayout ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LUIHorizontalLayout *local_this = (LUIHorizontalLayout *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LUIHorizontalLayout) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_LUIBaseElement) {
    return (LUIBaseElement *)(LUIObject *)(LUIBaseLayout *) local_this;
  }
  if (requested_type == Dtool_Ptr_LUIBaseLayout) {
    return (LUIBaseLayout *) local_this;
  }
  if (requested_type == Dtool_Ptr_LUIColorable) {
    return (LUIColorable *)(LUIBaseElement *)(LUIObject *)(LUIBaseLayout *) local_this;
  }
  if (requested_type == Dtool_Ptr_LUIObject) {
    return (LUIObject *)(LUIBaseLayout *) local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *)(TypedReferenceCount *)(LUIBaseElement *)(LUIObject *)(LUIBaseLayout *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedObject) {
    return (TypedObject *)(TypedReferenceCount *)(LUIBaseElement *)(LUIObject *)(LUIBaseLayout *) local_this;
  }
  if (requested_type == Dtool_Ptr_TypedReferenceCount) {
    return (TypedReferenceCount *)(LUIBaseElement *)(LUIObject *)(LUIBaseLayout *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LUIHorizontalLayout(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LUIHorizontalLayout) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_LUIBaseElement) {
    LUIBaseElement* other_this = (LUIBaseElement*)from_this;
    return (LUIHorizontalLayout*)other_this;
  }
  if (from_type == Dtool_Ptr_LUIBaseLayout) {
    LUIBaseLayout* other_this = (LUIBaseLayout*)from_this;
    return (LUIHorizontalLayout*)other_this;
  }
  if (from_type == Dtool_Ptr_LUIColorable) {
    LUIColorable* other_this = (LUIColorable*)from_this;
    return (LUIHorizontalLayout*)other_this;
  }
  if (from_type == Dtool_Ptr_LUIObject) {
    LUIObject* other_this = (LUIObject*)from_this;
    return (LUIHorizontalLayout*)other_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LUIHorizontalLayout*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedObject) {
    TypedObject* other_this = (TypedObject*)from_this;
    return (LUIHorizontalLayout*)other_this;
  }
  if (from_type == Dtool_Ptr_TypedReferenceCount) {
    TypedReferenceCount* other_this = (TypedReferenceCount*)from_this;
    return (LUIHorizontalLayout*)other_this;
  }
  return nullptr;
}

/**
 * Python wrappers for functions of class LUIAtlasPacker
 */
/**
 * Python function wrapper for:
 * LVector2f LUIAtlasPacker::find_position(std::size_t w, std::size_t h)
 */
static PyObject *Dtool_LUIAtlasPacker_find_position_335(PyObject *self, PyObject *args, PyObject *kwds) {
  LUIAtlasPacker *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer_NonConst(self, Dtool_LUIAtlasPacker, (void **)&local_this, "LUIAtlasPacker.find_position")) {
    return nullptr;
  }
  // 1-LVector2f LUIAtlasPacker::find_position(std::size_t w, std::size_t h)
  Py_ssize_t param1;
  Py_ssize_t param2;
  static const char *keyword_list[] = {"w", "h", nullptr};
  if (PyArg_ParseTupleAndKeywords(args, kwds, "nn:find_position", (char **)keyword_list, &param1, &param2)) {
#ifndef NDEBUG
    if (param1 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param1);
    }
#endif
#ifndef NDEBUG
    if (param2 < 0) {
      return PyErr_Format(PyExc_OverflowError,
                          "can't convert negative value %zd to size_t",
                          param2);
    }
#endif
    LVector2f *return_value = new LVector2f(((*local_this).find_position)((std::size_t)param1, (std::size_t)param2));
    if (return_value == nullptr) {
      return PyErr_NoMemory();
    }
    if (Dtool_CheckErrorOccurred()) {
      delete return_value;
      return nullptr;
    }
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LVector2f, true, false);
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "find_position(const LUIAtlasPacker self, int w, int h)\n");
  }
  return nullptr;
}

#ifndef NDEBUG
static const char *Dtool_LUIAtlasPacker_find_position_335_comment =
  "C++ Interface:\n"
  "find_position(const LUIAtlasPacker self, int w, int h)\n"
  "\n"
  "/**\n"
  " * @brief Finds a region in the atlas\n"
  " * @details This attempts to find a place for the given dimensions in the atlas.\n"
  " *   If a region is found, returns the upper left coordinate of the region in\n"
  " *   pixels. If no region was found, (-1, -1) is returned.\n"
  " *\n"
  " * @param w Width of the region in pixels\n"
  " * @param h Height of the region in pixels\n"
  " *\n"
  " * @return Either coordinate of the region, or (-1, -1) if no free spot was found\n"
  " */";
#else
static const char *Dtool_LUIAtlasPacker_find_position_335_comment = nullptr;
#endif

/**
 * Python function wrapper for:
 * inline LUIAtlasPacker::LUIAtlasPacker(LUIAtlasPacker const &) = default
 * LUIAtlasPacker::LUIAtlasPacker(std::size_t size)
 */
static int Dtool_Init_LUIAtlasPacker(PyObject *self, PyObject *args, PyObject *kwds) {
  int parameter_count = (int)PyTuple_Size(args);
  if (kwds != nullptr) {
    parameter_count += (int)PyDict_Size(kwds);
  }
  if (parameter_count != 1) {
#ifdef NDEBUG
    Dtool_Raise_TypeError("function takes exactly 1 argument");
    return -1;
#else
    PyErr_Format(PyExc_TypeError,
                 "LUIAtlasPacker() takes exactly 1 argument (%d given)",
                 parameter_count);
    return -1;
#endif
  }
  {
    // -2 inline LUIAtlasPacker::LUIAtlasPacker(LUIAtlasPacker const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      LUIAtlasPacker const *param0_this = nullptr;
      DtoolInstance_GetPointer(param0, param0_this, *Dtool_Ptr_LUIAtlasPacker);
      if (param0_this != nullptr) {
        LUIAtlasPacker *return_value = new LUIAtlasPacker(*param0_this);
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIAtlasPacker, true, false);
      }
    }
  }

  {
    // -2 LUIAtlasPacker::LUIAtlasPacker(std::size_t size)
    Py_ssize_t param0;
    static const char *keyword_list[] = {"size", nullptr};
    if (PyArg_ParseTupleAndKeywords(args, kwds, "n:LUIAtlasPacker", (char **)keyword_list, &param0)) {
#ifndef NDEBUG
      if (param0 < 0) {
        PyErr_Format(PyExc_OverflowError,
                     "can't convert negative value %zd to size_t",
                     param0);
        return -1;
      }
#endif
      LUIAtlasPacker *return_value = new LUIAtlasPacker((std::size_t)param0);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return -1;
      }
      return_value->ref();
      if (Dtool_CheckErrorOccurred()) {
        unref_delete(return_value);
        return -1;
      }
      return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIAtlasPacker, true, false);
    }
    PyErr_Clear();
  }

  {
    // -2 inline LUIAtlasPacker::LUIAtlasPacker(LUIAtlasPacker const &) = default
    PyObject *param0;
    if (Dtool_ExtractArg(&param0, args, kwds)) {
      CPT(LUIAtlasPacker) param0_this;
      if (Dtool_ConstCoerce_LUIAtlasPacker(param0, param0_this)) {
        LUIAtlasPacker *return_value = new LUIAtlasPacker(*std::move(param0_this));
        if (return_value == nullptr) {
          PyErr_NoMemory();
          return -1;
        }
        return_value->ref();
        if (Dtool_CheckErrorOccurred()) {
          unref_delete(return_value);
          return -1;
        }
        return DTool_PyInit_Finalize(self, (void *)return_value, &Dtool_LUIAtlasPacker, true, false);
      }
    }
  }

  // No coercion possible: LUIAtlasPacker::LUIAtlasPacker(std::size_t size)
  if (!_PyErr_OCCURRED()) {
    Dtool_Raise_BadArgumentsError(
      "LUIAtlasPacker(const LUIAtlasPacker param0)\n"
      "LUIAtlasPacker(int size)\n");
  }
  return -1;
}

bool Dtool_ConstCoerce_LUIAtlasPacker(PyObject *args, CPT(LUIAtlasPacker) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_LUIAtlasPacker)) {
    // The argument is already of matching type, no need to coerce.
    coerced->ref();
    return true;
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-LUIAtlasPacker::LUIAtlasPacker(std::size_t size)
    if (PyLongOrInt_Check(arg)) {
      size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
      if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
        return false;
      }
#endif
      LUIAtlasPacker *return_value = new LUIAtlasPacker(arg_val);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

bool Dtool_Coerce_LUIAtlasPacker(PyObject *args, PT(LUIAtlasPacker) &coerced) {
  if (DtoolInstance_GetPointer(args, coerced.cheat(), Dtool_LUIAtlasPacker)) {
    // The argument is already of matching type, no need to coerce.
    if (!DtoolInstance_IS_CONST(args)) {
      // A non-const instance is required, which this is.
      coerced->ref();
      return true;
    }
  }

  if (!PyTuple_Check(args)) {
    PyObject *arg = args;
    // 1-LUIAtlasPacker::LUIAtlasPacker(std::size_t size)
    if (PyLongOrInt_Check(arg)) {
      size_t arg_val = PyLongOrInt_AsSize_t(arg);
#ifndef NDEBUG
      if (arg_val == (size_t)-1 && _PyErr_OCCURRED()) {
        return false;
      }
#endif
      LUIAtlasPacker *return_value = new LUIAtlasPacker(arg_val);
      if (return_value == nullptr) {
        PyErr_NoMemory();
        return false;
      }
      return_value->ref();
      if (_PyErr_OCCURRED()) {
        unref_delete(return_value);
        return false;
      } else {
        coerced = std::move(return_value);
        return true;
      }
    }
  }
  return false;
}

static void *Dtool_UpcastInterface_LUIAtlasPacker(PyObject *self, Dtool_PyTypedObject *requested_type) {
  Dtool_PyTypedObject *type = DtoolInstance_TYPE(self);
  if (type != &Dtool_LUIAtlasPacker) {
    printf("LUIAtlasPacker ** Bad Source Type-- Requesting Conversion from %s to %s\n", Py_TYPE(self)->tp_name, requested_type->_PyType.tp_name); fflush(nullptr);
    return nullptr;
  }

  LUIAtlasPacker *local_this = (LUIAtlasPacker *)DtoolInstance_VOID_PTR(self);
  if (requested_type == &Dtool_LUIAtlasPacker) {
    return local_this;
  }
  if (requested_type == Dtool_Ptr_ReferenceCount) {
    return (ReferenceCount *) local_this;
  }
  return nullptr;
}

static void *Dtool_DowncastInterface_LUIAtlasPacker(void *from_this, Dtool_PyTypedObject *from_type) {
  if (from_this == nullptr || from_type == nullptr) {
    return nullptr;
  }
  if (from_type == Dtool_Ptr_LUIAtlasPacker) {
    return from_this;
  }
  if (from_type == Dtool_Ptr_ReferenceCount) {
    ReferenceCount* other_this = (ReferenceCount*)from_this;
    return (LUIAtlasPacker*)other_this;
  }
  return nullptr;
}

/**
 * Python method tables for LUIColorable (LUIColorable)
 */
static PyMethodDef Dtool_Methods_LUIColorable[] = {
  {"set_color", (PyCFunction) &Dtool_LUIColorable_set_color_2, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LUIColorable_set_color_2_comment},
  {"set_red", &Dtool_LUIColorable_set_red_3, METH_O, (const char *)Dtool_LUIColorable_set_red_3_comment},
  {"set_green", &Dtool_LUIColorable_set_green_4, METH_O, (const char *)Dtool_LUIColorable_set_green_4_comment},
  {"set_blue", &Dtool_LUIColorable_set_blue_5, METH_O, (const char *)Dtool_LUIColorable_set_blue_5_comment},
  {"set_alpha", &Dtool_LUIColorable_set_alpha_6, METH_O, (const char *)Dtool_LUIColorable_set_alpha_6_comment},
  {"get_red", &Dtool_LUIColorable_get_red_7, METH_NOARGS, (const char *)Dtool_LUIColorable_get_red_7_comment},
  {"get_green", &Dtool_LUIColorable_get_green_8, METH_NOARGS, (const char *)Dtool_LUIColorable_get_green_8_comment},
  {"get_blue", &Dtool_LUIColorable_get_blue_9, METH_NOARGS, (const char *)Dtool_LUIColorable_get_blue_9_comment},
  {"get_alpha", &Dtool_LUIColorable_get_alpha_10, METH_NOARGS, (const char *)Dtool_LUIColorable_get_alpha_10_comment},
  {"get_color", &Dtool_LUIColorable_get_color_11, METH_NOARGS, (const char *)Dtool_LUIColorable_get_color_11_comment},
  {"get_composed_color", &Dtool_LUIColorable_get_composed_color_12, METH_NOARGS, (const char *)Dtool_LUIColorable_get_composed_color_12_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_LUIColorable[] = {
  {(char *)"color", &Dtool_LUIColorable_color_Getter, &Dtool_LUIColorable_color_Setter, (char *)
    "// Python properties",
    nullptr},
  {(char *)"composed_color", &Dtool_LUIColorable_composed_color_Getter, nullptr, nullptr, nullptr},
  {(char *)"red", &Dtool_LUIColorable_red_Getter, &Dtool_LUIColorable_red_Setter, nullptr, nullptr},
  {(char *)"green", &Dtool_LUIColorable_green_Getter, &Dtool_LUIColorable_green_Setter, nullptr, nullptr},
  {(char *)"blue", &Dtool_LUIColorable_blue_Getter, &Dtool_LUIColorable_blue_Setter, nullptr, nullptr},
  {(char *)"alpha", &Dtool_LUIColorable_alpha_Getter, &Dtool_LUIColorable_alpha_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_LUIColorable = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_LUIColorable = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "lui.LUIColorable",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LUIColorable,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LUIColorable,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LUIColorable,
    nullptr, // tp_members
    Dtool_Properties_LUIColorable,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LUIColorable,
    PyType_GenericAlloc,
    Dtool_new_LUIColorable,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LUIColorable,
  Dtool_UpcastInterface_LUIColorable,
  Dtool_DowncastInterface_LUIColorable,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LUIColorable(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LUIColorable._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LUIColorable._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LUIColorable) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LUIColorable)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LUIColorable);
  }
}

/**
 * Python method tables for LUIBounds (LUIBounds)
 */
static PyMethodDef Dtool_Methods_LUIBounds[] = {
  {"get_top", &Dtool_LUIBounds_get_top_26, METH_NOARGS, (const char *)Dtool_LUIBounds_get_top_26_comment},
  {"get_right", &Dtool_LUIBounds_get_right_27, METH_NOARGS, (const char *)Dtool_LUIBounds_get_right_27_comment},
  {"get_bottom", &Dtool_LUIBounds_get_bottom_28, METH_NOARGS, (const char *)Dtool_LUIBounds_get_bottom_28_comment},
  {"get_left", &Dtool_LUIBounds_get_left_29, METH_NOARGS, (const char *)Dtool_LUIBounds_get_left_29_comment},
  {"set_top", &Dtool_LUIBounds_set_top_30, METH_O, (const char *)Dtool_LUIBounds_set_top_30_comment},
  {"set_right", &Dtool_LUIBounds_set_right_31, METH_O, (const char *)Dtool_LUIBounds_set_right_31_comment},
  {"set_bottom", &Dtool_LUIBounds_set_bottom_32, METH_O, (const char *)Dtool_LUIBounds_set_bottom_32_comment},
  {"set_left", &Dtool_LUIBounds_set_left_33, METH_O, (const char *)Dtool_LUIBounds_set_left_33_comment},
  {"set_bounds", (PyCFunction) &Dtool_LUIBounds_set_bounds_34, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LUIBounds_set_bounds_34_comment},
  {"get_bounds", &Dtool_LUIBounds_get_bounds_35, METH_NOARGS, (const char *)Dtool_LUIBounds_get_bounds_35_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_LUIBounds[] = {
  {(char *)"top", &Dtool_LUIBounds_top_Getter, &Dtool_LUIBounds_top_Setter, nullptr, nullptr},
  {(char *)"right", &Dtool_LUIBounds_right_Getter, &Dtool_LUIBounds_right_Setter, nullptr, nullptr},
  {(char *)"bottom", &Dtool_LUIBounds_bottom_Getter, &Dtool_LUIBounds_bottom_Setter, nullptr, nullptr},
  {(char *)"left", &Dtool_LUIBounds_left_Getter, &Dtool_LUIBounds_left_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_LUIBounds = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_LUIBounds = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "lui.LUIBounds",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LUIBounds,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LUIBounds,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LUIBounds,
    nullptr, // tp_members
    Dtool_Properties_LUIBounds,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LUIBounds,
    PyType_GenericAlloc,
    Dtool_new_LUIBounds,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LUIBounds,
  Dtool_UpcastInterface_LUIBounds,
  Dtool_DowncastInterface_LUIBounds,
  nullptr,
  (CoerceFunction)Dtool_Coerce_LUIBounds,
};

static void Dtool_PyModuleClassInit_LUIBounds(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LUIBounds._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LUIBounds._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LUIBounds) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LUIBounds)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LUIBounds);
  }
}

/**
 * Python method tables for LUIRect (LUIRect)
 */
static PyMethodDef Dtool_Methods_LUIRect[] = {
  {"get_x", &Dtool_LUIRect_get_x_43, METH_NOARGS, (const char *)Dtool_LUIRect_get_x_43_comment},
  {"get_y", &Dtool_LUIRect_get_y_44, METH_NOARGS, (const char *)Dtool_LUIRect_get_y_44_comment},
  {"get_w", &Dtool_LUIRect_get_w_45, METH_NOARGS, (const char *)Dtool_LUIRect_get_w_45_comment},
  {"get_h", &Dtool_LUIRect_get_h_46, METH_NOARGS, (const char *)Dtool_LUIRect_get_h_46_comment},
  {"get_xy", &Dtool_LUIRect_get_xy_47, METH_NOARGS, (const char *)Dtool_LUIRect_get_xy_47_comment},
  {"get_wh", &Dtool_LUIRect_get_wh_48, METH_NOARGS, (const char *)Dtool_LUIRect_get_wh_48_comment},
  {"set_x", &Dtool_LUIRect_set_x_49, METH_O, (const char *)Dtool_LUIRect_set_x_49_comment},
  {"set_y", &Dtool_LUIRect_set_y_50, METH_O, (const char *)Dtool_LUIRect_set_y_50_comment},
  {"set_w", &Dtool_LUIRect_set_w_51, METH_O, (const char *)Dtool_LUIRect_set_w_51_comment},
  {"set_h", &Dtool_LUIRect_set_h_52, METH_O, (const char *)Dtool_LUIRect_set_h_52_comment},
  {"set_rect", (PyCFunction) &Dtool_LUIRect_set_rect_53, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LUIRect_set_rect_53_comment},
  {"get_rect", &Dtool_LUIRect_get_rect_54, METH_NOARGS, (const char *)Dtool_LUIRect_get_rect_54_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_LUIRect[] = {
  {(char *)"x", &Dtool_LUIRect_x_Getter, &Dtool_LUIRect_x_Setter, nullptr, nullptr},
  {(char *)"y", &Dtool_LUIRect_y_Getter, &Dtool_LUIRect_y_Setter, nullptr, nullptr},
  {(char *)"w", &Dtool_LUIRect_w_Getter, &Dtool_LUIRect_w_Setter, nullptr, nullptr},
  {(char *)"h", &Dtool_LUIRect_h_Getter, &Dtool_LUIRect_h_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_LUIRect = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_LUIRect = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "lui.LUIRect",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LUIRect,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LUIRect,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LUIRect,
    nullptr, // tp_members
    Dtool_Properties_LUIRect,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LUIRect,
    PyType_GenericAlloc,
    Dtool_new_LUIRect,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LUIRect,
  Dtool_UpcastInterface_LUIRect,
  Dtool_DowncastInterface_LUIRect,
  nullptr,
  (CoerceFunction)Dtool_Coerce_LUIRect,
};

static void Dtool_PyModuleClassInit_LUIRect(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LUIRect._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LUIRect._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LUIRect) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LUIRect)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LUIRect);
  }
}

/**
 * Python method tables for LUIBaseElement (LUIBaseElement)
 */
static PyMethodDef Dtool_Methods_LUIBaseElement[] = {
  {"bind", (PyCFunction) &Dtool_LUIBaseElement_bind_67, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LUIBaseElement_bind_67_comment},
  {"unbind", &Dtool_LUIBaseElement_unbind_68, METH_O, (const char *)Dtool_LUIBaseElement_unbind_68_comment},
  {"unbind_all", &Dtool_LUIBaseElement_unbind_all_69, METH_NOARGS, (const char *)Dtool_LUIBaseElement_unbind_all_69_comment},
  {"has_event", &Dtool_LUIBaseElement_has_event_70, METH_O, (const char *)Dtool_LUIBaseElement_has_event_70_comment},
  {"trigger_event", (PyCFunction) &Dtool_LUIBaseElement_trigger_event_71, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LUIBaseElement_trigger_event_71_comment},
  {"set_name", &Dtool_LUIBaseElement_set_name_72, METH_O, (const char *)Dtool_LUIBaseElement_set_name_72_comment},
  {"get_name", &Dtool_LUIBaseElement_get_name_73, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_name_73_comment},
  {"set_top_left", &Dtool_LUIBaseElement_set_top_left_74, METH_O, (const char *)Dtool_LUIBaseElement_set_top_left_74_comment},
  {"set_top_right", &Dtool_LUIBaseElement_set_top_right_75, METH_O, (const char *)Dtool_LUIBaseElement_set_top_right_75_comment},
  {"set_bottom_left", &Dtool_LUIBaseElement_set_bottom_left_76, METH_O, (const char *)Dtool_LUIBaseElement_set_bottom_left_76_comment},
  {"set_bottom_right", &Dtool_LUIBaseElement_set_bottom_right_77, METH_O, (const char *)Dtool_LUIBaseElement_set_bottom_right_77_comment},
  {"get_top_left", &Dtool_LUIBaseElement_get_top_left_78, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_top_left_78_comment},
  {"get_top_right", &Dtool_LUIBaseElement_get_top_right_79, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_top_right_79_comment},
  {"get_bottom_left", &Dtool_LUIBaseElement_get_bottom_left_80, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_bottom_left_80_comment},
  {"get_bottom_right", &Dtool_LUIBaseElement_get_bottom_right_81, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_bottom_right_81_comment},
  {"set_pos", (PyCFunction) &Dtool_LUIBaseElement_set_pos_82, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LUIBaseElement_set_pos_82_comment},
  {"get_pos", &Dtool_LUIBaseElement_get_pos_83, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_pos_83_comment},
  {"get_abs_pos", &Dtool_LUIBaseElement_get_abs_pos_84, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_abs_pos_84_comment},
  {"set_top", &Dtool_LUIBaseElement_set_top_85, METH_O, (const char *)Dtool_LUIBaseElement_set_top_85_comment},
  {"set_right", &Dtool_LUIBaseElement_set_right_86, METH_O, (const char *)Dtool_LUIBaseElement_set_right_86_comment},
  {"set_bottom", &Dtool_LUIBaseElement_set_bottom_87, METH_O, (const char *)Dtool_LUIBaseElement_set_bottom_87_comment},
  {"set_left", &Dtool_LUIBaseElement_set_left_88, METH_O, (const char *)Dtool_LUIBaseElement_set_left_88_comment},
  {"get_top", &Dtool_LUIBaseElement_get_top_89, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_top_89_comment},
  {"get_right", &Dtool_LUIBaseElement_get_right_90, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_right_90_comment},
  {"get_bottom", &Dtool_LUIBaseElement_get_bottom_91, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_bottom_91_comment},
  {"get_left", &Dtool_LUIBaseElement_get_left_92, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_left_92_comment},
  {"set_centered", (PyCFunction) &Dtool_LUIBaseElement_set_centered_93, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LUIBaseElement_set_centered_93_comment},
  {"set_center_vertical", (PyCFunction) &Dtool_LUIBaseElement_set_center_vertical_94, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LUIBaseElement_set_center_vertical_94_comment},
  {"set_center_horizontal", (PyCFunction) &Dtool_LUIBaseElement_set_center_horizontal_95, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LUIBaseElement_set_center_horizontal_95_comment},
  {"is_centered", &Dtool_LUIBaseElement_is_centered_96, METH_NOARGS, (const char *)Dtool_LUIBaseElement_is_centered_96_comment},
  {"is_vertical_centered", &Dtool_LUIBaseElement_is_vertical_centered_97, METH_NOARGS, (const char *)Dtool_LUIBaseElement_is_vertical_centered_97_comment},
  {"is_horizontal_centered", &Dtool_LUIBaseElement_is_horizontal_centered_98, METH_NOARGS, (const char *)Dtool_LUIBaseElement_is_horizontal_centered_98_comment},
  {"set_margin", (PyCFunction) &Dtool_LUIBaseElement_set_margin_99, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LUIBaseElement_set_margin_99_comment},
  {"set_margin_top", &Dtool_LUIBaseElement_set_margin_top_100, METH_O, (const char *)Dtool_LUIBaseElement_set_margin_top_100_comment},
  {"set_margin_right", &Dtool_LUIBaseElement_set_margin_right_101, METH_O, (const char *)Dtool_LUIBaseElement_set_margin_right_101_comment},
  {"set_margin_bottom", &Dtool_LUIBaseElement_set_margin_bottom_102, METH_O, (const char *)Dtool_LUIBaseElement_set_margin_bottom_102_comment},
  {"set_margin_left", &Dtool_LUIBaseElement_set_margin_left_103, METH_O, (const char *)Dtool_LUIBaseElement_set_margin_left_103_comment},
  {"get_margin_top", &Dtool_LUIBaseElement_get_margin_top_104, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_margin_top_104_comment},
  {"get_margin_right", &Dtool_LUIBaseElement_get_margin_right_105, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_margin_right_105_comment},
  {"get_margin_bottom", &Dtool_LUIBaseElement_get_margin_bottom_106, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_margin_bottom_106_comment},
  {"get_margin_left", &Dtool_LUIBaseElement_get_margin_left_107, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_margin_left_107_comment},
  {"get_margin", &Dtool_LUIBaseElement_get_margin_108, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_margin_108_comment},
  {"set_padding", (PyCFunction) &Dtool_LUIBaseElement_set_padding_109, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LUIBaseElement_set_padding_109_comment},
  {"set_padding_top", &Dtool_LUIBaseElement_set_padding_top_110, METH_O, (const char *)Dtool_LUIBaseElement_set_padding_top_110_comment},
  {"set_padding_right", &Dtool_LUIBaseElement_set_padding_right_111, METH_O, (const char *)Dtool_LUIBaseElement_set_padding_right_111_comment},
  {"set_padding_bottom", &Dtool_LUIBaseElement_set_padding_bottom_112, METH_O, (const char *)Dtool_LUIBaseElement_set_padding_bottom_112_comment},
  {"set_padding_left", &Dtool_LUIBaseElement_set_padding_left_113, METH_O, (const char *)Dtool_LUIBaseElement_set_padding_left_113_comment},
  {"get_padding_top", &Dtool_LUIBaseElement_get_padding_top_114, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_padding_top_114_comment},
  {"get_padding_right", &Dtool_LUIBaseElement_get_padding_right_115, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_padding_right_115_comment},
  {"get_padding_bottom", &Dtool_LUIBaseElement_get_padding_bottom_116, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_padding_bottom_116_comment},
  {"get_padding_left", &Dtool_LUIBaseElement_get_padding_left_117, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_padding_left_117_comment},
  {"get_padding", &Dtool_LUIBaseElement_get_padding_118, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_padding_118_comment},
  {"set_size", (PyCFunction) &Dtool_LUIBaseElement_set_size_119, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LUIBaseElement_set_size_119_comment},
  {"set_width", &Dtool_LUIBaseElement_set_width_120, METH_O, (const char *)Dtool_LUIBaseElement_set_width_120_comment},
  {"set_height", &Dtool_LUIBaseElement_set_height_121, METH_O, (const char *)Dtool_LUIBaseElement_set_height_121_comment},
  {"get_width", &Dtool_LUIBaseElement_get_width_122, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_width_122_comment},
  {"get_height", &Dtool_LUIBaseElement_get_height_123, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_height_123_comment},
  {"clear_width", &Dtool_LUIBaseElement_clear_width_124, METH_NOARGS, (const char *)Dtool_LUIBaseElement_clear_width_124_comment},
  {"clear_height", &Dtool_LUIBaseElement_clear_height_125, METH_NOARGS, (const char *)Dtool_LUIBaseElement_clear_height_125_comment},
  {"clear_size", &Dtool_LUIBaseElement_clear_size_126, METH_NOARGS, (const char *)Dtool_LUIBaseElement_clear_size_126_comment},
  {"has_width", &Dtool_LUIBaseElement_has_width_127, METH_NOARGS, (const char *)Dtool_LUIBaseElement_has_width_127_comment},
  {"has_height", &Dtool_LUIBaseElement_has_height_128, METH_NOARGS, (const char *)Dtool_LUIBaseElement_has_height_128_comment},
  {"has_size", &Dtool_LUIBaseElement_has_size_129, METH_NOARGS, (const char *)Dtool_LUIBaseElement_has_size_129_comment},
  {"get_size", &Dtool_LUIBaseElement_get_size_130, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_size_130_comment},
  {"set_visible", &Dtool_LUIBaseElement_set_visible_131, METH_O, (const char *)Dtool_LUIBaseElement_set_visible_131_comment},
  {"is_visible", &Dtool_LUIBaseElement_is_visible_132, METH_NOARGS, (const char *)Dtool_LUIBaseElement_is_visible_132_comment},
  {"hide", &Dtool_LUIBaseElement_hide_133, METH_NOARGS, (const char *)Dtool_LUIBaseElement_hide_133_comment},
  {"show", &Dtool_LUIBaseElement_show_134, METH_NOARGS, (const char *)Dtool_LUIBaseElement_show_134_comment},
  {"set_solid", &Dtool_LUIBaseElement_set_solid_135, METH_O, (const char *)Dtool_LUIBaseElement_set_solid_135_comment},
  {"get_solid", &Dtool_LUIBaseElement_get_solid_136, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_solid_136_comment},
  {"set_z_offset", &Dtool_LUIBaseElement_set_z_offset_137, METH_O, (const char *)Dtool_LUIBaseElement_set_z_offset_137_comment},
  {"get_z_offset", &Dtool_LUIBaseElement_get_z_offset_138, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_z_offset_138_comment},
  {"has_focus", &Dtool_LUIBaseElement_has_focus_139, METH_NOARGS, (const char *)Dtool_LUIBaseElement_has_focus_139_comment},
  {"request_focus", &Dtool_LUIBaseElement_request_focus_140, METH_NOARGS, (const char *)Dtool_LUIBaseElement_request_focus_140_comment},
  {"blur", &Dtool_LUIBaseElement_blur_141, METH_NOARGS, (const char *)Dtool_LUIBaseElement_blur_141_comment},
  {"has_parent", &Dtool_LUIBaseElement_has_parent_142, METH_NOARGS, (const char *)Dtool_LUIBaseElement_has_parent_142_comment},
  {"clear_parent", &Dtool_LUIBaseElement_clear_parent_143, METH_NOARGS, (const char *)Dtool_LUIBaseElement_clear_parent_143_comment},
  {"set_parent", &Dtool_LUIBaseElement_set_parent_144, METH_O, (const char *)Dtool_LUIBaseElement_set_parent_144_comment},
  {"get_parent", &Dtool_LUIBaseElement_get_parent_145, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_parent_145_comment},
  {"intersects", (PyCFunction) &Dtool_LUIBaseElement_intersects_146, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LUIBaseElement_intersects_146_comment},
  {"clear_clip_bounds", &Dtool_LUIBaseElement_clear_clip_bounds_147, METH_NOARGS, (const char *)Dtool_LUIBaseElement_clear_clip_bounds_147_comment},
  {"set_clip_bounds", (PyCFunction) &Dtool_LUIBaseElement_set_clip_bounds_148, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LUIBaseElement_set_clip_bounds_148_comment},
  {"get_clip_bounds", &Dtool_LUIBaseElement_get_clip_bounds_149, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_clip_bounds_149_comment},
  {"get_abs_clip_bounds", &Dtool_LUIBaseElement_get_abs_clip_bounds_150, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_abs_clip_bounds_150_comment},
  {"is_topmost", &Dtool_LUIBaseElement_is_topmost_151, METH_NOARGS, (const char *)Dtool_LUIBaseElement_is_topmost_151_comment},
  {"set_topmost", &Dtool_LUIBaseElement_set_topmost_152, METH_O, (const char *)Dtool_LUIBaseElement_set_topmost_152_comment},
  {"get_relative_pos", &Dtool_LUIBaseElement_get_relative_pos_153, METH_O, (const char *)Dtool_LUIBaseElement_get_relative_pos_153_comment},
  {"set_debug_name", &Dtool_LUIBaseElement_set_debug_name_154, METH_O, (const char *)Dtool_LUIBaseElement_set_debug_name_154_comment},
  {"get_debug_name", &Dtool_LUIBaseElement_get_debug_name_155, METH_NOARGS, (const char *)Dtool_LUIBaseElement_get_debug_name_155_comment},
  {"get_class_type", &Dtool_LUIBaseElement_get_class_type_211, METH_NOARGS | METH_STATIC, (const char *)Dtool_LUIBaseElement_get_class_type_211_comment},
  {"upcast_to_TypedReferenceCount", &Dtool_LUIBaseElement_upcast_to_TypedReferenceCount_62, METH_NOARGS, (const char *)Dtool_LUIBaseElement_upcast_to_TypedReferenceCount_62_comment},
  {"upcast_to_LUIColorable", &Dtool_LUIBaseElement_upcast_to_LUIColorable_64, METH_NOARGS, (const char *)Dtool_LUIBaseElement_upcast_to_LUIColorable_64_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_LUIBaseElement[] = {
  {(char *)"name", &Dtool_LUIBaseElement_name_Getter, &Dtool_LUIBaseElement_name_Setter, (char *)
    "// Properties for python",
    nullptr},
  {(char *)"debug_name", &Dtool_LUIBaseElement_debug_name_Getter, &Dtool_LUIBaseElement_debug_name_Setter, nullptr, nullptr},
  {(char *)"top_left", &Dtool_LUIBaseElement_top_left_Getter, &Dtool_LUIBaseElement_top_left_Setter, nullptr, nullptr},
  {(char *)"top_right", &Dtool_LUIBaseElement_top_right_Getter, &Dtool_LUIBaseElement_top_right_Setter, nullptr, nullptr},
  {(char *)"bottom_left", &Dtool_LUIBaseElement_bottom_left_Getter, &Dtool_LUIBaseElement_bottom_left_Setter, nullptr, nullptr},
  {(char *)"bottom_right", &Dtool_LUIBaseElement_bottom_right_Getter, &Dtool_LUIBaseElement_bottom_right_Setter, nullptr, nullptr},
  {(char *)"pos", &Dtool_LUIBaseElement_pos_Getter, &Dtool_LUIBaseElement_pos_Setter, nullptr, nullptr},
  {(char *)"abs_pos", &Dtool_LUIBaseElement_abs_pos_Getter, nullptr, nullptr, nullptr},
  {(char *)"top", &Dtool_LUIBaseElement_top_Getter, &Dtool_LUIBaseElement_top_Setter, nullptr, nullptr},
  {(char *)"bottom", &Dtool_LUIBaseElement_bottom_Getter, &Dtool_LUIBaseElement_bottom_Setter, nullptr, nullptr},
  {(char *)"left", &Dtool_LUIBaseElement_left_Getter, &Dtool_LUIBaseElement_left_Setter, nullptr, nullptr},
  {(char *)"right", &Dtool_LUIBaseElement_right_Getter, &Dtool_LUIBaseElement_right_Setter, nullptr, nullptr},
  {(char *)"centered", &Dtool_LUIBaseElement_centered_Getter, &Dtool_LUIBaseElement_centered_Setter, nullptr, nullptr},
  {(char *)"center_vertical", &Dtool_LUIBaseElement_center_vertical_Getter, &Dtool_LUIBaseElement_center_vertical_Setter, nullptr, nullptr},
  {(char *)"center_horizontal", &Dtool_LUIBaseElement_center_horizontal_Getter, &Dtool_LUIBaseElement_center_horizontal_Setter, nullptr, nullptr},
  {(char *)"margin", &Dtool_LUIBaseElement_margin_Getter, &Dtool_LUIBaseElement_margin_Setter, nullptr, nullptr},
  {(char *)"padding", &Dtool_LUIBaseElement_padding_Getter, &Dtool_LUIBaseElement_padding_Setter, nullptr, nullptr},
  {(char *)"size", &Dtool_LUIBaseElement_size_Getter, &Dtool_LUIBaseElement_size_Setter, nullptr, nullptr},
  {(char *)"width", &Dtool_LUIBaseElement_width_Getter, &Dtool_LUIBaseElement_width_Setter, nullptr, nullptr},
  {(char *)"height", &Dtool_LUIBaseElement_height_Getter, &Dtool_LUIBaseElement_height_Setter, nullptr, nullptr},
  {(char *)"visible", &Dtool_LUIBaseElement_visible_Getter, &Dtool_LUIBaseElement_visible_Setter, nullptr, nullptr},
  {(char *)"z_offset", &Dtool_LUIBaseElement_z_offset_Getter, &Dtool_LUIBaseElement_z_offset_Setter, nullptr, nullptr},
  {(char *)"focused", &Dtool_LUIBaseElement_focused_Getter, nullptr, (char *)
    "// Focus",
    nullptr},
  {(char *)"parent", &Dtool_LUIBaseElement_parent_Getter, &Dtool_LUIBaseElement_parent_Setter, nullptr, nullptr},
  {(char *)"clip_bounds", &Dtool_LUIBaseElement_clip_bounds_Getter, &Dtool_LUIBaseElement_clip_bounds_Setter, nullptr, nullptr},
  {(char *)"topmost", &Dtool_LUIBaseElement_topmost_Getter, &Dtool_LUIBaseElement_topmost_Setter, nullptr, nullptr},
  {(char *)"solid", &Dtool_LUIBaseElement_solid_Getter, &Dtool_LUIBaseElement_solid_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_LUIBaseElement = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LUIBaseElement = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LUIBaseElement = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LUIBaseElement = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LUIBaseElement = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LUIBaseElement = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "lui.LUIBaseElement",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LUIBaseElement,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LUIBaseElement,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LUIBaseElement,
    &Dtool_SequenceMethods_LUIBaseElement,
    &Dtool_MappingMethods_LUIBaseElement,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LUIBaseElement,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * @brief Base class for all LUI objects\n"
    " * @details This is the base class from which every LUI object derives. It stores\n"
    " *   information like the position, alignment and size, and also defines a common\n"
    " *   interface.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LUIBaseElement,
    nullptr, // tp_members
    Dtool_Properties_LUIBaseElement,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LUIBaseElement,
    PyType_GenericAlloc,
    Dtool_new_LUIBaseElement,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LUIBaseElement,
  Dtool_UpcastInterface_LUIBaseElement,
  Dtool_DowncastInterface_LUIBaseElement,
  (CoerceFunction)Dtool_ConstCoerce_LUIBaseElement,
  (CoerceFunction)Dtool_Coerce_LUIBaseElement,
};

static void Dtool_PyModuleClassInit_LUIBaseElement(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_TypedReferenceCount != nullptr);
    assert(Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_TypedReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_PyModuleClassInit_LUIColorable(nullptr);
    Dtool_LUIBaseElement._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_TypedReferenceCount, (PyTypeObject *)&Dtool_LUIColorable);
    PyObject *dict = PyDict_New();
    Dtool_LUIBaseElement._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LUIBaseElement) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LUIBaseElement)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LUIBaseElement);
  }
}

/**
 * Python method tables for LUIObject (LUIObject)
 */
static PyMethodDef Dtool_Methods_LUIObject[] = {
  {"get_children", &Dtool_LUIObject_get_children_191, METH_NOARGS, (const char *)Dtool_LUIObject_get_children_191_comment},
  {"get_child", &Dtool_LUIObject_get_child_192, METH_O, (const char *)Dtool_LUIObject_get_child_192_comment},
  {"add_child", &Dtool_LUIObject_add_child_193, METH_O, (const char *)Dtool_LUIObject_add_child_193_comment},
  {"remove_child", &Dtool_LUIObject_remove_child_194, METH_O, (const char *)Dtool_LUIObject_remove_child_194_comment},
  {"remove_all_children", &Dtool_LUIObject_remove_all_children_195, METH_NOARGS, (const char *)Dtool_LUIObject_remove_all_children_195_comment},
  {"get_child_count", &Dtool_LUIObject_get_child_count_196, METH_NOARGS, (const char *)Dtool_LUIObject_get_child_count_196_comment},
  {"set_content_node", &Dtool_LUIObject_set_content_node_197, METH_O, (const char *)Dtool_LUIObject_set_content_node_197_comment},
  {"get_content_node", &Dtool_LUIObject_get_content_node_198, METH_NOARGS, (const char *)Dtool_LUIObject_get_content_node_198_comment},
  {"ls", (PyCFunction) &Dtool_LUIObject_ls_199, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LUIObject_ls_199_comment},
  {"get_class_type", &Dtool_LUIObject_get_class_type_206, METH_NOARGS | METH_STATIC, (const char *)Dtool_LUIObject_get_class_type_206_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_LUIObject[] = {
  {(char *)"children", &Dtool_LUIObject_children_Getter, nullptr, (char *)
    "// Python properties",
    nullptr},
  {(char *)"child_count", &Dtool_LUIObject_child_count_Getter, nullptr, nullptr, nullptr},
  {(char *)"content_node", &Dtool_LUIObject_content_node_Getter, &Dtool_LUIObject_content_node_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_LUIObject = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LUIObject = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LUIObject = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LUIObject = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LUIObject = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LUIObject = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "lui.LUIObject",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LUIObject,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LUIObject,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LUIObject,
    &Dtool_SequenceMethods_LUIObject,
    &Dtool_MappingMethods_LUIObject,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LUIObject,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LUIObject,
    nullptr, // tp_members
    Dtool_Properties_LUIObject,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LUIObject,
    PyType_GenericAlloc,
    Dtool_new_LUIObject,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LUIObject,
  Dtool_UpcastInterface_LUIObject,
  Dtool_DowncastInterface_LUIObject,
  (CoerceFunction)Dtool_ConstCoerce_LUIObject,
  (CoerceFunction)Dtool_Coerce_LUIObject,
};

static void Dtool_PyModuleClassInit_LUIObject(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LUIBaseElement(nullptr);
    Dtool_LUIObject._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LUIBaseElement);
    PyObject *dict = PyDict_New();
    Dtool_LUIObject._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LUIObject) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LUIObject)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LUIObject);
  }
}

/**
 * Python method tables for LUIAtlas (LUIAtlas)
 */
static PyMethodDef Dtool_Methods_LUIAtlas[] = {
  {"load_descriptor_file", &Dtool_LUIAtlas_load_descriptor_file_214, METH_O, (const char *)Dtool_LUIAtlas_load_descriptor_file_214_comment},
  {"load_texture", &Dtool_LUIAtlas_load_texture_215, METH_O, (const char *)Dtool_LUIAtlas_load_texture_215_comment},
  {"get_texture", &Dtool_LUIAtlas_get_texture_216, METH_NOARGS, (const char *)Dtool_LUIAtlas_get_texture_216_comment},
  {"has_entry", &Dtool_LUIAtlas_has_entry_217, METH_O, (const char *)Dtool_LUIAtlas_has_entry_217_comment},
  {"get_size", &Dtool_LUIAtlas_get_size_219, METH_NOARGS, (const char *)Dtool_LUIAtlas_get_size_219_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LUIAtlas = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LUIAtlas = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LUIAtlas = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LUIAtlas = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LUIAtlas = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LUIAtlas = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "lui.LUIAtlas",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LUIAtlas,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LUIAtlas,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LUIAtlas,
    &Dtool_SequenceMethods_LUIAtlas,
    &Dtool_MappingMethods_LUIAtlas,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LUIAtlas,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * @brief This is the container class for an atlas\n"
    " * @details This class manages the storage of a single atlas texture, including\n"
    " *   storing a reference to the atlas texture, the atlas size, and the atlas entries.\n"
    " *   It provides functions to load atlas descriptions generated by LUIAtlasGen too.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LUIAtlas,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LUIAtlas,
    PyType_GenericAlloc,
    Dtool_new_LUIAtlas,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LUIAtlas,
  Dtool_UpcastInterface_LUIAtlas,
  Dtool_DowncastInterface_LUIAtlas,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LUIAtlas(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_LUIAtlas._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_LUIAtlas._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LUIAtlas) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LUIAtlas)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LUIAtlas);
  }
}

/**
 * Python method tables for LUIAtlasPool (LUIAtlasPool)
 */
static PyMethodDef Dtool_Methods_LUIAtlasPool[] = {
  {"get_global_ptr", &Dtool_LUIAtlasPool_get_global_ptr_223, METH_NOARGS | METH_STATIC, (const char *)Dtool_LUIAtlasPool_get_global_ptr_223_comment},
  {"load_atlas", (PyCFunction) &Dtool_LUIAtlasPool_load_atlas_224, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LUIAtlasPool_load_atlas_224_comment},
  {"has_atlas", &Dtool_LUIAtlasPool_has_atlas_225, METH_O, (const char *)Dtool_LUIAtlasPool_has_atlas_225_comment},
  {"get_atlas", &Dtool_LUIAtlasPool_get_atlas_226, METH_O, (const char *)Dtool_LUIAtlasPool_get_atlas_226_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LUIAtlasPool = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_LUIAtlasPool = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "lui.LUIAtlasPool",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LUIAtlasPool,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LUIAtlasPool,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * @brief Globals storage for multiple atlases\n"
    " * @details This class stores all atlases, and keeps a reference to them. It also\n"
    " *   provides methods to get a descriptor from a given entry name and atlas name.\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LUIAtlasPool,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LUIAtlasPool,
    PyType_GenericAlloc,
    Dtool_new_LUIAtlasPool,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LUIAtlasPool,
  Dtool_UpcastInterface_LUIAtlasPool,
  Dtool_DowncastInterface_LUIAtlasPool,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LUIAtlasPool(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LUIAtlasPool._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LUIAtlasPool._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LUIAtlasPool) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LUIAtlasPool)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LUIAtlasPool);
  }
}

/**
 * Python method tables for LUISprite (LUISprite)
 */
static PyMethodDef Dtool_Methods_LUISprite[] = {
  {"set_uv_range", (PyCFunction) &Dtool_LUISprite_set_uv_range_232, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LUISprite_set_uv_range_232_comment},
  {"get_uv_begin", &Dtool_LUISprite_get_uv_begin_233, METH_NOARGS, (const char *)Dtool_LUISprite_get_uv_begin_233_comment},
  {"get_uv_end", &Dtool_LUISprite_get_uv_end_234, METH_NOARGS, (const char *)Dtool_LUISprite_get_uv_end_234_comment},
  {"set_texture", (PyCFunction) &Dtool_LUISprite_set_texture_235, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LUISprite_set_texture_235_comment},
  {"get_texture", &Dtool_LUISprite_get_texture_236, METH_NOARGS, (const char *)Dtool_LUISprite_get_texture_236_comment},
  {"print_vertices", &Dtool_LUISprite_print_vertices_237, METH_NOARGS, (const char *)Dtool_LUISprite_print_vertices_237_comment},
  {"ls", (PyCFunction) &Dtool_LUISprite_ls_238, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LUISprite_ls_238_comment},
  {"get_class_type", &Dtool_LUISprite_get_class_type_242, METH_NOARGS | METH_STATIC, (const char *)Dtool_LUISprite_get_class_type_242_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_LUISprite[] = {
  {(char *)"texture", &Dtool_LUISprite_texture_Getter, nullptr, (char *)
    "// Python properties",
    nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_LUISprite = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LUISprite = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LUISprite = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LUISprite = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LUISprite = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LUISprite = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "lui.LUISprite",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LUISprite,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LUISprite,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LUISprite,
    &Dtool_SequenceMethods_LUISprite,
    &Dtool_MappingMethods_LUISprite,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LUISprite,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "////////////////////////////////////////////////////////////////////\n"
    "//       Class : LUISprite\n"
    "// Description : A LUISprite stores a single card, including position,\n"
    "//               scale, and uv coordinates. It also notifies the\n"
    "//               LUIVertexPool when any scalar or texture got changed.\n"
    "////////////////////////////////////////////////////////////////////",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LUISprite,
    nullptr, // tp_members
    Dtool_Properties_LUISprite,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LUISprite,
    PyType_GenericAlloc,
    Dtool_new_LUISprite,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LUISprite,
  Dtool_UpcastInterface_LUISprite,
  Dtool_DowncastInterface_LUISprite,
  (CoerceFunction)Dtool_ConstCoerce_LUISprite,
  (CoerceFunction)Dtool_Coerce_LUISprite,
};

static void Dtool_PyModuleClassInit_LUISprite(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LUIBaseElement(nullptr);
    Dtool_LUISprite._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LUIBaseElement);
    PyObject *dict = PyDict_New();
    Dtool_LUISprite._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LUISprite) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LUISprite)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LUISprite);
  }
}

/**
 * Python method tables for LUIElementIterator (LUIElementIterator)
 */
static PyMethodDef Dtool_Methods_LUIElementIterator[] = {
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LUIElementIterator slot tp_iter -> __iter__
//////////////////
static PyObject *Dtool_LUIElementIterator_iter_245_tp_iter(PyObject *self) {
  LUIElementIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIElementIterator, (void **)&local_this)) {
    return nullptr;
  }

  if (!DtoolInstance_IS_CONST(self)) {
    // 1-inline LUIElementIterator &LUIElementIterator::__iter__(void)
    LUIElementIterator *return_value = &(((*local_this).__iter__)());
    if (return_value != nullptr) {
      return_value->ref();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return Dtool_Raise_AssertionError();
    }
#endif
    return DTool_CreatePyInstance((void *)return_value, *Dtool_Ptr_LUIElementIterator, true, false);
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LUIElementIterator.__iter__() on a const object.");
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__iter__(const LUIElementIterator self)\n");
  }
  return nullptr;
}

//////////////////
// A wrapper function to satisfy Python's internal calling conventions.
// LUIElementIterator slot tp_iternext -> __next__
//////////////////
static PyObject *Dtool_LUIElementIterator_next_244_tp_iternext(PyObject *self) {
  LUIElementIterator *local_this = nullptr;
  if (!Dtool_Call_ExtractThisPointer(self, Dtool_LUIElementIterator, (void **)&local_this)) {
    return nullptr;
  }

  if (!DtoolInstance_IS_CONST(self)) {
    // 1-inline LUIBaseElement *LUIElementIterator::__next__(void)
    LUIBaseElement *return_value = ((*local_this).__next__)();
    if (return_value != nullptr) {
      return_value->ref();
    }
#ifndef NDEBUG
    Notify *notify = Notify::ptr();
    if (UNLIKELY(notify->has_assert_failed())) {
      if (return_value != nullptr) {
        unref_delete(return_value);
      }
      return Dtool_Raise_AssertionError();
    }
#endif
    if (return_value == nullptr) {
      return nullptr;
    } else {
      if (return_value == nullptr) {
        Py_INCREF(Py_None);
        return Py_None;
      } else {
        return DTool_CreatePyInstanceTyped((void *)return_value, *Dtool_Ptr_LUIBaseElement, true, false, return_value->as_typed_object()->get_type_index());
      }
    }
  } else {
#ifdef NDEBUG
    return Dtool_Raise_TypeError("non-const method called on const object");
#else
    return Dtool_Raise_TypeError("Cannot call LUIElementIterator.__next__() on a const object.");
#endif
  }
  if (!_PyErr_OCCURRED()) {
    return Dtool_Raise_BadArgumentsError(
      "__next__(const LUIElementIterator self)\n");
  }
  return nullptr;
}

static PyNumberMethods Dtool_NumberMethods_LUIElementIterator = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LUIElementIterator = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LUIElementIterator = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LUIElementIterator = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LUIElementIterator = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LUIElementIterator = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "lui.LUIElementIterator",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LUIElementIterator,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LUIElementIterator,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LUIElementIterator,
    &Dtool_SequenceMethods_LUIElementIterator,
    &Dtool_MappingMethods_LUIElementIterator,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LUIElementIterator,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    &Dtool_LUIElementIterator_iter_245_tp_iter,
    &Dtool_LUIElementIterator_next_244_tp_iternext,
    Dtool_Methods_LUIElementIterator,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LUIElementIterator,
    PyType_GenericAlloc,
    Dtool_new_LUIElementIterator,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LUIElementIterator,
  Dtool_UpcastInterface_LUIElementIterator,
  Dtool_DowncastInterface_LUIElementIterator,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LUIElementIterator(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_LUIElementIterator._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_LUIElementIterator._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LUIElementIterator) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LUIElementIterator)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LUIElementIterator);
  }
}

/**
 * Python method tables for LUIRoot (LUIRoot)
 */
static PyMethodDef Dtool_Methods_LUIRoot[] = {
  {"node", &Dtool_LUIRoot_node_249, METH_NOARGS, (const char *)Dtool_LUIRoot_node_249_comment},
  {"set_use_glsl_130", &Dtool_LUIRoot_set_use_glsl_130_250, METH_O | METH_STATIC, (const char *)Dtool_LUIRoot_set_use_glsl_130_250_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LUIRoot = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LUIRoot = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LUIRoot = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LUIRoot = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LUIRoot = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LUIRoot = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "lui.LUIRoot",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LUIRoot,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LUIRoot,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LUIRoot,
    &Dtool_SequenceMethods_LUIRoot,
    &Dtool_MappingMethods_LUIRoot,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LUIRoot,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LUIRoot,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LUIRoot,
    PyType_GenericAlloc,
    Dtool_new_LUIRoot,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LUIRoot,
  Dtool_UpcastInterface_LUIRoot,
  Dtool_DowncastInterface_LUIRoot,
  (CoerceFunction)Dtool_ConstCoerce_LUIRoot,
  (CoerceFunction)Dtool_Coerce_LUIRoot,
};

static void Dtool_PyModuleClassInit_LUIRoot(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_LUIRoot._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_LUIRoot._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LUIRoot) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LUIRoot)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LUIRoot);
  }
}

/**
 * Python method tables for LUIInputHandler (LUIInputHandler)
 */
static PyMethodDef Dtool_Methods_LUIInputHandler[] = {
  {"get_class_type", &Dtool_LUIInputHandler_get_class_type_254, METH_NOARGS | METH_STATIC, (const char *)Dtool_LUIInputHandler_get_class_type_254_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LUIInputHandler = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LUIInputHandler = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LUIInputHandler = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LUIInputHandler = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LUIInputHandler = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LUIInputHandler = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "lui.LUIInputHandler",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LUIInputHandler,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LUIInputHandler,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LUIInputHandler,
    &Dtool_SequenceMethods_LUIInputHandler,
    &Dtool_MappingMethods_LUIInputHandler,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LUIInputHandler,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LUIInputHandler,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LUIInputHandler,
    PyType_GenericAlloc,
    Dtool_new_LUIInputHandler,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LUIInputHandler,
  Dtool_UpcastInterface_LUIInputHandler,
  Dtool_DowncastInterface_LUIInputHandler,
  (CoerceFunction)Dtool_ConstCoerce_LUIInputHandler,
  (CoerceFunction)Dtool_Coerce_LUIInputHandler,
};

static void Dtool_PyModuleClassInit_LUIInputHandler(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DataNode != nullptr);
    assert(Dtool_Ptr_DataNode->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_DataNode->_Dtool_ModuleClassInit(nullptr);
    Dtool_LUIInputHandler._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_DataNode);
    PyObject *dict = PyDict_New();
    Dtool_LUIInputHandler._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LUIInputHandler) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LUIInputHandler)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LUIInputHandler);
  }
}

/**
 * Python method tables for LUIRegion (LUIRegion)
 */
static PyMethodDef Dtool_Methods_LUIRegion[] = {
  {"make", (PyCFunction) &Dtool_LUIRegion_make_257, METH_VARARGS | METH_KEYWORDS | METH_STATIC, (const char *)Dtool_LUIRegion_make_257_comment},
  {"get_root", &Dtool_LUIRegion_get_root_258, METH_NOARGS, (const char *)Dtool_LUIRegion_get_root_258_comment},
  {"set_input_handler", &Dtool_LUIRegion_set_input_handler_260, METH_O, (const char *)Dtool_LUIRegion_set_input_handler_260_comment},
  {"get_input_handler", &Dtool_LUIRegion_get_input_handler_261, METH_NOARGS, (const char *)Dtool_LUIRegion_get_input_handler_261_comment},
  {"set_render_wireframe", &Dtool_LUIRegion_set_render_wireframe_262, METH_O, (const char *)Dtool_LUIRegion_set_render_wireframe_262_comment},
  {"toggle_render_wireframe", &Dtool_LUIRegion_toggle_render_wireframe_263, METH_NOARGS, (const char *)Dtool_LUIRegion_toggle_render_wireframe_263_comment},
  {"get_class_type", &Dtool_LUIRegion_get_class_type_264, METH_NOARGS | METH_STATIC, (const char *)Dtool_LUIRegion_get_class_type_264_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_LUIRegion[] = {
  {(char *)"root", &Dtool_LUIRegion_root_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_LUIRegion = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LUIRegion = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LUIRegion = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LUIRegion = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LUIRegion = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LUIRegion = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "lui.LUIRegion",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LUIRegion,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LUIRegion,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LUIRegion,
    &Dtool_SequenceMethods_LUIRegion,
    &Dtool_MappingMethods_LUIRegion,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LUIRegion,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LUIRegion,
    nullptr, // tp_members
    Dtool_Properties_LUIRegion,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LUIRegion,
    PyType_GenericAlloc,
    Dtool_new_LUIRegion,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LUIRegion,
  Dtool_UpcastInterface_LUIRegion,
  Dtool_DowncastInterface_LUIRegion,
  (CoerceFunction)Dtool_ConstCoerce_LUIRegion,
  (CoerceFunction)Dtool_Coerce_LUIRegion,
};

static void Dtool_PyModuleClassInit_LUIRegion(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_DisplayRegion != nullptr);
    assert(Dtool_Ptr_DisplayRegion->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_DisplayRegion->_Dtool_ModuleClassInit(nullptr);
    Dtool_LUIRegion._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_DisplayRegion);
    PyObject *dict = PyDict_New();
    Dtool_LUIRegion._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LUIRegion) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LUIRegion)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LUIRegion);
  }
}

/**
 * Python method tables for LUIFontPool (LUIFontPool)
 */
static PyMethodDef Dtool_Methods_LUIFontPool[] = {
  {"get_global_ptr", &Dtool_LUIFontPool_get_global_ptr_266, METH_NOARGS | METH_STATIC, (const char *)Dtool_LUIFontPool_get_global_ptr_266_comment},
  {"load_font", (PyCFunction) &Dtool_LUIFontPool_load_font_267, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LUIFontPool_load_font_267_comment},
  {"register_font", (PyCFunction) &Dtool_LUIFontPool_register_font_268, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LUIFontPool_register_font_268_comment},
  {"has_font", &Dtool_LUIFontPool_has_font_269, METH_O, (const char *)Dtool_LUIFontPool_has_font_269_comment},
  {"get_font", &Dtool_LUIFontPool_get_font_270, METH_O, (const char *)Dtool_LUIFontPool_get_font_270_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LUIFontPool = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

struct Dtool_PyTypedObject Dtool_LUIFontPool = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "lui.LUIFontPool",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LUIFontPool,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    nullptr, // tp_as_async
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LUIFontPool,
    nullptr, // tp_as_sequence
    nullptr, // tp_as_mapping
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    nullptr, // tp_as_buffer
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LUIFontPool,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LUIFontPool,
    PyType_GenericAlloc,
    Dtool_new_LUIFontPool,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LUIFontPool,
  Dtool_UpcastInterface_LUIFontPool,
  Dtool_DowncastInterface_LUIFontPool,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LUIFontPool(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_LUIFontPool._PyType.tp_base = (PyTypeObject *)Dtool_GetSuperBase();
    PyObject *dict = PyDict_New();
    Dtool_LUIFontPool._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LUIFontPool) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LUIFontPool)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LUIFontPool);
  }
}

/**
 * Python method tables for LUIText (LUIText)
 */
static PyMethodDef Dtool_Methods_LUIText[] = {
  {"set_font", &Dtool_LUIText_set_font_273, METH_O, (const char *)Dtool_LUIText_set_font_273_comment},
  {"get_font", &Dtool_LUIText_get_font_274, METH_NOARGS, (const char *)Dtool_LUIText_get_font_274_comment},
  {"set_text", &Dtool_LUIText_set_text_275, METH_O, (const char *)Dtool_LUIText_set_text_275_comment},
  {"get_text", &Dtool_LUIText_get_text_276, METH_NOARGS, (const char *)Dtool_LUIText_get_text_276_comment},
  {"set_font_size", &Dtool_LUIText_set_font_size_277, METH_O, (const char *)Dtool_LUIText_set_font_size_277_comment},
  {"get_font_size", &Dtool_LUIText_get_font_size_278, METH_NOARGS, (const char *)Dtool_LUIText_get_font_size_278_comment},
  {"set_wordwrap", &Dtool_LUIText_set_wordwrap_279, METH_O, (const char *)Dtool_LUIText_set_wordwrap_279_comment},
  {"get_wordwrap", &Dtool_LUIText_get_wordwrap_280, METH_NOARGS, (const char *)Dtool_LUIText_get_wordwrap_280_comment},
  {"get_char_index", &Dtool_LUIText_get_char_index_281, METH_O, (const char *)Dtool_LUIText_get_char_index_281_comment},
  {"get_char_pos", &Dtool_LUIText_get_char_pos_282, METH_O, (const char *)Dtool_LUIText_get_char_pos_282_comment},
  {"get_class_type", &Dtool_LUIText_get_class_type_291, METH_NOARGS | METH_STATIC, (const char *)Dtool_LUIText_get_class_type_291_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_LUIText[] = {
  {(char *)"font", &Dtool_LUIText_font_Getter, &Dtool_LUIText_font_Setter, nullptr, nullptr},
  {(char *)"text", &Dtool_LUIText_text_Getter, &Dtool_LUIText_text_Setter, nullptr, nullptr},
  {(char *)"font_size", &Dtool_LUIText_font_size_Getter, &Dtool_LUIText_font_size_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_LUIText = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LUIText = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LUIText = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LUIText = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LUIText = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LUIText = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "lui.LUIText",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LUIText,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LUIText,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LUIText,
    &Dtool_SequenceMethods_LUIText,
    &Dtool_MappingMethods_LUIText,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LUIText,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LUIText,
    nullptr, // tp_members
    Dtool_Properties_LUIText,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LUIText,
    PyType_GenericAlloc,
    Dtool_new_LUIText,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LUIText,
  Dtool_UpcastInterface_LUIText,
  Dtool_DowncastInterface_LUIText,
  (CoerceFunction)Dtool_ConstCoerce_LUIText,
  (CoerceFunction)Dtool_Coerce_LUIText,
};

static void Dtool_PyModuleClassInit_LUIText(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LUIObject(nullptr);
    Dtool_LUIText._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LUIObject);
    PyObject *dict = PyDict_New();
    Dtool_LUIText._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LUIText) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LUIText)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LUIText);
  }
}

/**
 * Python method tables for LUIEventData (LUIEventData)
 */
static PyMethodDef Dtool_Methods_LUIEventData[] = {
  {"get_name", &Dtool_LUIEventData_get_name_299, METH_NOARGS, (const char *)Dtool_LUIEventData_get_name_299_comment},
  {"get_sender", &Dtool_LUIEventData_get_sender_300, METH_NOARGS, (const char *)Dtool_LUIEventData_get_sender_300_comment},
  {"get_coordinates", &Dtool_LUIEventData_get_coordinates_301, METH_NOARGS, (const char *)Dtool_LUIEventData_get_coordinates_301_comment},
  {"get_message", &Dtool_LUIEventData_get_message_302, METH_NOARGS, (const char *)Dtool_LUIEventData_get_message_302_comment},
  {"get_key_modifiers", &Dtool_LUIEventData_get_key_modifiers_303, METH_NOARGS, (const char *)Dtool_LUIEventData_get_key_modifiers_303_comment},
  {"get_modifier_state", &Dtool_LUIEventData_get_modifier_state_304, METH_O, (const char *)Dtool_LUIEventData_get_modifier_state_304_comment},
  {"get_class_type", &Dtool_LUIEventData_get_class_type_314, METH_NOARGS | METH_STATIC, (const char *)Dtool_LUIEventData_get_class_type_314_comment},
  {"upcast_to_CallbackData", &Dtool_LUIEventData_upcast_to_CallbackData_294, METH_NOARGS, (const char *)Dtool_LUIEventData_upcast_to_CallbackData_294_comment},
  {"upcast_to_ReferenceCount", &Dtool_LUIEventData_upcast_to_ReferenceCount_296, METH_NOARGS, (const char *)Dtool_LUIEventData_upcast_to_ReferenceCount_296_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_LUIEventData[] = {
  {(char *)"name", &Dtool_LUIEventData_name_Getter, nullptr, nullptr, nullptr},
  {(char *)"sender", &Dtool_LUIEventData_sender_Getter, nullptr, nullptr, nullptr},
  {(char *)"coordinates", &Dtool_LUIEventData_coordinates_Getter, nullptr, nullptr, nullptr},
  {(char *)"message", &Dtool_LUIEventData_message_Getter, nullptr, nullptr, nullptr},
  {(char *)"key_modifiers", &Dtool_LUIEventData_key_modifiers_Getter, nullptr, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_LUIEventData = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LUIEventData = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LUIEventData = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LUIEventData = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LUIEventData = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LUIEventData = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "lui.LUIEventData",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LUIEventData,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LUIEventData,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LUIEventData,
    &Dtool_SequenceMethods_LUIEventData,
    &Dtool_MappingMethods_LUIEventData,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LUIEventData,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LUIEventData,
    nullptr, // tp_members
    Dtool_Properties_LUIEventData,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LUIEventData,
    PyType_GenericAlloc,
    Dtool_new_LUIEventData,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LUIEventData,
  Dtool_UpcastInterface_LUIEventData,
  Dtool_DowncastInterface_LUIEventData,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LUIEventData(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_CallbackData != nullptr);
    assert(Dtool_Ptr_CallbackData->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_CallbackData->_Dtool_ModuleClassInit(nullptr);
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_LUIEventData._PyType.tp_bases = PyTuple_Pack(2, (PyTypeObject *)Dtool_Ptr_CallbackData, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    PyObject *dict = _PyDict_NewPresized(7);
    Dtool_LUIEventData._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    // enum LUIEventData::KeyModifiers;
    PyDict_SetItemString(dict, "KM_shift", Dtool_WrapValue(LUIEventData::KM_shift));
    PyDict_SetItemString(dict, "KM_alt", Dtool_WrapValue(LUIEventData::KM_alt));
    PyDict_SetItemString(dict, "KM_ctrl", Dtool_WrapValue(LUIEventData::KM_ctrl));
    if (PyType_Ready((PyTypeObject *)&Dtool_LUIEventData) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LUIEventData)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LUIEventData);
  }
}

/**
 * Python method tables for LUIBaseLayout (LUIBaseLayout)
 */
static PyMethodDef Dtool_Methods_LUIBaseLayout[] = {
  {"add", (PyCFunction) &Dtool_LUIBaseLayout_add_316, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LUIBaseLayout_add_316_comment},
  {"reset", &Dtool_LUIBaseLayout_reset_317, METH_NOARGS, (const char *)Dtool_LUIBaseLayout_reset_317_comment},
  {"remove_cell", &Dtool_LUIBaseLayout_remove_cell_318, METH_O, (const char *)Dtool_LUIBaseLayout_remove_cell_318_comment},
  {"cell", &Dtool_LUIBaseLayout_cell_319, METH_VARARGS, (const char *)Dtool_LUIBaseLayout_cell_319_comment},
  {"set_spacing", &Dtool_LUIBaseLayout_set_spacing_320, METH_O, (const char *)Dtool_LUIBaseLayout_set_spacing_320_comment},
  {"get_spacing", &Dtool_LUIBaseLayout_get_spacing_321, METH_NOARGS, (const char *)Dtool_LUIBaseLayout_get_spacing_321_comment},
  {"get_class_type", &Dtool_LUIBaseLayout_get_class_type_323, METH_NOARGS | METH_STATIC, (const char *)Dtool_LUIBaseLayout_get_class_type_323_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyGetSetDef Dtool_Properties_LUIBaseLayout[] = {
  {(char *)"spacing", &Dtool_LUIBaseLayout_spacing_Getter, &Dtool_LUIBaseLayout_spacing_Setter, nullptr, nullptr},
  {nullptr},
};

static PyNumberMethods Dtool_NumberMethods_LUIBaseLayout = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LUIBaseLayout = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LUIBaseLayout = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LUIBaseLayout = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LUIBaseLayout = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LUIBaseLayout = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "lui.LUIBaseLayout",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LUIBaseLayout,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LUIBaseLayout,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LUIBaseLayout,
    &Dtool_SequenceMethods_LUIBaseLayout,
    &Dtool_MappingMethods_LUIBaseLayout,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LUIBaseLayout,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LUIBaseLayout,
    nullptr, // tp_members
    Dtool_Properties_LUIBaseLayout,
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LUIBaseLayout,
    PyType_GenericAlloc,
    Dtool_new_LUIBaseLayout,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LUIBaseLayout,
  Dtool_UpcastInterface_LUIBaseLayout,
  Dtool_DowncastInterface_LUIBaseLayout,
  nullptr,
  nullptr,
};

static void Dtool_PyModuleClassInit_LUIBaseLayout(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LUIObject(nullptr);
    Dtool_LUIBaseLayout._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LUIObject);
    PyObject *dict = PyDict_New();
    Dtool_LUIBaseLayout._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LUIBaseLayout) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LUIBaseLayout)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LUIBaseLayout);
  }
}

/**
 * Python method tables for LUIVerticalLayout (LUIVerticalLayout)
 */
static PyMethodDef Dtool_Methods_LUIVerticalLayout[] = {
  {"get_class_type", &Dtool_LUIVerticalLayout_get_class_type_327, METH_NOARGS | METH_STATIC, (const char *)Dtool_LUIVerticalLayout_get_class_type_327_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LUIVerticalLayout = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LUIVerticalLayout = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LUIVerticalLayout = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LUIVerticalLayout = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LUIVerticalLayout = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LUIVerticalLayout = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "lui.LUIVerticalLayout",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LUIVerticalLayout,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LUIVerticalLayout,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LUIVerticalLayout,
    &Dtool_SequenceMethods_LUIVerticalLayout,
    &Dtool_MappingMethods_LUIVerticalLayout,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LUIVerticalLayout,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LUIVerticalLayout,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LUIVerticalLayout,
    PyType_GenericAlloc,
    Dtool_new_LUIVerticalLayout,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LUIVerticalLayout,
  Dtool_UpcastInterface_LUIVerticalLayout,
  Dtool_DowncastInterface_LUIVerticalLayout,
  (CoerceFunction)Dtool_ConstCoerce_LUIVerticalLayout,
  (CoerceFunction)Dtool_Coerce_LUIVerticalLayout,
};

static void Dtool_PyModuleClassInit_LUIVerticalLayout(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LUIBaseLayout(nullptr);
    Dtool_LUIVerticalLayout._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LUIBaseLayout);
    PyObject *dict = PyDict_New();
    Dtool_LUIVerticalLayout._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LUIVerticalLayout) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LUIVerticalLayout)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LUIVerticalLayout);
  }
}

/**
 * Python method tables for LUIHorizontalLayout (LUIHorizontalLayout)
 */
static PyMethodDef Dtool_Methods_LUIHorizontalLayout[] = {
  {"get_class_type", &Dtool_LUIHorizontalLayout_get_class_type_331, METH_NOARGS | METH_STATIC, (const char *)Dtool_LUIHorizontalLayout_get_class_type_331_comment},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LUIHorizontalLayout = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LUIHorizontalLayout = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LUIHorizontalLayout = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LUIHorizontalLayout = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LUIHorizontalLayout = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LUIHorizontalLayout = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "lui.LUIHorizontalLayout",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LUIHorizontalLayout,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LUIHorizontalLayout,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LUIHorizontalLayout,
    &Dtool_SequenceMethods_LUIHorizontalLayout,
    &Dtool_MappingMethods_LUIHorizontalLayout,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LUIHorizontalLayout,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
    nullptr, // tp_doc
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LUIHorizontalLayout,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LUIHorizontalLayout,
    PyType_GenericAlloc,
    Dtool_new_LUIHorizontalLayout,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LUIHorizontalLayout,
  Dtool_UpcastInterface_LUIHorizontalLayout,
  Dtool_DowncastInterface_LUIHorizontalLayout,
  (CoerceFunction)Dtool_ConstCoerce_LUIHorizontalLayout,
  (CoerceFunction)Dtool_Coerce_LUIHorizontalLayout,
};

static void Dtool_PyModuleClassInit_LUIHorizontalLayout(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    Dtool_PyModuleClassInit_LUIBaseLayout(nullptr);
    Dtool_LUIHorizontalLayout._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)&Dtool_LUIBaseLayout);
    PyObject *dict = PyDict_New();
    Dtool_LUIHorizontalLayout._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LUIHorizontalLayout) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LUIHorizontalLayout)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LUIHorizontalLayout);
  }
}

/**
 * Python method tables for LUIAtlasPacker (LUIAtlasPacker)
 */
static PyMethodDef Dtool_Methods_LUIAtlasPacker[] = {
  {"find_position", (PyCFunction) &Dtool_LUIAtlasPacker_find_position_335, METH_VARARGS | METH_KEYWORDS, (const char *)Dtool_LUIAtlasPacker_find_position_335_comment},
  {"__copy__", &copy_from_copy_constructor, METH_NOARGS, nullptr},
  {"__deepcopy__", &map_deepcopy_to_copy, METH_VARARGS, nullptr},
  {nullptr, nullptr, 0, nullptr}
};

static PyNumberMethods Dtool_NumberMethods_LUIAtlasPacker = {
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr, // nb_long
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
#if PY_MAJOR_VERSION < 3
  nullptr,
#endif
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#if PY_VERSION_HEX >= 0x02050000
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x03050000
  nullptr,
  nullptr,
#endif
};

static PySequenceMethods Dtool_SequenceMethods_LUIAtlasPacker = {
  nullptr,
  nullptr,
  nullptr,
  nullptr,
  nullptr, // sq_slice
  nullptr,
  nullptr, // sq_ass_slice
  nullptr,
  nullptr,
  nullptr,
};

static PyMappingMethods Dtool_MappingMethods_LUIAtlasPacker = {
  nullptr,
  nullptr,
  nullptr,
};

static PyBufferProcs Dtool_BufferProcs_LUIAtlasPacker = {
#if PY_MAJOR_VERSION < 3
  nullptr,
  nullptr,
  nullptr,
  nullptr,
#endif
#if PY_VERSION_HEX >= 0x02060000
  nullptr,
  nullptr,
#endif
};

#if PY_VERSION_HEX >= 0x03050000
static PyAsyncMethods Dtool_AsyncMethods_LUIAtlasPacker = {
  nullptr,
  nullptr,
  nullptr,
};
#endif

struct Dtool_PyTypedObject Dtool_LUIAtlasPacker = {
  {
    PyVarObject_HEAD_INIT(nullptr, 0)
    "lui.LUIAtlasPacker",
    sizeof(Dtool_PyInstDef),
    0, // tp_itemsize
    &Dtool_FreeInstance_LUIAtlasPacker,
#if PY_VERSION_HEX >= 0x03080000
    0, // tp_vectorcall_offset
#else
    nullptr,
#endif
    nullptr,
    nullptr,
#if PY_VERSION_HEX >= 0x03050000
    &Dtool_AsyncMethods_LUIAtlasPacker,
#elif PY_MAJOR_VERSION >= 3
    nullptr, // tp_reserved
#else
    nullptr, // tp_compare
#endif
    nullptr,
    &Dtool_NumberMethods_LUIAtlasPacker,
    &Dtool_SequenceMethods_LUIAtlasPacker,
    &Dtool_MappingMethods_LUIAtlasPacker,
    nullptr, // tp_hash
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    &Dtool_BufferProcs_LUIAtlasPacker,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_CHECKTYPES,
#ifdef NDEBUG
    0,
#else
    "/**\n"
    " * @brief Helper class used by the LUIAtlasPacker\n"
    " * @details This is a helper class which is used by the LUIAtlasPacker to generate\n"
    " *   an atlas. It provides functionality to find positions for sprites in a texture.\n"
    " *\n"
    " */",
#endif
    nullptr, // tp_traverse
    nullptr, // tp_clear
    nullptr, // tp_richcompare
    0, // tp_weaklistoffset
    nullptr,
    nullptr,
    Dtool_Methods_LUIAtlasPacker,
    nullptr, // tp_members
    nullptr, // tp_getset
    nullptr, // tp_base
    nullptr, // tp_dict
    nullptr,
    nullptr,
    0, // tp_dictoffset
    Dtool_Init_LUIAtlasPacker,
    PyType_GenericAlloc,
    Dtool_new_LUIAtlasPacker,
    PyObject_Del,
    nullptr, // tp_is_gc
    nullptr, // tp_bases
    nullptr, // tp_mro
    nullptr, // tp_cache
    nullptr, // tp_subclasses
    nullptr, // tp_weaklist
    nullptr, // tp_del
#if PY_VERSION_HEX >= 0x02060000
    0, // tp_version_tag
#endif
#if PY_VERSION_HEX >= 0x03040000
    nullptr, // tp_finalize
#endif
#if PY_VERSION_HEX >= 0x03080000
    nullptr, // tp_vectorcall
#endif
  },
  TypeHandle::none(),
  Dtool_PyModuleClassInit_LUIAtlasPacker,
  Dtool_UpcastInterface_LUIAtlasPacker,
  Dtool_DowncastInterface_LUIAtlasPacker,
  (CoerceFunction)Dtool_ConstCoerce_LUIAtlasPacker,
  (CoerceFunction)Dtool_Coerce_LUIAtlasPacker,
};

static void Dtool_PyModuleClassInit_LUIAtlasPacker(PyObject *module) {
  (void) module; // Unused
  static bool initdone = false;
  if (!initdone) {
    initdone = true;
    // Dependent objects
    assert(Dtool_Ptr_ReferenceCount != nullptr);
    assert(Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit != nullptr);
    Dtool_Ptr_ReferenceCount->_Dtool_ModuleClassInit(nullptr);
    Dtool_LUIAtlasPacker._PyType.tp_bases = PyTuple_Pack(1, (PyTypeObject *)Dtool_Ptr_ReferenceCount);
    PyObject *dict = PyDict_New();
    Dtool_LUIAtlasPacker._PyType.tp_dict = dict;
    PyDict_SetItemString(dict, "DtoolClassDict", dict);
    if (PyType_Ready((PyTypeObject *)&Dtool_LUIAtlasPacker) < 0) {
      Dtool_Raise_TypeError("PyType_Ready(LUIAtlasPacker)");
      return;
    }
    Py_INCREF((PyTypeObject *)&Dtool_LUIAtlasPacker);
  }
}


/**
 * Module Object Linker ..
 */
void Dtool_lui_RegisterTypes() {
  TypeRegistry *registry = TypeRegistry::ptr();
  nassertv(registry != nullptr);
  {
    LUIBaseElement::init_type();
    TypeHandle handle = LUIBaseElement::get_class_type();
    Dtool_LUIBaseElement._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LUIBaseElement);
  }
  {
    LUIObject::init_type();
    TypeHandle handle = LUIObject::get_class_type();
    Dtool_LUIObject._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LUIObject);
  }
  {
    LUISprite::init_type();
    TypeHandle handle = LUISprite::get_class_type();
    Dtool_LUISprite._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LUISprite);
  }
  {
    LUIInputHandler::init_type();
    TypeHandle handle = LUIInputHandler::get_class_type();
    Dtool_LUIInputHandler._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LUIInputHandler);
  }
  {
    LUIRegion::init_type();
    TypeHandle handle = LUIRegion::get_class_type();
    Dtool_LUIRegion._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LUIRegion);
  }
  {
    LUIText::init_type();
    TypeHandle handle = LUIText::get_class_type();
    Dtool_LUIText._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LUIText);
  }
  {
    LUIEventData::init_type();
    TypeHandle handle = LUIEventData::get_class_type();
    Dtool_LUIEventData._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LUIEventData);
  }
  {
    LUIBaseLayout::init_type();
    TypeHandle handle = LUIBaseLayout::get_class_type();
    Dtool_LUIBaseLayout._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LUIBaseLayout);
  }
  {
    LUIVerticalLayout::init_type();
    TypeHandle handle = LUIVerticalLayout::get_class_type();
    Dtool_LUIVerticalLayout._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LUIVerticalLayout);
  }
  {
    LUIHorizontalLayout::init_type();
    TypeHandle handle = LUIHorizontalLayout::get_class_type();
    Dtool_LUIHorizontalLayout._type = handle;
    registry->record_python_type(handle, (PyObject *)&Dtool_LUIHorizontalLayout);
  }
}

void Dtool_lui_BuildInstants(PyObject *module) {
  (void) module;
  // LUIColorable
  Dtool_PyModuleClassInit_LUIColorable(module);
  PyModule_AddObject(module, "LUIColorable", (PyObject *)&Dtool_LUIColorable);
  // LUIBounds
  Dtool_PyModuleClassInit_LUIBounds(module);
  PyModule_AddObject(module, "LUIBounds", (PyObject *)&Dtool_LUIBounds);
  // LUIRect
  Dtool_PyModuleClassInit_LUIRect(module);
  PyModule_AddObject(module, "LUIRect", (PyObject *)&Dtool_LUIRect);
  // LUIBaseElement
  Dtool_PyModuleClassInit_LUIBaseElement(module);
  PyModule_AddObject(module, "LUIBaseElement", (PyObject *)&Dtool_LUIBaseElement);
  // LUIObject
  Dtool_PyModuleClassInit_LUIObject(module);
  PyModule_AddObject(module, "LUIObject", (PyObject *)&Dtool_LUIObject);
  // LUIAtlas
  Dtool_PyModuleClassInit_LUIAtlas(module);
  PyModule_AddObject(module, "LUIAtlas", (PyObject *)&Dtool_LUIAtlas);
  // LUIAtlasPool
  Dtool_PyModuleClassInit_LUIAtlasPool(module);
  PyModule_AddObject(module, "LUIAtlasPool", (PyObject *)&Dtool_LUIAtlasPool);
  // LUISprite
  Dtool_PyModuleClassInit_LUISprite(module);
  PyModule_AddObject(module, "LUISprite", (PyObject *)&Dtool_LUISprite);
  // LUIElementIterator
  Dtool_PyModuleClassInit_LUIElementIterator(module);
  PyModule_AddObject(module, "LUIElementIterator", (PyObject *)&Dtool_LUIElementIterator);
  // LUIRoot
  Dtool_PyModuleClassInit_LUIRoot(module);
  PyModule_AddObject(module, "LUIRoot", (PyObject *)&Dtool_LUIRoot);
  // LUIInputHandler
  Dtool_PyModuleClassInit_LUIInputHandler(module);
  PyModule_AddObject(module, "LUIInputHandler", (PyObject *)&Dtool_LUIInputHandler);
  // LUIRegion
  Dtool_PyModuleClassInit_LUIRegion(module);
  PyModule_AddObject(module, "LUIRegion", (PyObject *)&Dtool_LUIRegion);
  // LUIFontPool
  Dtool_PyModuleClassInit_LUIFontPool(module);
  PyModule_AddObject(module, "LUIFontPool", (PyObject *)&Dtool_LUIFontPool);
  // LUIText
  Dtool_PyModuleClassInit_LUIText(module);
  PyModule_AddObject(module, "LUIText", (PyObject *)&Dtool_LUIText);
  // LUIEventData
  Dtool_PyModuleClassInit_LUIEventData(module);
  PyModule_AddObject(module, "LUIEventData", (PyObject *)&Dtool_LUIEventData);
  // LUIBaseLayout
  Dtool_PyModuleClassInit_LUIBaseLayout(module);
  PyModule_AddObject(module, "LUIBaseLayout", (PyObject *)&Dtool_LUIBaseLayout);
  // LUIVerticalLayout
  Dtool_PyModuleClassInit_LUIVerticalLayout(module);
  PyModule_AddObject(module, "LUIVerticalLayout", (PyObject *)&Dtool_LUIVerticalLayout);
  // LUIHorizontalLayout
  Dtool_PyModuleClassInit_LUIHorizontalLayout(module);
  PyModule_AddObject(module, "LUIHorizontalLayout", (PyObject *)&Dtool_LUIHorizontalLayout);
  // LUIAtlasPacker
  Dtool_PyModuleClassInit_LUIAtlasPacker(module);
  PyModule_AddObject(module, "LUIAtlasPacker", (PyObject *)&Dtool_LUIAtlasPacker);
}

static PyMethodDef python_simple_funcs[] = {
  // Support Function For Dtool_types ... for now in each module ??
  {"Dtool_BorrowThisReference", &Dtool_BorrowThisReference, METH_VARARGS, "Used to borrow 'this' pointer (to, from)\nAssumes no ownership."},
  {nullptr, nullptr, 0, nullptr}
};

#ifdef LINK_ALL_STATIC
extern const struct LibraryDef lui_moddef = {python_simple_funcs, exports, nullptr};
#else
extern const struct LibraryDef lui_moddef = {python_simple_funcs, exports, imports};
#endif
static InterrogateModuleDef _in_module_def = {
  1687635855,  /* file_identifier */
  "lui",  /* library_name */
  "190L",  /* library_hash_name */
  "lui",  /* module_name */
  "interrogate.in",  /* database_filename */
  nullptr,  /* unique_names */
  0,  /* num_unique_names */
  nullptr,  /* fptrs */
  0,  /* num_fptrs */
  1,  /* first_index */
  685  /* next_index */
};

Configure(_in_configure_lui);
ConfigureFn(_in_configure_lui) {
  interrogate_request_module(&_in_module_def);
}

